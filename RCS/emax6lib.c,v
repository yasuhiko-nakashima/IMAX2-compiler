head	1.190;
access;
symbols;
locks
	nakashim:1.190; strict;
comment	@ * @;


1.190
date	2022.10.28.09.11.09;	author nakashim;	state Exp;
branches;
next	1.189;

1.189
date	2022.10.28.08.41.56;	author nakashim;	state Exp;
branches;
next	1.188;

1.188
date	2022.10.27.04.20.25;	author nakashim;	state Exp;
branches;
next	1.187;

1.187
date	2022.10.27.00.43.27;	author nakashim;	state Exp;
branches;
next	1.186;

1.186
date	2022.10.25.23.19.07;	author nakashim;	state Exp;
branches;
next	1.185;

1.185
date	2022.10.21.13.45.19;	author nakashim;	state Exp;
branches;
next	1.184;

1.184
date	2022.10.16.15.06.24;	author nakashim;	state Exp;
branches;
next	1.183;

1.183
date	2022.10.16.14.10.45;	author nakashim;	state Exp;
branches;
next	1.182;

1.182
date	2022.10.11.08.05.12;	author nakashim;	state Exp;
branches;
next	1.181;

1.181
date	2022.10.10.11.43.16;	author nakashim;	state Exp;
branches;
next	1.180;

1.180
date	2022.10.09.00.22.22;	author nakashim;	state Exp;
branches;
next	1.179;

1.179
date	2022.10.07.10.30.22;	author nakashim;	state Exp;
branches;
next	1.178;

1.178
date	2022.09.10.02.23.36;	author nakashim;	state Exp;
branches;
next	1.177;

1.177
date	2022.07.25.05.43.56;	author nakashim;	state Exp;
branches;
next	1.176;

1.176
date	2022.04.29.14.00.49;	author nakashim;	state Exp;
branches;
next	1.175;

1.175
date	2022.04.27.09.04.50;	author nakashim;	state Exp;
branches;
next	1.174;

1.174
date	2022.04.18.23.41.42;	author nakashim;	state Exp;
branches;
next	1.173;

1.173
date	2022.03.11.08.20.46;	author nakashim;	state Exp;
branches;
next	1.172;

1.172
date	2022.03.11.04.15.58;	author nakashim;	state Exp;
branches;
next	1.171;

1.171
date	2022.03.11.03.22.09;	author nakashim;	state Exp;
branches;
next	1.170;

1.170
date	2022.03.10.12.12.56;	author nakashim;	state Exp;
branches;
next	1.169;

1.169
date	2022.03.04.03.40.40;	author nakashim;	state Exp;
branches;
next	1.168;

1.168
date	2022.03.03.14.58.09;	author nakashim;	state Exp;
branches;
next	1.167;

1.167
date	2022.02.19.00.49.30;	author nakashim;	state Exp;
branches;
next	1.166;

1.166
date	2022.01.28.00.44.07;	author nakashim;	state Exp;
branches;
next	1.165;

1.165
date	2022.01.27.01.36.39;	author nakashim;	state Exp;
branches;
next	1.164;

1.164
date	2022.01.26.03.30.40;	author nakashim;	state Exp;
branches;
next	1.163;

1.163
date	2022.01.25.23.55.20;	author nakashim;	state Exp;
branches;
next	1.162;

1.162
date	2022.01.03.03.59.13;	author nakashim;	state Exp;
branches;
next	1.161;

1.161
date	2021.12.27.05.54.28;	author nakashim;	state Exp;
branches;
next	1.160;

1.160
date	2021.12.21.03.59.52;	author nakashim;	state Exp;
branches;
next	1.159;

1.159
date	2021.12.08.00.59.00;	author nakashim;	state Exp;
branches;
next	1.158;

1.158
date	2021.11.01.00.00.50;	author nakashim;	state Exp;
branches;
next	1.157;

1.157
date	2021.10.31.23.04.40;	author nakashim;	state Exp;
branches;
next	1.156;

1.156
date	2021.10.31.09.44.08;	author nakashim;	state Exp;
branches;
next	1.155;

1.155
date	2021.09.21.07.42.15;	author nakashim;	state Exp;
branches;
next	1.154;

1.154
date	2021.08.11.04.45.48;	author nakashim;	state Exp;
branches;
next	1.153;

1.153
date	2021.07.13.06.56.03;	author nakashim;	state Exp;
branches;
next	1.152;

1.152
date	2021.07.10.06.37.23;	author nakashim;	state Exp;
branches;
next	1.151;

1.151
date	2021.07.07.00.45.22;	author nakashim;	state Exp;
branches;
next	1.150;

1.150
date	2021.07.06.23.24.22;	author nakashim;	state Exp;
branches;
next	1.149;

1.149
date	2021.07.06.01.56.04;	author nakashim;	state Exp;
branches;
next	1.148;

1.148
date	2021.07.04.05.43.53;	author nakashim;	state Exp;
branches;
next	1.147;

1.147
date	2021.07.02.14.03.27;	author nakashim;	state Exp;
branches;
next	1.146;

1.146
date	2021.07.02.13.42.49;	author nakashim;	state Exp;
branches;
next	1.145;

1.145
date	2021.06.23.05.38.01;	author nakashim;	state Exp;
branches;
next	1.144;

1.144
date	2021.06.23.05.06.24;	author nakashim;	state Exp;
branches;
next	1.143;

1.143
date	2021.06.13.13.03.26;	author nakashim;	state Exp;
branches;
next	1.142;

1.142
date	2021.06.13.07.02.06;	author nakashim;	state Exp;
branches;
next	1.141;

1.141
date	2021.06.11.14.29.44;	author nakashim;	state Exp;
branches;
next	1.140;

1.140
date	2021.06.11.14.09.44;	author nakashim;	state Exp;
branches;
next	1.139;

1.139
date	2021.06.11.14.06.06;	author nakashim;	state Exp;
branches;
next	1.138;

1.138
date	2021.06.10.13.44.00;	author nakashim;	state Exp;
branches;
next	1.137;

1.137
date	2021.06.06.08.39.12;	author nakashim;	state Exp;
branches;
next	1.136;

1.136
date	2021.06.06.06.23.46;	author nakashim;	state Exp;
branches;
next	1.135;

1.135
date	2021.06.02.10.37.25;	author nakashim;	state Exp;
branches;
next	1.134;

1.134
date	2021.03.19.05.41.33;	author nakashim;	state Exp;
branches;
next	1.133;

1.133
date	2021.03.19.01.07.24;	author nakashim;	state Exp;
branches;
next	1.132;

1.132
date	2021.02.28.05.58.08;	author nakashim;	state Exp;
branches;
next	1.131;

1.131
date	2020.12.11.05.08.21;	author nakashim;	state Exp;
branches;
next	1.130;

1.130
date	2020.11.29.14.42.48;	author nakashim;	state Exp;
branches;
next	1.129;

1.129
date	2020.11.29.13.12.45;	author nakashim;	state Exp;
branches;
next	1.128;

1.128
date	2020.11.29.07.33.45;	author nakashim;	state Exp;
branches;
next	1.127;

1.127
date	2020.11.25.00.52.40;	author nakashim;	state Exp;
branches;
next	1.126;

1.126
date	2020.11.25.00.18.08;	author nakashim;	state Exp;
branches;
next	1.125;

1.125
date	2020.11.16.13.15.28;	author nakashim;	state Exp;
branches;
next	1.124;

1.124
date	2020.11.10.23.24.35;	author nakashim;	state Exp;
branches;
next	1.123;

1.123
date	2020.11.07.12.15.55;	author nakashim;	state Exp;
branches;
next	1.122;

1.122
date	2020.10.12.15.03.20;	author nakashim;	state Exp;
branches;
next	1.121;

1.121
date	2020.05.27.04.04.18;	author nakashim;	state Exp;
branches;
next	1.120;

1.120
date	2020.05.05.13.55.38;	author nakashim;	state Exp;
branches;
next	1.119;

1.119
date	2020.04.26.02.41.31;	author nakashim;	state Exp;
branches;
next	1.118;

1.118
date	2020.04.25.11.47.55;	author nakashim;	state Exp;
branches;
next	1.117;

1.117
date	2020.04.25.07.35.15;	author nakashim;	state Exp;
branches;
next	1.116;

1.116
date	2020.04.18.13.01.55;	author nakashim;	state Exp;
branches;
next	1.115;

1.115
date	2019.10.20.02.52.15;	author nakashim;	state Exp;
branches;
next	1.114;

1.114
date	2019.08.18.11.53.57;	author nakashim;	state Exp;
branches;
next	1.113;

1.113
date	2019.08.18.11.40.02;	author nakashim;	state Exp;
branches;
next	1.112;

1.112
date	2019.07.30.07.29.43;	author nakashim;	state Exp;
branches;
next	1.111;

1.111
date	2019.07.23.11.51.28;	author nakashim;	state Exp;
branches;
next	1.110;

1.110
date	2019.07.20.06.19.35;	author nakashim;	state Exp;
branches;
next	1.109;

1.109
date	2019.02.28.12.52.15;	author nakashim;	state Exp;
branches;
next	1.108;

1.108
date	2019.02.17.12.45.35;	author nakashim;	state Exp;
branches;
next	1.107;

1.107
date	2018.12.24.10.49.09;	author nakashim;	state Exp;
branches;
next	1.106;

1.106
date	2018.12.18.22.59.27;	author nakashim;	state Exp;
branches;
next	1.105;

1.105
date	2018.12.17.01.30.01;	author nakashim;	state Exp;
branches;
next	1.104;

1.104
date	2018.12.09.04.39.32;	author nakashim;	state Exp;
branches;
next	1.103;

1.103
date	2018.12.09.03.31.28;	author nakashim;	state Exp;
branches;
next	1.102;

1.102
date	2018.12.07.02.51.33;	author nakashim;	state Exp;
branches;
next	1.101;

1.101
date	2018.11.30.01.09.23;	author nakashim;	state Exp;
branches;
next	1.100;

1.100
date	2018.11.22.06.28.06;	author nakashim;	state Exp;
branches;
next	1.99;

1.99
date	2018.11.21.06.19.30;	author nakashim;	state Exp;
branches;
next	1.98;

1.98
date	2018.11.15.23.39.16;	author nakashim;	state Exp;
branches;
next	1.97;

1.97
date	2018.11.14.01.43.29;	author nakashim;	state Exp;
branches;
next	1.96;

1.96
date	2018.10.18.12.43.04;	author nakashim;	state Exp;
branches;
next	1.95;

1.95
date	2018.09.10.11.35.21;	author nakashim;	state Exp;
branches;
next	1.94;

1.94
date	2018.05.14.02.10.29;	author nakashim;	state Exp;
branches;
next	1.93;

1.93
date	2018.02.22.02.02.01;	author nakashim;	state Exp;
branches;
next	1.92;

1.92
date	2018.02.21.03.17.18;	author nakashim;	state Exp;
branches;
next	1.91;

1.91
date	2018.02.20.01.12.36;	author nakashim;	state Exp;
branches;
next	1.90;

1.90
date	2018.02.16.07.27.22;	author nakashim;	state Exp;
branches;
next	1.89;

1.89
date	2018.02.16.06.37.02;	author nakashim;	state Exp;
branches;
next	1.88;

1.88
date	2018.02.14.10.01.46;	author nakashim;	state Exp;
branches;
next	1.87;

1.87
date	2018.02.13.01.55.09;	author nakashim;	state Exp;
branches;
next	1.86;

1.86
date	2017.12.24.14.12.32;	author nakashim;	state Exp;
branches;
next	1.85;

1.85
date	2017.12.05.12.52.05;	author nakashim;	state Exp;
branches;
next	1.84;

1.84
date	2017.12.05.12.20.56;	author nakashim;	state Exp;
branches;
next	1.83;

1.83
date	2017.09.12.09.15.58;	author nakashim;	state Exp;
branches;
next	1.82;

1.82
date	2017.09.05.05.22.18;	author nakashim;	state Exp;
branches;
next	1.81;

1.81
date	2017.08.23.15.24.52;	author nakashim;	state Exp;
branches;
next	1.80;

1.80
date	2017.08.20.10.48.20;	author nakashim;	state Exp;
branches;
next	1.79;

1.79
date	2017.08.19.04.38.04;	author nakashim;	state Exp;
branches;
next	1.78;

1.78
date	2017.08.18.12.27.17;	author nakashim;	state Exp;
branches;
next	1.77;

1.77
date	2017.08.16.15.32.32;	author nakashim;	state Exp;
branches;
next	1.76;

1.76
date	2017.08.16.06.33.55;	author nakashim;	state Exp;
branches;
next	1.75;

1.75
date	2017.08.14.07.46.35;	author nakashim;	state Exp;
branches;
next	1.74;

1.74
date	2017.08.13.13.36.12;	author nakashim;	state Exp;
branches;
next	1.73;

1.73
date	2017.08.12.08.51.58;	author nakashim;	state Exp;
branches;
next	1.72;

1.72
date	2017.07.30.06.26.49;	author nakashim;	state Exp;
branches;
next	1.71;

1.71
date	2017.07.25.07.18.47;	author nakashim;	state Exp;
branches;
next	1.70;

1.70
date	2017.07.11.00.01.26;	author nakashim;	state Exp;
branches;
next	1.69;

1.69
date	2017.06.19.05.49.11;	author nakashim;	state Exp;
branches;
next	1.68;

1.68
date	2017.06.11.10.17.24;	author nakashim;	state Exp;
branches;
next	1.67;

1.67
date	2017.06.10.08.10.36;	author nakashim;	state Exp;
branches;
next	1.66;

1.66
date	2017.06.04.14.32.23;	author nakashim;	state Exp;
branches;
next	1.65;

1.65
date	2017.06.04.09.12.29;	author nakashim;	state Exp;
branches;
next	1.64;

1.64
date	2017.06.03.23.40.07;	author nakashim;	state Exp;
branches;
next	1.63;

1.63
date	2017.06.03.13.23.59;	author nakashim;	state Exp;
branches;
next	1.62;

1.62
date	2017.06.03.12.42.13;	author nakashim;	state Exp;
branches;
next	1.61;

1.61
date	2017.06.03.09.46.43;	author nakashim;	state Exp;
branches;
next	1.60;

1.60
date	2017.06.01.23.42.07;	author nakashim;	state Exp;
branches;
next	1.59;

1.59
date	2017.05.30.08.40.40;	author nakashim;	state Exp;
branches;
next	1.58;

1.58
date	2017.05.29.06.17.53;	author nakashim;	state Exp;
branches;
next	1.57;

1.57
date	2017.05.27.12.26.45;	author nakashim;	state Exp;
branches;
next	1.56;

1.56
date	2017.04.28.01.03.35;	author nakashim;	state Exp;
branches;
next	1.55;

1.55
date	2017.04.23.13.09.22;	author nakashim;	state Exp;
branches;
next	1.54;

1.54
date	2017.04.21.03.30.17;	author nakashim;	state Exp;
branches;
next	1.53;

1.53
date	2017.02.28.14.50.26;	author nakashim;	state Exp;
branches;
next	1.52;

1.52
date	2017.02.23.11.15.32;	author nakashim;	state Exp;
branches;
next	1.51;

1.51
date	2016.12.10.08.47.58;	author nakashim;	state Exp;
branches;
next	1.50;

1.50
date	2016.11.27.13.29.49;	author nakashim;	state Exp;
branches;
next	1.49;

1.49
date	2016.11.26.12.18.47;	author nakashim;	state Exp;
branches;
next	1.48;

1.48
date	2016.11.21.23.12.49;	author nakashim;	state Exp;
branches;
next	1.47;

1.47
date	2016.11.15.12.58.10;	author nakashim;	state Exp;
branches;
next	1.46;

1.46
date	2016.11.06.08.37.10;	author nakashim;	state Exp;
branches;
next	1.45;

1.45
date	2016.10.23.09.11.41;	author nakashim;	state Exp;
branches;
next	1.44;

1.44
date	2016.09.23.03.30.03;	author nakashim;	state Exp;
branches;
next	1.43;

1.43
date	2016.09.03.07.37.31;	author nakashim;	state Exp;
branches;
next	1.42;

1.42
date	2016.08.16.03.07.27;	author nakashim;	state Exp;
branches;
next	1.41;

1.41
date	2016.08.04.15.33.25;	author nakashim;	state Exp;
branches;
next	1.40;

1.40
date	2016.06.08.13.37.10;	author nakashim;	state Exp;
branches;
next	1.39;

1.39
date	2016.06.07.06.25.06;	author nakashim;	state Exp;
branches;
next	1.38;

1.38
date	2016.06.05.04.22.35;	author nakashim;	state Exp;
branches;
next	1.37;

1.37
date	2016.06.02.06.35.06;	author nakashim;	state Exp;
branches;
next	1.36;

1.36
date	2016.06.01.12.56.25;	author nakashim;	state Exp;
branches;
next	1.35;

1.35
date	2016.05.29.23.47.09;	author nakashim;	state Exp;
branches;
next	1.34;

1.34
date	2016.05.25.04.48.38;	author nakashim;	state Exp;
branches;
next	1.33;

1.33
date	2016.04.27.15.20.12;	author nakashim;	state Exp;
branches;
next	1.32;

1.32
date	2016.04.20.22.59.06;	author nakashim;	state Exp;
branches;
next	1.31;

1.31
date	2016.04.18.13.07.32;	author nakashim;	state Exp;
branches;
next	1.30;

1.30
date	2016.04.14.14.26.31;	author nakashim;	state Exp;
branches;
next	1.29;

1.29
date	2016.04.14.01.05.23;	author nakashim;	state Exp;
branches;
next	1.28;

1.28
date	2016.04.10.13.55.08;	author nakashim;	state Exp;
branches;
next	1.27;

1.27
date	2016.04.10.10.31.44;	author nakashim;	state Exp;
branches;
next	1.26;

1.26
date	2016.04.10.10.23.15;	author nakashim;	state Exp;
branches;
next	1.25;

1.25
date	2016.04.10.10.15.13;	author nakashim;	state Exp;
branches;
next	1.24;

1.24
date	2016.03.26.14.39.53;	author nakashim;	state Exp;
branches;
next	1.23;

1.23
date	2016.03.12.11.34.53;	author nakashim;	state Exp;
branches;
next	1.22;

1.22
date	2016.02.28.13.09.29;	author nakashim;	state Exp;
branches;
next	1.21;

1.21
date	2016.02.28.11.43.46;	author nakashim;	state Exp;
branches;
next	1.20;

1.20
date	2016.01.30.07.43.12;	author nakashim;	state Exp;
branches;
next	1.19;

1.19
date	2016.01.29.15.14.28;	author nakashim;	state Exp;
branches;
next	1.18;

1.18
date	2016.01.28.04.47.52;	author nakashim;	state Exp;
branches;
next	1.17;

1.17
date	2016.01.27.03.48.26;	author nakashim;	state Exp;
branches;
next	1.16;

1.16
date	2016.01.27.00.58.56;	author nakashim;	state Exp;
branches;
next	1.15;

1.15
date	2016.01.26.16.40.31;	author nakashim;	state Exp;
branches;
next	1.14;

1.14
date	2016.01.22.16.10.54;	author nakashim;	state Exp;
branches;
next	1.13;

1.13
date	2016.01.19.03.03.51;	author nakashim;	state Exp;
branches;
next	1.12;

1.12
date	2016.01.16.08.47.47;	author nakashim;	state Exp;
branches;
next	1.11;

1.11
date	2016.01.15.04.06.53;	author nakashim;	state Exp;
branches;
next	1.10;

1.10
date	2015.11.29.02.53.28;	author nakashim;	state Exp;
branches;
next	1.9;

1.9
date	2015.11.27.08.40.24;	author nakashim;	state Exp;
branches;
next	1.8;

1.8
date	2015.11.11.16.09.33;	author nakashim;	state Exp;
branches;
next	1.7;

1.7
date	2015.11.08.03.00.24;	author nakashim;	state Exp;
branches;
next	1.6;

1.6
date	2015.10.25.23.41.59;	author nakashim;	state Exp;
branches;
next	1.5;

1.5
date	2015.10.20.03.05.11;	author nakashim;	state Exp;
branches;
next	1.4;

1.4
date	2015.10.19.23.42.30;	author nakashim;	state Exp;
branches;
next	1.3;

1.3
date	2015.08.16.03.34.55;	author nakashim;	state Exp;
branches;
next	1.2;

1.2
date	2015.08.09.12.58.39;	author nakashim;	state Exp;
branches;
next	1.1;

1.1
date	2015.08.09.12.19.25;	author nakashim;	state Exp;
branches;
next	;


desc
@@


1.190
log
@*** empty log message ***
@
text
@
/* EMAX6 library                        */
/*         Copyright (C) 2013- by NAIST */
/*          Primary writer: Y.Nakashima */
/*                 nakashim@@is.naist.jp */

/*******************************************************************************/
/******************************** Defs *****************************************/
/*******************************************************************************/

enum { NANOS_ARM, NANOS_DRAIN, NANOS_CONF, NANOS_REGV, NANOS_RANGE, NANOS_LOAD, NANOS_EXEC, NANOS_TOTAL, NANOS_CLASS };

typedef struct {
  Uint  f : 23;
  Uint  e :  8;
  Uint  s :  1;
} f32bit;

typedef struct {
  Uint  e :  6;
  Uint  b :  1;
  Uint  s :  1;
} u7bit;

typedef struct {
  Uint  e :  7;
  Uint  s :  1;
} u8bit;

typedef struct {
  Uchar u[8];
} u64bit;

#define abs(a)    ((a)>  0 ? (a) :-(a)    )
#define ad(a,b)   ((a)<(b)?(b)-(a):(a)-(b))
#define ss(a,b)   ((a)<(b)?   0   :(a)-(b))

/* dma_ctrl_space */
/* regmap of zynq ultrascale+ */
/* https://japan.xilinx.com/html_docs/registers/ug1087/ug1087-zynq-ultrascale-registers.html#_module_summary.html */
struct dma_ctrl {
  /*   Register Name		   Address	Width	Type	Reset Value	Description */
  Uint ZDMA_ERR_CTRL;    	/* 0x00000000	32	mixed	0x00000001	Enable/Disable a error response */
  Uint dmy0[63];
  Uint ZDMA_CH_ISR;      	/* 0x00000100	32	mixed	0x00000000	Interrupt Status Register for intrN. This is a sticky register that holds the value of the interrupt until cleared by a value of 1. */
  Uint ZDMA_CH_IMR;      	/* 0x00000104	32	mixed	0x00000FFF	Interrupt Mask Register for intrN. This is a read-only location and can be atomically altered by either the IDR or the IER. */
  Uint ZDMA_CH_IEN;      	/* 0x00000108	32	mixed	0x00000000	Interrupt Enable Register. A write of to this location will unmask the interrupt. (IMR: 0) */
  Uint ZDMA_CH_IDS;      	/* 0x0000010C	32	mixed	0x00000000	Interrupt Disable Register. A write of one to this location will mask the interrupt. (IMR: 1) */
  Uint ZDMA_CH_CTRL0;    	/* 0x00000110★	32	mixed	0x00000080	Channel Control Register 0 */
	/*   Field Name  Bits  Type Reset Value  Description            */
	/*   Reserved	 31:8  raz  0x0	         Reseved for future use */
	/*   OVR_FETCH	    7  rw   0x1	         0: DMA channel is not allowed to over-fetch on SRC */
	/*                                       1: DMA channel is allowed to over-fetch */
	/*                                       This field must remain stable while DMA Channel is enabled */
	/*   POINT_TYPE	    6  rw   0x0	       ★0: Simple mode DMA. Descriptor (DMA command) from APB register space. */
	/*                                       1: Scatter-gather mode DMA. Descriptor are stored in Memory. */
	/*                                       This field must remain stable while DMA Channel is enabled */
	/*   MODE	  5:4  rw   0x0	         00: Normal read & write DMA (default) */
	/*                                       01: Write only */
	/*                                       (uses data from WR_DMA_DATA*) */
	/*                                       10: Read only */
	/*                                       11: Reseved for future use */
	/*                                       This field must remain stable while DMA Channel is enabled */
	/*   RATE_CTRL	    3  rw   0x0	         Enable/Disable rate control */
	/*                                       0: rate control is disabled */
	/*                                       1: rate control is enabled, use rate control count to schedule AXI transaction (Read) */
	/*                                       This field must remain stable while DMA Channel is enabled */
	/*   CONT_ADDR	    2  rw   0x0	         Coming out of pause */
	/*                                       0: use continuous address(calculated from previous DSCR Addr) to fetch next descriptor */
	/*                                       1: use address specified in Start Address Register to fetch next descriptor on both SRC & DST side */
	/*   CONT	    1  wo   0x0	         Setting to 1 unpause (restarts from current position) the pauseed DMA */
	/*                                       SW sets this 1 to trigger. When DMA is unpaused , then hardware clears this bit. SW clear has no effect on it */
	/*   Reserved	    0  raz  0x0	         Reseved for future use */

  Uint ZDMA_CH_CTRL1;    	/* 0x00000114	32	mixed	0x000003FF	Channel Flow Control Register */
  Uint ZDMA_CH_FCI;      	/* 0x00000118	32	mixed 	0x00000000	Channel Control Register 1 */
  Uint ZDMA_CH_STATUS;   	/* 0x0000011C★	32	mixed	0x00000000	Channel Status Register */
	/*   Field Name  Bits  Type Reset Value  Description            */
	/*   Reserved    31:2  raz  0x0          Reseved for future use */
	/*   STATE        1:0  ro   0x0        ★00: Done with no error (as a result Enable bit is cleared by HW) */
	/*                                       01: paused with no error (as a result Enable bit remains set). */
	/*                                       10: DMA is busy transferring */
	/*                                     ★11: DMA done with error (error condition captured in otherregisters) */
	/*                                       This bit is cleared by HW when Enable or Unpause is set to 1. */

  Uint ZDMA_CH_DATA_ATTR;	/* 0x00000120	32	mixed	0x0483D20F	Channel DATA AXI parameter Register */
  Uint ZDMA_CH_DSCR_ATTR;	/* 0x00000124	32	mixed	0x00000000	Channel DSCR AXI parameter Register */
  Uint ZDMA_CH_SRC_DSCR_WORD0;	/* 0x00000128★	32	rw	0x00000000	SRC DSCR Word 0 */
  Uint ZDMA_CH_SRC_DSCR_WORD1;  /* 0x0000012C★	32	mixed	0x00000000	SRC DSCR Word 1 */
  Uint ZDMA_CH_SRC_DSCR_WORD2;  /* 0x00000130★	32	mixed	0x00000000	SRC DSCR Word 2 */
	/*   Field Name  Bits  Type Reset Value  Description            */
	/*   Reserved	 31:30 raz  0x0	         Reserved for furure use */
	/*   SIZE	 29:0  rw   0x0	         Buffer size in bytes (1G=2^30) */

  Uint ZDMA_CH_SRC_DSCR_WORD3;  /* 0x00000134	32	mixed	0x00000000	SRC DSCR Word 3 */
  Uint ZDMA_CH_DST_DSCR_WORD0;  /* 0x00000138★	32	rw	0x00000000	DST DSCR Word 0 */
  Uint ZDMA_CH_DST_DSCR_WORD1;  /* 0x0000013C★	32	mixed	0x00000000	DST DSCR Word 1 */
  Uint ZDMA_CH_DST_DSCR_WORD2;  /* 0x00000140★	32	mixed	0x00000000	DST DSCR Word 2 */
	/*   Field Name  Bits  Type Reset Value  Description            */
	/*   Reserved	 31:30 raz  0x0	         Reserved for furure use */
	/*   SIZE	 29:0  rw   0x0	         Buffer size in bytes (1G=2^30) */

  Uint ZDMA_CH_DST_DSCR_WORD3;  /* 0x00000144	32	mixed	0x00000000	DST DSCR Word 3 */
  Uint ZDMA_CH_WR_ONLY_WORD0;   /* 0x00000148	32	rw	0x00000000	Write Only Data Word 0 */
  Uint ZDMA_CH_WR_ONLY_WORD1;   /* 0x0000014C	32	rw	0x00000000	Write Only Data Word 1 */
  Uint ZDMA_CH_WR_ONLY_WORD2;   /* 0x00000150	32	rw	0x00000000	Write Only Data Word 2 */
  Uint ZDMA_CH_WR_ONLY_WORD3;   /* 0x00000154	32	rw	0x00000000	Write Only Data Word 3 */
  Uint ZDMA_CH_SRC_START_LSB;   /* 0x00000158	32	rw	0x00000000	SRC DSCR Start Address LSB Regiser */
  Uint ZDMA_CH_SRC_START_MSB;   /* 0x0000015C	32	mixed	0x00000000	SRC DSCR Start Address MSB Regiser */
  Uint ZDMA_CH_DST_START_LSB;   /* 0x00000160	32	rw	0x00000000	DST DSCR Start Address LSB Regiser */
  Uint ZDMA_CH_DST_START_MSB;   /* 0x00000164	32	mixed	0x00000000	DST DSCR Start Address MSB Regiser */
  Uint dmy1[9];
  Uint ZDMA_CH_RATE_CTRL;       /* 0x0000018C	32	mixed	0x00000000	Rate Control Count Register */
  Uint ZDMA_CH_IRQ_SRC_ACCT;    /* 0x00000190	32	mixed	0x00000000	SRC Interrupt Account Count Register */
  Uint ZDMA_CH_IRQ_DST_ACCT;    /* 0x00000194	32	mixed	0x00000000	DST Interrupt Account Count Register */
  Uint dmy2[26];
  Uint ZDMA_CH_CTRL2;  		/* 0x00000200★	32	mixed	0x00000000	zDMA Control Register 2 */
	/*   Field Name  Bits  Type Reset Value  Description            */
	/*   Reserved	 31:1  raz  0x0	         Reseved for future use */
	/*   EN	            0  rw   0x0	         Channel is enabled */
	/*                                       SW sets this 1 to trigger. If DMA channel is in pause and this bit is cleared by software */
	/*                                       then DMA channel goes to disable state when SW set CONT bit. */
	/*                                       HW clears this flag after finishing DMA opertion. */

  /* Simple Mode */
  /* 1. ZDMA_CH_STATUS レジスタを読み出し、STATEが00または11(DMAがIDLEステート) になるまで待つ. */
  /*    DMAがPAUSEステートの場合、「チャネル一時停止」で説明する手順に従って PAUSE ステートを終了. */
  /* 2. ZDMA_CH_CTRL0レジスタの POINT_TYPE (ビット 6) を 0 に設定 */
  /*    データソースバッファのアドレスの LSB を ZDMA_CH_SRC_DSCR_WORD0レジスタに書き込む */
  /*    データソースバッファのアドレスの MSB を ZDMA_CH_SRC_DSCR_WORD1レジスタに書き込む */
  /* 3. データデスティネーションバッファのアドレスの LSB を ZDMA_CH_DST_DSCR_WORD0レジスタに書き込む */
  /*    データデスティネーションバッファのアドレスの MSB を ZDMA_CH_DST_DSCR_WORD1レジスタに書き込む */
  /* 4. Simple Modeでは、SRCトランザクションサイズとDSTトランザクションサイズの両方を設定する必要がある */
  /*    DMA は SRCトランザクションサイズを使用しますが、両方のレジスタを設定しておく必要がある */
  /*    ZDMA_CH_SRC_DSCR_WORD2 レジスタにソースデータサイズを書き込む */
  /*    ZDMA_CH_DST_DSCR_WORD2 レジスタにデスティネーショントランザクションサイズを書き込む */
  /*    SRCトランザクションサイズとDSTトランザクションサイズは必ず同じ */
  /* 5. 必要に応じ,ZDMA_CH_DST_DSCR_WORD3およびZDMA_CH_SRC_DSCR_WORD3レジスタでINTRを1にセットし割り込みを有効にする */
  /* 6. ソースおよびデスティネーションバッファがキャッシュコヒーレントとして割り当てられているかフラッシュされている場合, */
  /*    COHRNTをセットする必要はない. それ以外の場合,ソースおよびデスティネーションバッファがキャッシュコヒーレントとして */
  /*    割り当てられていない、またはフラッシュされていない場合、ZDMA_CH_SRC_DSCR_WORD3およびZDMA_CH_DST_DSCR_WORD3レジスタで */
  /*    それぞれ COHRNTをセットする. COHRNTビットは LPD-DMA の場合のみ有効. FPD-DMAはコヒーレンシをサポートしない. */
  /* 7. ZDMA_CH_CTRL2レジスタのENビットをセットして,DMA転送に使用するDMAチャネルを有効にする. */
  /*    DMAを有効にした後、「エラー条件」に示すエラー条件をチェックする. */
};

/* reg_ctrl */
enum { EXRING_IDLE, EXRING_BUSY};
enum { LMRING_IDLE, LMRING_BUSY};
enum { CMD_NOP, CMD_RESET, CMD_SCON, CMD_EXEC};
struct reg_ctrl {
  struct i0 {
    Ull  stat; /* +0000 bit15-12:LMM_SIZE, bit11-8:EMAX_DEPTH, bit7-4:LMRING, bit3-0:EXRING */
    Uint mcid; /* +0008 maximum chip-ID of IMAX (<EMAX_NCHIP) to be chained (activated) */
    Uint dmy0;
    Uint cmd;  /* +0010 host writes Ull cmd then chip# is propagated to succesors */
  /*Uint cid;*//* +0012 chip# ( set by write to cmd ) */
    Uint dmy1;
    Ull  dmy2;
    Ull  adtr; /* +0020 */
    Ull  dmy3;
    Ull  csel; /* +0030 */
    Ull  dmrp; /* +0038 DMAREAD-PREF */
    Ull  dmy4[1016];
    struct conf                    conf[AMAP_DEPTH][EMAX_WIDTH];  /* +2000-3fff */
    struct {Ull  br[UNIT_WIDTH];}  breg[AMAP_DEPTH][EMAX_WIDTH];  /* +4000-5fff *//* unit[cid][EMAX_DEPTH].breg[x][EMAX_WIDTH].br[UNIT_WIDTH] is used */
    struct {Uint ea0b ; /* ea0 base   (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
      /*Ull  dmy0 :14;*/
        Uint ea0o ; /* ea0 offset (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
      /*Ull  dmy1 :14;*/
        Uint ea1b ; /* ea1 base   (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
      /*Ull  dmy2 :14;*/
        Uint ea1o ; /* ea1 offset (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
      /*Ull  dmy3 :14;*/
        Uint top  ; /* LMM-top virtual-address */
      /*Ull  dmy4 : 1;*/
        Uint bot  ; /* LMM-bot virtual-address */
      /*Ull  dmy5 : 1;*/
        Ull  dmy6 ;}           addr[AMAP_DEPTH][EMAX_WIDTH];  /* +6000-7fff */
    struct {Ull  reg[UNIT_WIDTH];} lddmrw[AMAP_DEPTH][EMAX_WIDTH];/* +8000-9fff *//* lddmq/trans-r,lddmq-w */
    Ull dmy5[3072]; /* +a000-ffff */
  } i[EMAX_NCHIP]; /* 0000-ffff */
};

/* emax6 host control */
enum { STATUS_IDLE, STATUS_CONF, STATUS_SCON, STATUS_REGV, STATUS_RANGE, STATUS_DRAIN, STATUS_LOAD, STATUS_START, STATUS_EXEC, STATUS_TERM };

struct emax6 { /* host status of EMAX6 */
  volatile Ull   dma_ctrl;  /* struct dma_ctrl *dma_ctrl  DMA control */
  volatile Ull   reg_ctrl;  /* struct reg_ctrl *reg_ctrl  REG control */

  Ull   status            : 4;
  Ull   csel_save         : 2;
  Ull   last_conf            ; /* for insn_reuse */
  Ull   lmmic             : 1; /* 0:lmm[0] is curent, 1:lmm[1] is current */
  Ull   lmmio             : 1; /* 0:lmm[0] is prev,   1:lmm[1] is prev    */
  Ull   mapdist           : 6; /* specified mapdist */
  Ull   lastdist          : 6; /* lastdist for DYNAMIC_SCON */
  struct lmmi lmmi[EMAX_NCHIP][AMAP_DEPTH][EMAX_WIDTH][2]; /* lmmi for host (len/ofs/top are resolved) */
  Ull   lmmi_bitmap[EMAX_WIDTH];      /* based on lmmi[*][EMAX_WIDTH][2].v */
  Uchar lmmd[AMAP_DEPTH][EMAX_WIDTH]; /* chip#7,6,..,0:clean, 1:dirty, exec後store箇所に1, drain直後0 */

#ifndef IGNORE_LMMI_BLKGATHER
  Ull   plist                ; /* pointer-list */
  Ull   blkcount          : 7; /* active block number */
  Ull   blksize           : 9; /* 1:64 2:128 3:256 dwords */
  Ull   lmmblktop            ; /* LMM-addr     for LDRQ(blk>0) */
  Ull   lmmblklen            ; /* total dwords for LDRQ(blk>0) */
#endif

  Ull   rw                    ; /* 0:load(mem->lmm), 1:store(lmm->mem)      */
  Ull   ddraddr               ; /* ddr-address                              */
  Ull   lmmaddr               ; /* lmm-address                              */
  Ull   dmalen                ; /* dma-length                               */

#ifndef IGNORE_LDDMQ_HANDSHAKE
  Ull   fsm_busy          : 1; /* for LDDMQ and TR */
  Ull   lmwd_valid        : 1; /* for LDDMQ */
  Ull   tcureg_valid      : 1; /* fsm->ARM   0 -> 1 -> 1 -> 0 -> 0 -> 0                              */
  Ull   tcureg_ready      : 1; /* fsm<-ARM   0 -> 0 -> 1 -> 0 -> 0 -> 0                              */
  Ull   tcureg_last       : 1; /* fsm->ARM   0 -> 0 -> 0 -> 1 -> 1 -> 0                              */
  Ull   tcureg_term       : 1; /* fsm<-ARM   0 -> 0 -> 0 -> 0 -> 1 -> 0                              */
  Ull   tcureg[UNIT_WIDTH]   ; /* tcu-data        of tcu                       v                     */
                               /* from ARM:  svc 0x1010 ... tcureg_valid->x0                         */
                               /* from ARM:  svc 0x1011 ... 1->tcureg_ready                          */
                               /* from ARM:  svc 0x1012 ... tcureg_last->x0                          */
                               /* from ARM:  svc 0x1013 ... 1->tcureg_term                           */
                               /* from ARM:  svc 0x1014 ... tcureg[3:0]->x3,2,1,0                    */
#endif
} emax6;

volatile struct emax_info {
  Ull  dma_phys;     // kern-phys
  Ull  dma_vadr;     // not used
  Ull  dma_mmap;     // user-virt Contiguous 64K register space
  Ull  reg_phys;     // kern-phys
  Ull  reg_vadr;     // not used
  Ull  reg_mmap;     // user-virt Contiguous 4GB space including LMM space
  Ull  lmm_phys;     // kern-phys
  Ull  lmm_vadr;     // not used
  Ull  lmm_mmap;     // user-virt Contiguous 2GB space for LMM space
  Ull  ddr_phys;     // kern-phys
  Ull  ddr_vadr;     // not used
  Ull  ddr_mmap;     // user-virt Contiguous 2GB space in DDR-high-2GB space
  int  driver_use_1;
  int  driver_use_2;
} emax_info;

/*  ... for ARMSIML only */
#define DMA_BASE2_PHYS	 0x50000000
#define REG_BASE2_PHYS	 0x50100000
#define REG_CONF_OFFS    0x00002000
#define REG_BREG_OFFS    0x00004000
#define REG_ADDR_OFFS    0x00006000
#define REG_LDDM_OFFS    0x00008000
#define REG_AREA_MASK    0x0000ffff
#define LMM_BASE2_PHYS 	 0x60000000
#define MEM_VALID_ADDR	 0xafffffff

#ifndef NO_EMAX6LIB_BODY

#ifdef ARMZYNQ
/*******************************************************************************/
/******************************** ZYNQ-COMMON **********************************/
/*******************************************************************************/

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <dirent.h>
#include <errno.h>
#include <linux/ioctl.h>

#define DMA_BASE_PHYS	 0x00000000fd500000LL
/*  ... fixed */
#define DMA_MMAP_SIZE	 0x0000000000010000LL
/*  ... 64KB  */
#define REG_BASE_PHYS	 0x0000000400000000LL
/*  ... fixed */
#define REG_MMAP_SIZE	 0x0000000100000000LL
/*  ... 4GB(including REGS) */
#define LMM_BASE_PHYS	 0x0000000480000000LL
/*  ... fixed */
#define DDR_BASE_PHYS	 0x0000000800000000LL
/*  ... fixed */
#define DDR_MMAP_SIZE	 0x0000000080000000LL
/*  ... 2GB   */

#define EMAX_IOC_MAGIC  60
/* Please use a different 8-bit number in your code */
#define EMAX_IORESET			_IO( EMAX_IOC_MAGIC, 0)
#define EMAX_GET_ACPMEM			_IOWR(EMAX_IOC_MAGIC,  1, unsigned long)
#define EMAX_IOC_MAXNR 2

static int filter(struct dirent *dir)
{
  return dir->d_name[0] == '.' ? 0 : 1;
}

static void trim(char *d_name)
{
  char *p = strchr(d_name, '\n');
  if (p != NULL) *p = '\0';
}

static int is_target_dev(char *d_name, char *target)
{
  char path[32];
  char name[32];
  FILE *fp;
  sprintf(path, "/sys/class/uio/%s/name", d_name);
  if ((fp = fopen(path, "r")) == NULL) return 0;
  if (fgets(name, sizeof(name), fp) == NULL) {
    fclose(fp);
    return 0;
  }
  fclose(fp);
  if (strcmp(name, target) != 0) return 0;
  return 1;
}

static int get_reg_size(char *d_name)
{
  char path[32];
  char size[32];
  FILE *fp;
  sprintf(path, "/sys/class/uio/%s/maps/map0/size", d_name);
  if ((fp = fopen(path, "r")) == NULL) return 0;
  if (fgets(size, sizeof(size), fp) == NULL) {
    fclose(fp);
    return 0;
  }
  fclose(fp);
  return strtoull(size, NULL, 16);
}

emax6_open()
/* HPMを経由する制御レジスタにリセット送出 */
/* HPPを経由する画像メモリを仮想空間に写像 */
/* ACPを経由するconf/lmmi/regv空間を仮想空間に写像 */
{
  struct dirent **namelist;
  int num_dirs, dir;
  int reg_size;
  int  fd_dma_found = 0;
  char path[1024];
  int  fd_dma;
  int  fd_reg;
  int  fd_ddr;
  char *UIO_DMA           = "dma\n";
  char *UIO_AXI_CHIP2CHIP = "axi_chip2chip\n";
  char *UIO_AXI_EMAX6     = "emax6\n";
  char *UIO_DDR_HIGH      = "ddr_high\n";

  if ((num_dirs = scandir("/sys/class/uio", &namelist, filter, alphasort)) == -1)
    return (NULL);

  for (dir = 0; dir < num_dirs; ++dir) {
    trim(namelist[dir]->d_name);
    if (!fd_dma_found && is_target_dev(namelist[dir]->d_name, UIO_DMA) && (reg_size = get_reg_size(namelist[dir]->d_name))) {
      if (strlen(namelist[dir]->d_name)>4) /* ignore /dev/uio1X */
	continue;
      sprintf(path, "/dev/%s", namelist[dir]->d_name);
      free(namelist[dir]);
      if ((fd_dma = open(path, O_RDWR | O_SYNC)) == -1)
	continue;
      printf("%s: %s", path, UIO_DMA);
      emax_info.dma_phys = DMA_BASE_PHYS;
      emax_info.dma_mmap = (Ull)mmap(NULL, reg_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd_dma, 0);
      close(fd_dma);
      if (emax_info.dma_mmap == MAP_FAILED)
	continue;
      fd_dma_found++;
    }
    else if (is_target_dev(namelist[dir]->d_name, UIO_AXI_CHIP2CHIP)) {
      sprintf(path, "/dev/%s", namelist[dir]->d_name);
      free(namelist[dir]);
      if ((fd_reg = open(path, O_RDWR | O_SYNC)) == -1) {
	printf("open failed. %s", UIO_AXI_CHIP2CHIP);
	return (NULL);
      }
      printf("%s: %s", path, UIO_AXI_CHIP2CHIP);
      // mmap(cache-off) 4KB aligned
      emax_info.reg_phys = REG_BASE_PHYS;
      emax_info.reg_mmap = (Ull)mmap(NULL, REG_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd_reg, 0); /* 4GB */
      if (emax_info.reg_mmap == MAP_FAILED) {
	printf("fd_reg mmap() failed. errno=%d\n", errno);
	return (NULL);
      }
      emax_info.lmm_phys = LMM_BASE_PHYS;
      emax_info.lmm_mmap = emax_info.reg_mmap + (LMM_BASE_PHYS - REG_BASE_PHYS);
    }
    else if (is_target_dev(namelist[dir]->d_name, UIO_AXI_EMAX6)) {
      sprintf(path, "/dev/%s", namelist[dir]->d_name);
      free(namelist[dir]);
      if ((fd_reg = open(path, O_RDWR | O_SYNC)) == -1) {
	printf("open failed. %s", UIO_AXI_EMAX6);
	return (NULL);
      }
      printf("%s: %s", path, UIO_AXI_EMAX6);
      // mmap(cache-off) 4KB aligned
      emax_info.reg_phys = REG_BASE_PHYS;
      emax_info.reg_mmap = (Ull)mmap(NULL, REG_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd_reg, 0); /* 4GB */
      if (emax_info.reg_mmap == MAP_FAILED) {
	printf("fd_reg mmap() failed. errno=%d\n", errno);
	return (NULL);
      }
      emax_info.lmm_phys = LMM_BASE_PHYS;
      emax_info.lmm_mmap = emax_info.reg_mmap + (LMM_BASE_PHYS - REG_BASE_PHYS);
    }
    else if (is_target_dev(namelist[dir]->d_name, UIO_DDR_HIGH)) {
      sprintf(path, "/dev/%s", namelist[dir]->d_name);
      free(namelist[dir]);
      if ((fd_ddr = open(path, O_RDWR | O_SYNC)) == -1) {
	printf("open failed. %s",UIO_DDR_HIGH);
	return (NULL);
      }
      printf("%s: %s", path, UIO_DDR_HIGH);
      // mmap(cache-on)  4KB aligned
      emax_info.ddr_phys = DDR_BASE_PHYS;
      emax_info.ddr_mmap = (Ull)mmap(NULL, DDR_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd_ddr, 0); /* 2GB */
      if (emax_info.ddr_mmap == MAP_FAILED) {
	printf("fd_ddr mmap() failed. errno=%d\n", errno);
	return (NULL);
      }
    }
    else {
      free(namelist[dir]);
      continue;
    }
  }
  free(namelist);

  if (fd_dma_found) {
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_ERR_CTRL          = 0x00000001;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_ISR            = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_IMR            = 0x00000FFF;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_IEN            = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_IDS            = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_CTRL0          = 0x00000080;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_CTRL1          = 0x000003FF;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_FCI            = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_STATUS         = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_DATA_ATTR      = 0x04C3D30F; /* Note - AxCACHE: 0011 value recomended by Xilinx. */
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_DSCR_ATTR      = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_SRC_DSCR_WORD0 = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_SRC_DSCR_WORD1 = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_SRC_DSCR_WORD2 = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_SRC_DSCR_WORD3 = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_DST_DSCR_WORD0 = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_DST_DSCR_WORD1 = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_DST_DSCR_WORD2 = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_DST_DSCR_WORD3 = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_WR_ONLY_WORD0  = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_WR_ONLY_WORD1  = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_WR_ONLY_WORD2  = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_WR_ONLY_WORD3  = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_SRC_START_LSB  = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_SRC_START_MSB  = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_DST_START_LSB  = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_DST_START_MSB  = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_RATE_CTRL      = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_IRQ_SRC_ACCT   = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_IRQ_DST_ACCT   = 0x00000000;
    ((struct dma_ctrl*)emax_info.dma_mmap)->ZDMA_CH_CTRL2          = 0x00000000;
  }
  return (1);
}
#endif

/*******************************************************************************/
/******************************** Timer ****************************************/
/*******************************************************************************/

Ull nanosec_sav;
Ull nanosec[NANOS_CLASS];

reset_nanosec()
{
  int i;
  for (i=0; i<NANOS_CLASS; i++)
    nanosec[i] = 0;
#if defined(ARMSIML)
  nanosec_sav = _getclk(0);
#else
  struct timespec ts;
  clock_gettime(0, &ts); /*CLOCK_REALTIME*/
  nanosec_sav = 1000000000*ts.tv_sec + ts.tv_nsec;
#endif
}

get_nanosec(int class)
{
  Ull nanosec_now;
#if defined(ARMSIML)
  nanosec_now = _getclk(0);
  nanosec[class] += nanosec_now - nanosec_sav;
  nanosec[NANOS_TOTAL] += nanosec_now - nanosec_sav;
  nanosec_sav = nanosec_now;
#else
  struct timespec ts;
  clock_gettime(0, &ts); /*CLOCK_REALTIME*/
  nanosec_now = 1000000000*ts.tv_sec + ts.tv_nsec;
  nanosec[class] += nanosec_now - nanosec_sav;
  nanosec[NANOS_TOTAL] += nanosec_now - nanosec_sav;
  nanosec_sav = nanosec_now;
#endif
}

show_nanosec()
{
#if defined(ARMSIML)
  printf("SIML_cycle/1000: ARM:%d DRAIN:%d CONF:%d REGV:%d RANGE:%d LOAD:%d EXEC:%d total:%d\n",
	 (Uint)(nanosec[NANOS_ARM]/1000),
	 (Uint)(nanosec[NANOS_DRAIN]/1000),
	 (Uint)(nanosec[NANOS_CONF]/1000),
	 (Uint)(nanosec[NANOS_REGV]/1000),
	 (Uint)(nanosec[NANOS_RANGE]/1000),
	 (Uint)(nanosec[NANOS_LOAD]/1000),
	 (Uint)(nanosec[NANOS_EXEC]/1000),
	 (Uint)(nanosec[NANOS_TOTAL]/1000));
#else
  printf("usec: ARM:%d DRAIN:%d CONF:%d REGV:%d RANGE:%d LOAD:%d EXEC:%d total:%d\n",
	 (Uint)(nanosec[NANOS_ARM]/1000),
	 (Uint)(nanosec[NANOS_DRAIN]/1000),
	 (Uint)(nanosec[NANOS_CONF]/1000),
	 (Uint)(nanosec[NANOS_REGV]/1000),
	 (Uint)(nanosec[NANOS_RANGE]/1000),
	 (Uint)(nanosec[NANOS_LOAD]/1000),
	 (Uint)(nanosec[NANOS_EXEC]/1000),
	 (Uint)(nanosec[NANOS_TOTAL]/1000));
#endif
}

/*******************************************************************************/
/******************************** DMA-START ************************************/
/*******************************************************************************/

#if !defined(EMAXNC)
emax6_check_lmmi_and_dma(int mode, int phase, int lastdist, int c, int i, int j)
{
  /* mode   0:array, 1:drain */
  /* phase  0:nop,   1:drain, 2:load, 3exec */
  /* lastdist */
  /* i      row              */
  /* j      col              */
  /* lmmi更新後に呼ばれる. lmd関連はlmd位置を基準にlmr/lmxを検査(+lastdistの理由) */
  /*                   次回lmd    位置は,"lmmi[i         ][lmmic]" */
  /* lastdist=>0の場合,前回lmw/lmx位置は,"lmmi[i+lastdist][lmmio]" */
  /* 従来,lmdの場合,SCONしてもしなくてもEXECと同時にDRAIN (lastdist=0の場合はlmmの半分をlmd/lmwに使い分ける前提) */
  /* lastdist=0の場合,DYNAMIC_SCONは無意味なので従来通り */
  /* lastdist>0の場合,DYNAMIC_SCONかつSCON有りは従来通り */
  /*                 SCON無視の場合,そもそもlmd位置が合わないのでlmd指定は無視すべき.旧lmw/lmxのEXEC前DRAINが必要 */
  /*                 ★★★ただし,lmdを使うケースではDYNAMIC_SCONを使わないはずなので,当面対応しない */
  int k, m = (i+lastdist)%EMAX_DEPTH; /* lmmo-index */
  int lmmc_topz;
  int lmmc_ofsz;
  int lmmo_stat;
  int lmmc_stat;
  int lmm_ready;
  int lmm_readz;
  int mark;

  struct lmmi *lmmiop  = &emax6.lmmi[c][m][j][emax6.lmmio];
  struct lmmi *lmmicp  = &emax6.lmmi[c][i][j][emax6.lmmic];
  struct lmmi *lmmiop1 = &emax6.lmmi[c][(m+1)%EMAX_DEPTH][j][emax6.lmmio];
  struct lmmi *lmmicp1 = &emax6.lmmi[c][(i+1)%EMAX_DEPTH][j][emax6.lmmic];

  Ull dmadr;
  int dmlen;
  Ull dmnxt;
  int dmrw; /* 0:mem->lmm 1:lmm->mem */
  static Ull concat_adr[EMAX_NCHIP]; /* NULL:invalid, !NULL:top_addr */
  static int concat_len[EMAX_NCHIP]; /* byte-len */

  /* check_lmmi */
  if ((phase == 1 && mode == 0) || phase == 2 || phase == 3) { /* (drain && array) || load || exec */
    lmmc_topz = (lmmicp->top == 0);
    lmmc_ofsz = (lmmicp->ofs == 0);
    lmmo_stat = (lmmiop->v<<3)|(lmmiop->rw<<2)|(lmmiop->f<<1)|(lmmiop->p); /* v|rw|f|p */
    lmmc_stat =((lmmicp->v & ~lmmicp->hcopy & ~lmmicp->vcopy & ((lmmicp->f&lmmicp->p) | !lmmc_topz))<<3)|(lmmicp->rw<<2)|(lmmicp->f<<1)|(lmmicp->p); /* v= ~copy & (OP_LDDMQ/OP_TR または ptop!=NULL) */
    lmm_ready = (lmmiop->v && lmmiop->blk == lmmicp->blk && lmmiop->len == lmmicp->len && lmmiop->top == lmmicp->top);
    lmm_readz = (lmmiop->v && lmmiop->blk == lmmicp->blk && lmmiop->len == lmmicp->len &&(lmmiop->top+(Sll)(int)lmmiop->ofs) == lmmicp->top);
  }

  /* lmx: bitmapを検査し,現addr+lenと次addrを比べ,連続なら連結した次addr/lenを保存.最終または不連続なら保存addr/lenまたは現addr/lenを使ってDMA */

  if      (phase == 1) { /* drain */
    if      (mode==0 && lmmo_stat==12 && lmmc_stat!=13 && (emax6.lmmd[m][j]&1<<c)) { mark=1;emax6.lmmd[m][j]&=~(1<<c);dmadr=lmmiop->top;dmlen=lmmiop->len;dmnxt=lmmiop1->top;dmrw=1;}/* ●2 lmw&!lmd drain */
    else if (mode==0 && lmmo_stat==14 && !lmm_ready    && (emax6.lmmd[m][j]&1<<c)) { mark=1;emax6.lmmd[m][j]&=~(1<<c);dmadr=lmmiop->top;dmlen=lmmiop->len;dmnxt=lmmiop1->top;dmrw=1;}/* ●4 lmx      drain */
    else if (mode==1 &&                                   (emax6.lmmd[i][j]&1<<c)) { mark=1;emax6.lmmd[i][j]&=~(1<<c);dmadr=lmmicp->top;dmlen=lmmicp->len;dmnxt=lmmicp1->top;dmrw=1;}/* ☆ drain_dirty_lmm */
    else                                                                           { mark=0;                                                                                        }
  }
  else if (phase == 2) { /* load */
    if     ((lmmc_stat== 8               && !lmm_ready)                                                                                                                              /* ●1 lmr & !ready */
         || (lmmc_stat== 9               && !lmm_readz)                                                                                                                              /* ●7 lmp & !readz */
         || (lmmc_stat==10                            )                                                                                                                              /* ●3 lmf always load */
         || (lmmc_stat==14               && !lmm_ready))                           { mark=1;                          dmadr=lmmicp->top;dmlen=lmmicp->len;dmnxt=lmmicp1->top;dmrw=0;}/* ●3 lmx always load */
    else                                                                           { mark=0;                                                                                        }/* skip load */
  }
  else if (phase == 3) { /* exec */
    if      (lmmc_stat== 9 && (lastdist||!lmmc_ofsz)) { mark=1;                                                             dmadr=lmmicp->top;dmlen=lmmicp->len;dmrw=0;             }/* ●5 lmp */
    else if (lmmc_stat==12 || lmmc_stat==14         ) { mark=0;emax6.lmmd[i][j]|=(1<<c);                                                                                            }/* ●6 lmw/lmx */
    else if (lmmc_stat==13                          ) { mark=  emax6.lmmd[m][j]& (1<<c); emax6.lmmd[m][j]|=((!lastdist)<<c);dmadr=lmmicp->top;dmlen=lmmicp->len;dmrw=1;             }/* ●6 lmd & dirty */
#ifndef IGNORE_LDDMQ_HANDSHAKE
//  else if (lmmc_stat==11                          ) { mark=1;                             } /*     LDDMQ */
//  else if (lmmc_stat==15                          ) { mark=1;                             } /*     TR */
#endif
    else                                              { mark=0;                             } /* skip pdrain/pload */
  }

  if (mark) {
#if 1
    if (phase == 1) { /* drain */
      /* concat_adr=0        adr0,L=0        | adr1,L=0        | adr2,L=0        */
      /* concat_adr=adr0,L=0 adr0,L=0,mark=0 | adr1,L=0        | adr2,L=0        */
      /* concat_adr=adr0,L=1          mark=0 | adr1,L=0,mark=0 | adr2,L=0        */
      /* concat_adr=adr0,L=2          mark=0 |          mark=0 | adr2,L=0,mark=1 */
//printf("drain: adr=%08.8x len=%08.8x nxt=%08.8x\n", (Uint)dmadr, (Uint)dmlen, (Uint)dmnxt);
      if ((emax6.lmmd[(m+1)%EMAX_DEPTH][j]&(1<<c)) && (dmadr+(dmlen+1)*sizeof(Uint)) == dmnxt) {
	if (!concat_adr[c]) { concat_adr[c] = dmadr; concat_len[c] = dmlen; }
	else             { concat_len[c] += dmlen+1; }
	if (concat_len[c] < 8192) mark = 0;
      }
      else {
	if (concat_adr[c])  { concat_len[c] += dmlen+1; }
      }
    }
    else if (phase == 2) { /* load */
//printf("load: adr=%08.8x len=%08.8x nxt=%08.8x\n", (Uint)dmadr, (Uint)dmlen, (Uint)dmnxt);
      if (lmmicp1->v && (dmadr+(dmlen+1)*sizeof(Uint)) == dmnxt) {
	if (!concat_adr[c]) { concat_adr[c] = dmadr; concat_len[c] = dmlen; }
	else             { concat_len[c] += dmlen+1; }
	if (concat_len[c] < 8192) mark = 0;
      }
      else {
	if (concat_adr[c])  { concat_len[c] += dmlen+1; }
      }
    }
#endif
  }

  /* dma */
  if (mark) {
    emax6.rw = dmrw;
    if (phase == 1) { /* drain */
      emax6.ddraddr = (concat_adr[c])?concat_adr[c]:dmadr; /* address should be 4B-aligned */
      emax6.lmmaddr = emax6.ddraddr;
      emax6.dmalen  = (concat_adr[c])?concat_len[c]:dmlen; /* length should be # of words */
    }
    else if (phase == 3 && dmrw==1) { /* pdrain */
      emax6.ddraddr = dmadr+(Sll)(int)lmmicp->ofs; /* ★★★PDRAIN address should be 4B-aligned */
      emax6.lmmaddr = emax6.ddraddr;
      emax6.dmalen  = dmlen; /* length should be # of words */
    }
    else if (phase == 2                /* load */
	  ||(phase == 3 && dmrw==0)) { /* pload *//* address should be 4B-aligned *//* length should be # of words */
      if (lmmicp->blk==0) { /* inf */
	if (phase == 2) { /* load */
	  emax6.ddraddr = (concat_adr[c])?concat_adr[c]:dmadr; /* address should be 4B-aligned */
	  emax6.lmmaddr = emax6.ddraddr;
	  emax6.dmalen  = (concat_adr[c])?concat_len[c]:dmlen; /* length should be # of words */
	}
	else {
	  emax6.ddraddr = dmadr+(Sll)(int)lmmicp->ofs; /* ★★★PLOAD address should be 4B-aligned */
	  emax6.lmmaddr = emax6.ddraddr;
	  emax6.dmalen  = dmlen; /* length should be # of words */
	}
#ifndef IGNORE_LMMI_BLKGATHER
	emax6.blksize    = 0; /* max:10bit */
#endif
      }
#ifndef IGNORE_LMMI_BLKGATHER
      else { /* 16,32,64 */
	if (phase == 2) /* load */
	  emax6.plist = dmadr+emax6.blkcount*8; /* address should be 4B-aligned */
	else
	  emax6.plist = dmadr+emax6.blkcount*8+(Sll)(int)lmmicp->ofs; /* ★★★PLOAD address should be 4B-aligned */
	emax6.blksize  = 32<<lmmicp->blk; /* max:10bit */
	if (emax6.blkcount==0) {
	  emax6.lmmblktop = 0; /* ★★★未実装★★★ 先頭アドレスが0なので,addr_rangeに工夫が必要 */
	  emax6.lmmblklen = dmlen; /* length should be # of words */
	}
	emax6.ddraddr    = emax6.plist; /* address should be 4B-aligned */
	emax6.lmmaddr    = emax6.lmmblktop;
	emax6.dmalen     = (emax6.lmmblklen<emax6.blksize)?emax6.lmmblklen:emax6.blksize-1;
	emax6.lmmblktop += emax6.blksize*sizeof(Ull);
	emax6.lmmblklen = (emax6.lmmblklen<emax6.blksize)?0:(emax6.lmmblklen-emax6.blksize);
	if (emax6.lmmblklen==0)
	  emax6.blkcount = 0;
	else
	  emax6.blkcount++; /* ★★★未実装★★★ continue 複数回のDMA起動が必要 */
      }
#endif
    }
#if 0
printf("====DMA mode=%x phase=%x i=%x m=%x j=%x lmmic/o=%x/%x lmmc_stat=%x(dirty=%x) lmmo_stat=%x(dirty=%x) mark=%x\n", mode, phase, i, m, j, emax6.lmmic, emax6.lmmio, lmmc_stat, emax6.lmmd[i][j], lmmo_stat, emax6.lmmd[m][j], mark);
printf("        rw=0x%x ddraddr=%08.8x lmmaddr=%08.8x dmalen=0x%x ", emax6.rw, (Uint)emax6.ddraddr, (Uint)emax6.lmmaddr, (Uint)emax6.dmalen);
#endif
    concat_adr[c] = 0;
    emax6_kick_dma(j);
  }
}

emax6_kick_dma(int j) /* col */
{
  int status;
  Ull dst, src;
  Uint pio_words, pio_loop, pio_i, pio_b4, pio_b8, pio_b16, pio_e4, pio_e8, pio_e16;

  if (!emax6.ddraddr)
    return (0);

  if (j != emax6.csel_save) {
    ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].csel = j; /* DMA/LDDMQ/TRANS用に対象colセット */
    emax6.csel_save = j;
  }
#if defined(FPDDMA)
#define FPDDMA_DEFINED 1
#else
#define FPDDMA_DEFINED 0
#endif
  if (FPDDMA_DEFINED && emax6.dmalen > 1) { /* 4B/8B: ->PIO */
    /* kick dma_ctrl (Simple Mode) */
    /* 1. ZDMA_CH_STATUS レジスタを読み出し、STATEが00または11(DMAがIDLEステート) になるまで待つ. */
    /*    DMAがPAUSEステートの場合、「チャネル一時停止」で説明する手順に従って PAUSE ステートを終了. */
    /* 2. ZDMA_CH_CTRL0レジスタの POINT_TYPE (ビット 6) を 0 に設定 */
    /*    データソースバッファのアドレスの LSB を ZDMA_CH_SRC_DSCR_WORD0レジスタに書き込む */
    /*    データソースバッファのアドレスの MSB を ZDMA_CH_SRC_DSCR_WORD1レジスタに書き込む */
    /* 3. データデスティネーションバッファのアドレスの LSB を ZDMA_CH_DST_DSCR_WORD0レジスタに書き込む */
    /*    データデスティネーションバッファのアドレスの MSB を ZDMA_CH_DST_DSCR_WORD1レジスタに書き込む */
    /* 4. Simple Modeでは、SRCトランザクションサイズとDSTトランザクションサイズの両方を設定する必要がある */
    /*    DMA は SRCトランザクションサイズを使用しますが、両方のレジスタを設定しておく必要がある */
    /*    ZDMA_CH_SRC_DSCR_WORD2 レジスタにソースデータサイズを書き込む */
    /*    ZDMA_CH_DST_DSCR_WORD2 レジスタにデスティネーショントランザクションサイズを書き込む */
    /*    SRCトランザクションサイズとDSTトランザクションサイズは必ず同じ */
    if (emax6.rw == 0) { /* mem->lmm */
      *(Ull*)&(((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD0) = emax6.ddraddr-emax_info.ddr_mmap+emax_info.ddr_phys;     /* address should be 4B-aligned */
      ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Uint);                                     /* length should be # of words */
      *(Ull*)&(((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD0) = emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_phys;     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
      ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Uint);                                     /* length should be # of words */
      ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_CTRL2 = 1;
      do {
	status = ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_STATUS & 3;
      } while (status != 0 && status != 3);
    }
    else { /* lmm->mem */
      /* ZCU102がAXI3互換のため8beat/256bit分割するのをIMAX#0で128beat/256bit毎にまとめprefetchしておく */
      /* prefetch開始後,後続DMAREADはblockされ,prefetch完了後にBUFからREAD+response */
      /* start of DMAREADBUF */
      /*#define LMM_BASE2_PHYS 	         0x60000000  */
      /*#define LMM_BASE_PHYS	 0x0000000480000000LL ... DMAREADBUFのvsimのため, dmrp_topに差の0x20000000を加算 */
      /*                                            tb_top.convでもLMMアドレスに0x20000000を加算するのに合わせる */
      while (((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat & 0xffff00f0); //LMRING_BUSY
      ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].dmrp = (1LL<<63)|((emax6.dmalen+1)*sizeof(Uint)<<40)|(emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_phys);
      /*printf("dmrp=%08.8x_%08.8x\n", (Uint)((((struct reg_ctrl*)emax6.reg_ctrl)->i[0].dmrp)>>32), (Uint)(((struct reg_ctrl*)emax6.reg_ctrl)->i[0].dmrp));*/
      *(Ull*)&(((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD0) = emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_phys;     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
      ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Uint);                                      /* length should be # of words */
      *(Ull*)&(((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD0) = emax6.ddraddr-emax_info.ddr_mmap+emax_info.ddr_phys;     /* address should be 4B-aligned */
      ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Uint);                                      /* length should be # of words */
      ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_CTRL2 = 1;
      do {
	status = ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_STATUS & 3;
      } while (status != 0 && status != 3);
      /* end of DMAREADBUF */
      ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].dmrp = (0LL<<63); /* off */
    }
    /* 5. 必要に応じ,ZDMA_CH_DST_DSCR_WORD3およびZDMA_CH_SRC_DSCR_WORD3レジスタでINTRを1にセットし割り込みを有効にする */
    /* 6. ソースおよびデスティネーションバッファがキャッシュコヒーレントとして割り当てられているかフラッシュされている場合, */
    /*    COHRNTをセットする必要はない. それ以外の場合,ソースおよびデスティネーションバッファがキャッシュコヒーレントとして */
    /*    割り当てられていない、またはフラッシュされていない場合、ZDMA_CH_SRC_DSCR_WORD3およびZDMA_CH_DST_DSCR_WORD3レジスタで */
    /*    それぞれ COHRNTをセットする. COHRNTビットは LPD-DMA の場合のみ有効. FPD-DMAはコヒーレンシをサポートしない. */
    /* 7. ZDMA_CH_CTRL2レジスタのENビットをセットして,DMA転送に使用するDMAチャネルを有効にする. */
    /*    DMAを有効にした後、「エラー条件」に示すエラー条件をチェックする. */
    switch (status) {
    case 0:
      break;
    default: /* case 3 */
      printf("emax6_check_lmmi_and_dma(): ZDMA_CH_STATUS=%d (malfunction)\n", status);
      return (0);
    }
  }
  else { /* ★投機実行によりcache-fillを起動してしまう.投機失敗後にDMAが動き,cache-fillもされるのでmismatchとなる★ */
    /*printf("emax_info.lmm_mmap-emax_info.ddr_mmap=%08.8x_%08.8x\n", (Uint)((emax_info.lmm_mmap-emax_info.ddr_mmap)>>32), (Uint)(emax_info.lmm_mmap-emax_info.ddr_mmap));*/
    if (emax6.rw == 0) { /* mem->lmm */
      dst = emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_mmap;
      src = emax6.ddraddr;
#if 0
      printf("emax6.lmmaddr:%08.8x_%08.8x <- emax6.ddraddr:%08.8x_%08.8x\n",
	     (Uint)((Ull)((Ull*)emax6.lmmaddr)>>32), (Uint)(Ull)((Ull*)emax6.lmmaddr),
	     (Uint)((Ull)((Ull*)emax6.ddraddr)>>32), (Uint)(Ull)((Ull*)emax6.ddraddr));
#endif
    }
    else { /* lmm->mem */
      dst = emax6.ddraddr;
      src = emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_mmap;
#if 0
      printf("emax6.lmmaddr:%08.8x_%08.8x -> emax6.ddraddr:%08.8x_%08.8x\n",
	     (Uint)((Ull)((Ull*)emax6.lmmaddr)>>32), (Uint)(Ull)((Ull*)emax6.lmmaddr),
	     (Uint)((Ull)((Ull*)emax6.ddraddr)>>32), (Uint)(Ull)((Ull*)emax6.ddraddr));
#endif
    }
    /* srcとdstは32Bアラインされており,片側のみ非アラインになることはない */
    pio_words = emax6.dmalen+1;
    if (src & (sizeof(Ull)-1) & sizeof(Uint)) { /* 4B-access 0,4 */
      *(Uint*)dst = *(Uint*)src;
      src += sizeof(Uint);
      dst += sizeof(Uint);
      pio_words--;
    }
    if (pio_words >= 2) {
      if (src & (sizeof(Dll)-1) & sizeof(Ull)) { /* 8B-access 0,4 */
	*(Ull*)dst = *(Ull*)src;
	src += sizeof(Ull);
	dst += sizeof(Ull);
	pio_words-=2;
      }
    }
    if (pio_words >= 4) {
      if (pio_loop = pio_words/(sizeof(Dll)/sizeof(Uint))) {
	for(pio_i=0; pio_i<pio_loop; pio_i++)
	  *((Dll*)dst + pio_i) = *((Dll*)src + pio_i);
	pio_words -= pio_loop*(sizeof(Dll)/sizeof(Uint));
	src += pio_loop*sizeof(Dll);
	dst += pio_loop*sizeof(Dll);
      }
    }
    if (pio_words >= 2) { /* 8B-access */
      *(Ull*)dst = *(Ull*)src;
      src += sizeof(Ull);
      dst += sizeof(Ull);
      pio_words-=2;
    }
    if (pio_words >= 1) { /* 4B-access */
      *(Uint*)dst = *(Uint*)src;
      src += sizeof(Uint);
      dst += sizeof(Uint);
      pio_words--;
    }
  }

  return (0);
}

/*******************************************************************************/
/******************************** EMAX6-START **********************************/
/*******************************************************************************/

/* lmmwb=0: if lmm never be written back to DDR */
emax6_pre_with_keep_cache()
{
  /* (conf -> scon -> addr -> breg ) -> dma -> exec -> dma -> term */
#ifdef ARMSIML
  emax_pre_with_keep_cache(); /* start syscall EMAX6 */
#endif
#ifdef ARMZYNQ
  /* do nothing */
#endif
}

/* lmmwb=1: if lmm may   be written back to DDR */
emax6_pre_with_drain_cache()
{
  /* (conf -> scon -> addr -> breg ) -> dma -> exec -> dma -> term */
#ifdef ARMSIML
  emax_pre_with_drain_cache(); /* start syscall EMAX6 */
#endif
#ifdef ARMZYNQ
  /* do nothing */
#endif
}

#endif

/*******************************************************************************/
/******************************** EMAX6 NCLIB (no conv-c2c)*********************/
/*******************************************************************************/

void /*__attribute__((always_inline))*/
cex(Uint op_cx, Ull *ex, Ull c3, Ull c2, Ull c1, Ull c0, Ushort pattern)
{
  Uint index1, index0;

  switch (op_cx) {
  case OP_NOP:
    if (ex)
      *ex = 3; /* for bsim */
    break;
  case OP_CEXE:
    index1 = ((c3>>32&1)<<3)|((c2>>32&1)<<2)|((c1>>32&1)<<1)|(c0>>32&1);
    index0 = ((c3    &1)<<3)|((c2    &1)<<2)|((c1    &1)<<1)|(c0    &1);
    *ex = 0;
    if (pattern>>index1&1) *ex |= 2;
    if (pattern>>index0&1) *ex |= 1;
    break;
  default:
    printf("emax6lib: cex: undefined op_cx=%d\n", op_cx);
    break;
  }  
}

void /*__attribute__((always_inline))*/
ex4(Uint op_ex1, Ull *d, Ull *r1, Uint exp1, Ull *r2, Uint exp2, Ull *r3, Uint exp3, Uint op_ex2, Ull *r4, Uint op_ex3, Ull *r5)
{
  switch (op_ex1) {
  case OP_SFMA: /* 8bit*8  3in stochastic r1+r2*r3 -> 8bit */
    exe(op_ex1, (d+0), (Ull)r1, exp1, *(r2+0), exp2, *(r3+0), exp3, OP_NOP, (Ull)r4, OP_NOP, (Ull)r5);
    exe(op_ex1, (d+0), *(d+0),  exp1, *(r2+1), exp2, *(r3+1), exp3, OP_NOP, (Ull)r4, OP_NOP, (Ull)r5);
    exe(op_ex1, (d+0), *(d+0),  exp1, *(r2+2), exp2, *(r3+2), exp3, OP_NOP, (Ull)r4, OP_NOP, (Ull)r5);
    exe(op_ex1, (d+0), *(d+0),  exp1, *(r2+3), exp2, *(r3+3), exp3, OP_NOP, (Ull)r4, OP_NOP, (Ull)r5);
    break;
  case OP_NOP:
  case OP_CFMA: /* [idx|32bit]*2 3in =(idx2==idx3)?r1+r2*r3:r1 */
  case OP_FMA:  /* 32bit*2 3in floating-point r1+r2*r3 */
  case OP_FMS:  /* 32bit*2 3in floating-point r1-r2*r3 */
  case OP_FAD:  /* 32bit*2 2in floating-point r1+r2 */
  case OP_FML:  /* 32bit*2 2in floating-point r1*r2 */
  case OP_ADD3: /* 32bit*2 3in fixed-point r1+(r2+r3) */
  case OP_SUB3: /* 32bit*2 3in fixed-point r1-(r2+r3) */
  case OP_ADD:  /* 32bit*2 2in fixed-point r1+r2 */
  case OP_SUB:  /* 32bit*2 2in fixed-point r1-r2 */
    exe(op_ex1, (d+0), *(r1+0), exp1, *(r2+0), exp2, *(r3+0), exp3, OP_NOP, 0LL, OP_NOP, 0LL);
    exe(op_ex1, (d+1), *(r1+1), exp1, *(r2+1), exp2, *(r3+1), exp3, OP_NOP, 0LL, OP_NOP, 0LL);
    exe(op_ex1, (d+2), *(r1+2), exp1, *(r2+2), exp2, *(r3+2), exp3, OP_NOP, 0LL, OP_NOP, 0LL);
    exe(op_ex1, (d+3), *(r1+3), exp1, *(r2+3), exp2, *(r3+3), exp3, OP_NOP, 0LL, OP_NOP, 0LL);
    break;
  default:
    printf("emax6lib: ex4: undefined op_ex1=%d\n", op_ex1);
    break;
  }

  switch (op_ex2) {
  case OP_NOP:
    break;
  default:
    printf("emax6lib: ex4: illegal op_ex2=%d\n", op_ex2);
    break;
  }

  switch (op_ex3) {
  case OP_NOP:
    break;
  default:
    printf("emax6lib: ex4: illegal op_ex3=%d\n", op_ex3);
    break;
  }
}

int convf32tou7(u7bit *out, float in)
{
  //  convf32tou7 e=126     0.992 -> s0111111  0111111111111111111111111111111111111111111111111111111111111111
  //  convf32tou7 e=126 f=0 0.500 -> s0100000  0000000000000000000000000000000011111111111111111111111111111111
  //  convf32tou7 e=125 f=0 0.250 -> s0010000  0000000000000000000000000000000000000000000000001111111111111111
  //  convf32tou7 e=124 f=0 0.125 -> s0001000  0000000000000000000000000000000000000000000000000000000011111111
  //  convf32tou7 e=123 f=0 0.062 -> s0000100  0000000000000000000000000000000000000000000000000000000000001111
  //  convf32tou7 e=122 f=0 0.031 -> s0000010  0000000000000000000000000000000000000000000000000000000000000011
  //  convf32tou7 e=121 f=0 0.016 -> s0000001  0000000000000000000000000000000000000000000000000000000000000001
  //                        0.000 -> s0000000  0000000000000000000000000000000000000000000000000000000000000000
  f32bit in_f32;

  *(float*)&in_f32 = in;

  out->s = in_f32.s;
  out->b = 0;

  in = abs(in);
  if  (in >= 1.0) out->e = 63;    /* 乗算時は6bit表現(-1.0+1.0) */
  else            out->e = in*64; /* number of 1 */    

//printf("%7.4f -> %02.2x\n", *(float*)&in_f32, *(Uchar*)out);
}

int convf32tou8(u8bit *out, float in)
{
  f32bit in_f32;

  *(float*)&in_f32 = in;

  out->s = in_f32.s;

  in = abs(in);
  if  (in >= 2.0) out->e = 127;   /* 乗算時は6bit表現(-1.0+1.0) */
  else            out->e = in*64; /* number of 1 */    

//printf("%7.4f -> %02.2x\n", *(float*)&in_f32, *(Uchar*)out);
}

int convu8tof32(float *out, u8bit in)
{
  f32bit out_f32;

  *(float*)&out_f32 = (float)in.e/64; /* 6bit表現(-2.0+2.0) */
  out_f32.s = in.s;
  *out = *(float*)&out_f32;

//printf("%02.2x -> %7.4f\n", *(Uchar*)&in, *out);
}

Ull urand(int no)
{
  static Ull urand_seed[8]
    = {0xc3c3c3c3a5a5a5a5LL, 0x123456789abcdef0LL, 0xe1e1e1e1d4d4d4d4LL, 0x8888777766665555LL,
       0x8787878796969696LL, 0xfedcba9876543210LL, 0x5a5a5a5a3c3c3c3cLL, 0xbbbbccccddddeeeeLL};
  Ull retval = urand_seed[no];

//urand_seed = urand_seed * 1103515245LL + 12345LL;

  urand_seed[no] ^= (urand_seed[no]<<29);
  urand_seed[no] ^= (urand_seed[no]>>27);
  urand_seed[no] ^= (urand_seed[no]<<37);
  return (retval);
}

Ull shfl(Ull in, Ull r)
{
  int i;
  for (i=0; i<32; i++) {
    if (r&(1LL<<(i+16)))
      in = (in&~(1LL<<(i+32)|1LL<<i)) | (in>>i&1)<<(i+32) | (in>>(i+32)&1)<<i;
  }
  for (i=0; i<48; i++) {
    if (r&(1LL<<(i+8)))
      in = (in&~(1LL<<(i+16)|1LL<<i)) | (in>>i&1)<<(i+16) | (in>>(i+16)&1)<<i;
  }
  for (i=0; i<56; i++) {
    if (r&(1LL<<(i+4)))
      in = (in&~(1LL<<(i+ 8)|1LL<<i)) | (in>>i&1)<<(i+ 8) | (in>>(i+ 8)&1)<<i;
  }
  for (i=0; i<60; i++) {
    if (r&(1LL<<(i+2)))
      in = (in&~(1LL<<(i+ 4)|1LL<<i)) | (in>>i&1)<<(i+ 4) | (in>>(i+ 4)&1)<<i;
  }
  for (i=0; i<62; i++) {
    if (r&(1LL<<(i+1)))
      in = (in&~(1LL<<(i+ 2)|1LL<<i)) | (in>>i&1)<<(i+ 2) | (in>>(i+ 2)&1)<<i;
  }
  for (i=0; i<63; i++) {
    if (r&(1LL<<(i+0)))
      in = (in&~(1LL<<(i+ 1)|1LL<<i)) | (in>>i&1)<<(i+ 1) | (in>>(i+ 1)&1)<<i;
  }
  return(in);
}

int enable_x11;    /* 0 or set in extern */

void x11_softu64_dist(float, float);
int softu64(int stage, Ull *o1, Ull *o2, Ull *o3, Ull r1, Ull r2, Ull r3, Ull r4) /* o <- s1 + s2 * s3 */
     /* stage:1 stage_2 in EXEC:  r2*r3 64bit*2  -> *o1 32bit*8 b mult     */
     /* stage:2 stage_3 in EXEC:  *o1,r4 32bit*8 -> *o2 8bit+8bit count up */
     /* stage:3 stage_4 in EXEC:  r1 + *o2Σ     -> *o3 8bit               */
{
  int i, j;
  Ull u[8];
  Ull ss[8];
  Ull s2[8], s3[8];
  int pc, nc; /* number of 1 */
  int os, oc;

//#define SPU_DATA_BITS 31
//#define SPU_DATA_DIST 2
//#define SPU_COUT_BITS 31
#define SPU_DATA_BITS 15
#define SPU_DATA_DIST 4
#define SPU_COUT_BITS 12

  switch (stage) {
  case 1: /* stage2 */
    for (i=0; i<8; i++) /* s2 * s3 -> ad2 */
      u[i] = urand(i);
    for (i=0; i<8; i++) { /* s2 * s3 -> ad2 */
      ss[i] = (r2>>(i*8+7))&1 ^ (r3>>(i*8+7))&1;
  int s2e   = (r2>>(i*8))&0x7f; s2e = s2e<SPU_DATA_BITS?s2e:SPU_DATA_BITS;
  int s3e   = (r3>>(i*8))&0x7f; s3e = s3e<SPU_DATA_BITS?s3e:SPU_DATA_BITS;
#if 0
      s2[i] = (Ull)0x7fffffffffffffffLL>>(63-s2e); //乗算は6bit*6bit->6bit
      s3[i] = (Ull)0x7fffffffffffffffLL>>(63-s3e); //乗算は6bit*6bit->6bit
      // 下位64bit内でシャッフル
      s2[i] = shfl(s2[i], u[2]);
      s3[i] = shfl(s3[i], u[3]);
#else
      // 乱数をSPU_DATA_WIDTH bit毎に使用.入力値の6bitがほとんど15以下であることを利用(63近くなると誤差が出るはず)
      s2[i] = 0LL;
      s3[i] = 0LL;
      for (j=0; j<SPU_COUT_BITS; j++) {
	int k = j * SPU_DATA_DIST; /* SPU_DATA_BITS=15なら4bit毎 */
	s2[i] |= ((u[(i+0)%8]>>k&SPU_DATA_BITS)<=s2e)<<j;
	s3[i] |= ((u[(i+1)%8]>>k&SPU_DATA_BITS)<=s3e)<<j;
      }
      //printf("%08.8x_%08.8x %08.8x_%08.8x %d:%08.8x %d:%08.8x\n", (Uint)(u2>>32), (Uint)u2, (Uint)(u3>>32), (Uint)u3, s2e, (Uint)s2[i], s3e, (Uint)s3[i]);
#endif
      // s2*s3 各要素のstochastic乗算
      o1[i] = s2[i] & s3[i];                         // 1*1=1になる 実際は上位SPU_DATA_BITSのみAND
      o1[i] = ss[i]<<63|(o1[i]&0x7fffffffffffffffLL);// stage2の出力は(先頭符号bit|SPU_DATA_BITS bit) * 8
    }
    break;
  case 2: /* stage3 */
    pc = 0;
    nc = 0;
    // 正数/負数グループごとに，下位部分をスナップショット
    for (j=0; j<SPU_COUT_BITS; j++) {
      for (i=0; i<8; i++) { /* s2 * s3 -> ad2 */
	if (!(o1[i]>>63)) pc += (o1[i] & (1LL<<j))!=0;
	else              nc += (o1[i] & (1LL<<j))!=0;
      }
    }
    pc = pc>>r4; // r4=3 for MNIST/CIFAR10
    nc = nc>>r4; // r4=2 for test021
    *o2 = (Ull)(pc&0xffff)<<32 | (Ull)(nc&0xffff);
    break;
  case 3: /* stage4 */
    pc = *o2>>32&0xffff; /* high */
    nc = *o2    &0xffff; /* low */
    // s1をさらに加算
    if (!(r1&0x80)) pc += (r1&0x7f); /* merge pos s1 s1.eは最大7bit */
    else            nc += (r1&0x7f); /* merge neg s1 s1.eは最大7bit */
    // 正数と負数の加算(s1:7bit + s2*s3:6bit->7bit)
    if (pc >= nc) {
      os = 0x00; /* pos */
      oc = pc-nc; /* # of 1 */
    }
    else {
      os = 0x80; /* neg */
      oc = nc-pc; /* # of 1 */
    }
    if (oc >= 128) oc = 127;
    *o3 = os|oc;
#if !defined(ARMSIML) && defined(TRACE_SPIKE)
    if (enable_x11) {
      int i;
      u8bit r2_u8;
      u8bit r3_u8;
      float r1_f32;
      float r2_f32;
      float r3_f32;
      float o3_f32;
      convu8tof32(&o3_f32, *(u8bit*)o3);   /* for graph */
      convu8tof32(&r1_f32, *(u8bit*)&r1); /* for graph */
      for (i=0; i<8; i++) { /* s2 * s3 -> ad2 */
	*(Uchar*)&r2_u8 = r2>>(i*8)&0xff;
	*(Uchar*)&r3_u8 = r3>>(i*8)&0xff;
	convu8tof32(&r2_f32, r2_u8); /* for graph */
	convu8tof32(&r3_f32, r3_u8); /* for graph */
	r1_f32 += r2_f32*r3_f32;
      }
      x11_softu64_dist(r1_f32, o3_f32);
    }
#endif
    break;
  }

  return (0);
}

Ull __attribute__((always_inline))
exm(Ull s, Uchar exp)
{
  switch (exp) {
  case EXP_H3210: return ( s );
  case EXP_H1010: return ((s<<32&0xffffffff00000000LL) | (s    &0x00000000ffffffffLL));
  case EXP_H3232: return ((s    &0xffffffff00000000LL) | (s>>32&0x00000000ffffffffLL));
  case EXP_B7632: return ((s>> 8&0x00ff000000ff0000LL) | (s>>16&0x000000ff000000ffLL));
  case EXP_B5410: return ((s<< 8&0x00ff000000ff0000LL) | (s    &0x000000ff000000ffLL));
  default:        return ( s );
  }
}

int  /*__attribute__((always_inline))*/
exe(Uint op_ex1, Ull *d, Ull s1, Uint exp1, Ull s2, Uint exp2, Ull s3, Uint exp3, Uint op_ex2, Ull r4, Uint op_ex3, Ull r5)
{
  /* return 0:normal, 1:OP_WHILE breaks */
  union { Uint i; float f; } f3, f2, f1, f0;
  Ull r1, r2, r3;
  Ull t3, t2, t1, t0;
  Ull ro00, ro01, ro02, ro10, ro11, ro12;
  Ull c1, c0;
  Ull ex1_outd;
  Ull ex1_outd_sfma[8];
  Ull ex2_outd;
  int retval = 0;

  r1 = exm(s1, exp1);
  r2 = exm(s2, exp2);
  r3 = exm(s3, exp3);

  switch (op_ex1) {
  case OP_NOP:
    ex1_outd = r1;
    break;
  case OP_WHILE: /* emax6ncのlibとしては使用せず,bsim/emax6.cがsimlに使用 */
    t0 = (r1&0x00000000ffffffffLL)+(r2&0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    ex1_outd = t0;
    if (t0==0) retval = 1;
    break;
  case OP_FOR: /* emax6ncのlibとしては使用せず,bsim/emax6.cがsimlに使用 */
    t0 = (r1&0x00000000ffffffffLL)+(r2&0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    ex1_outd = t0;
    if (t0==0) retval = 1;
    break;
  case OP_SFMA: /* 8bit*8  3in stochastic r1+r2*r3 -> 8bit */
    softu64(1, ex1_outd_sfma, NULL, NULL, r1, r2, r3, r4);
    break;
  case OP_CFMA: /* [idx|32bit]*2 3in =(idx2==idx3)?r1+r2*r3:r1 */
    f1.i = (Uint)(r1);
    f2.i = (Uint)(r2>>32);
    f3.i = (Uint)(r3>>32);
    if (f2.i != -1 && f2.i == f3.i) {
      f2.i = (Uint)(r2);
      f3.i = (Uint)(r3);
      f0.f = f1.f + (f2.f * f3.f);
    }
    else {
      f0.f = f1.f;
    }
    t0 = f0.i;
    ex1_outd = t0;
    break;
  case OP_FMA: /* 32bit*2 3in floating-point r1+r2*r3 */
  case OP_FMS: /* 32bit*2 3in floating-point r1-r2*r3 */
    /* *(double*)&ex1_outd = *(double*)&r1 + (*(double*)&r2 * *(double*)&r3);*/
    f1.i = (Uint)(r1>>32);
    f2.i = (Uint)(r2>>32)^(op_ex1==OP_FMA?0:0x80000000);
    f3.i = (Uint)(r3>>32);
    f0.f = f1.f + (f2.f * f3.f);
    t2 = f0.i;
    f1.i = (Uint)(r1);
    f2.i = (Uint)(r2)^(op_ex1==OP_FMA?0:0x80000000);
    f3.i = (Uint)(r3);
    f0.f = f1.f + (f2.f * f3.f);
    t0 = f0.i;
    ex1_outd = (t2<<32)|(t0);
    break;
  case OP_FAD: /* 32bit*2 3in floating-point r1+r2 */
    /* *(double*)&ex1_outd = *(double*)&r1 + *(double*)&r2;*/
    f1.i = (Uint)(r1>>32);
    f2.i = (Uint)(r2>>32);
    f0.f = f1.f + f2.f;
    t2 = f0.i;
    f1.i = (Uint)(r1);
    f2.i = (Uint)(r2);
    f0.f = f1.f + f2.f;
    t0 = f0.i;
    ex1_outd = (t2<<32)|(t0);
    break;
  case OP_FML: /* 32bit*2 3in floating-point r1*r2 */
    /* *(double*)&ex1_outd = *(double*)&r1 * *(double*)&r2;*/
    f1.i = (Uint)(r1>>32);
    f2.i = (Uint)(r2>>32);
    f0.f = f1.f * f2.f;
    t2 = f0.i;
    f1.i = (Uint)(r1);
    f2.i = (Uint)(r2);
    f0.f = f1.f * f2.f;
    t0 = f0.i;
    ex1_outd = (t2<<32)|(t0);
    break;
  case OP_ADD3: /* 32bit*2 3in integer add s1+(s2+s3) */
    t2 = (r1>>32&0x00000000ffffffffLL)+((r2>>32&0x00000000ffffffffLL)+(r3>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (r1    &0x00000000ffffffffLL)+((r2    &0x00000000ffffffffLL)+(r3    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    ex1_outd = (t2<<32)|(t0);
    break;
  case OP_SUB3: /* 32bit*2 3in integer subtract s1-(s2+s3) */
    t2 = (r1>>32&0x00000000ffffffffLL)-((r2>>32&0x00000000ffffffffLL)+(r3>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (r1    &0x00000000ffffffffLL)-((r2    &0x00000000ffffffffLL)+(r3    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    ex1_outd = (t2<<32)|(t0);
    break;
  case OP_ADD: /* 32bit*2 2in integer add s1+s2 */
    t2 = (r1>>32&0x00000000ffffffffLL)+(r2>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (r1    &0x00000000ffffffffLL)+(r2    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    ex1_outd = (t2<<32)|(t0);
    break;
  case OP_SUB: /* 32bit*2 2in integer subtract s1-s2 */
    t2 = (r1>>32&0x00000000ffffffffLL)-(r2>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (r1    &0x00000000ffffffffLL)-(r2    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    ex1_outd = (t2<<32)|(t0);
    break;
  case OP_CMP_EQ: /* 32bit*2 2in compare and set 1*2bit-CC */
    c1 = (r1>>32&0x00000000ffffffffLL) == (r2>>32&0x00000000ffffffffLL);
    c0 = (r1    &0x00000000ffffffffLL) == (r2    &0x00000000ffffffffLL);
    ex1_outd = (c1<<32)|c0;
    break;
  case OP_CMP_NE: /* 32bit*2 2in compare and set 1*2bit-CC */
    c1 = (r1>>32&0x00000000ffffffffLL) != (r2>>32&0x00000000ffffffffLL);
    c0 = (r1    &0x00000000ffffffffLL) != (r2    &0x00000000ffffffffLL);
    ex1_outd = (c1<<32)|c0;
    break;
  case OP_CMP_LT: /* 32bit*2 2in compare and set 1*2bit-CC */
    c1 = (r1>>32&0x00000000ffffffffLL) < (r2>>32&0x00000000ffffffffLL);
    c0 = (r1    &0x00000000ffffffffLL) < (r2    &0x00000000ffffffffLL);
    ex1_outd = (c1<<32)|c0;
    break;
  case OP_CMP_LE: /* 32bit*2 2in compare and set 1*2bit-CC */
    c1 = (r1>>32&0x00000000ffffffffLL) <= (r2>>32&0x00000000ffffffffLL);
    c0 = (r1    &0x00000000ffffffffLL) <= (r2    &0x00000000ffffffffLL);
    ex1_outd = (c1<<32)|c0;
    break;
  case OP_CMP_GT: /* 32bit*2 2in compare and set 1*2bit-CC */
    c1 = (r1>>32&0x00000000ffffffffLL) > (r2>>32&0x00000000ffffffffLL);
    c0 = (r1    &0x00000000ffffffffLL) > (r2    &0x00000000ffffffffLL);
    ex1_outd = (c1<<32)|c0;
    break;
  case OP_CMP_GE: /* 32bit*2 2in compare and set 1*2bit-CC */
    c1 = (r1>>32&0x00000000ffffffffLL) >= (r2>>32&0x00000000ffffffffLL);
    c0 = (r1    &0x00000000ffffffffLL) >= (r2    &0x00000000ffffffffLL);
    ex1_outd = (c1<<32)|c0;
    break;
  case OP_CMOV: /* 32bit*2 3in 2bit conditional move */
    c1 = r1>>32&1;
    c0 = r1    &1;
    t2 = c1 ? (r2&0xffffffff00000000LL) : (r3&0xffffffff00000000LL);
    t0 = c0 ? (r2&0x00000000ffffffffLL) : (r3&0x00000000ffffffffLL);
    ex1_outd = t2 | t0;
    break;
//case OP_CCAT: /* 32bit 2in s1<<32|s2 concatenate */
//  ex1_outd = (r1<<32)|(r2);
//  break;
  case OP_MAUH3: /* 16bit*4 3in r1.pos+(r2.pos+r3.pos) */
    t3 = (r1>>48&0x000000000000ffffLL)+((r2>>48&0x000000000000ffffLL)+(r3>>48&0x000000000000ffffLL));
    if (t3 > 0x000000000000ffffLL) t3 = 0x000000000000ffffLL;
    t2 = (r1>>32&0x000000000000ffffLL)+((r2>>32&0x000000000000ffffLL)+(r3>>32&0x000000000000ffffLL));
    if (t2 > 0x000000000000ffffLL) t2 = 0x000000000000ffffLL;
    t1 = (r1>>16&0x000000000000ffffLL)+((r2>>16&0x000000000000ffffLL)+(r3>>16&0x000000000000ffffLL));
    if (t1 > 0x000000000000ffffLL) t1 = 0x000000000000ffffLL;
    t0 = (r1    &0x000000000000ffffLL)+((r2    &0x000000000000ffffLL)+(r3    &0x000000000000ffffLL));
    if (t0 > 0x000000000000ffffLL) t0 = 0x000000000000ffffLL;
    ex1_outd = (t3<<48)|(t2<<32)|(t1<<16)|(t0);
    break;
  case OP_MAUH: /* 16bit*4 2in r1.pos+r2.pos */
    t3 = (r1>>48&0x000000000000ffffLL)+(r2>>48&0x000000000000ffffLL);
    if (t3 > 0x000000000000ffffLL) t3 = 0x000000000000ffffLL;
    t2 = (r1>>32&0x000000000000ffffLL)+(r2>>32&0x000000000000ffffLL);
    if (t2 > 0x000000000000ffffLL) t2 = 0x000000000000ffffLL;
    t1 = (r1>>16&0x000000000000ffffLL)+(r2>>16&0x000000000000ffffLL);
    if (t1 > 0x000000000000ffffLL) t1 = 0x000000000000ffffLL;
    t0 = (r1    &0x000000000000ffffLL)+(r2    &0x000000000000ffffLL);
    if (t0 > 0x000000000000ffffLL) t0 = 0x000000000000ffffLL;
    ex1_outd = (t3<<48)|(t2<<32)|(t1<<16)|(t0);
    break;
  case OP_MSUH3: /* 16bit*4 3in r1.pos-(r2.pos+r3.pos) */
    t3 = (r1>>48&0x000000000000ffffLL)-((r2>>48&0x000000000000ffffLL)+(r3>>48&0x000000000000ffffLL));
    if (t3 > 0x000000000000ffffLL) t3 = 0x0000000000000000LL;
    t2 = (r1>>32&0x000000000000ffffLL)-((r2>>32&0x000000000000ffffLL)+(r3>>32&0x000000000000ffffLL));
    if (t2 > 0x000000000000ffffLL) t2 = 0x0000000000000000LL;
    t1 = (r1>>16&0x000000000000ffffLL)-((r2>>16&0x000000000000ffffLL)+(r3>>16&0x000000000000ffffLL));
    if (t1 > 0x000000000000ffffLL) t1 = 0x0000000000000000LL;
    t0 = (r1    &0x000000000000ffffLL)-((r2    &0x000000000000ffffLL)+(r3    &0x000000000000ffffLL));
    if (t0 > 0x000000000000ffffLL) t0 = 0x0000000000000000LL;
    ex1_outd = (t3<<48)|(t2<<32)|(t1<<16)|(t0);
    break;
  case OP_MSUH: /* 16bit*4 2in r1.pos-r2.pos */
    t3 = (r1>>48&0x000000000000ffffLL)-(r2>>48&0x000000000000ffffLL);
    if (t3 > 0x000000000000ffffLL) t3 = 0x0000000000000000LL;
    t2 = (r1>>32&0x000000000000ffffLL)-(r2>>32&0x000000000000ffffLL);
    if (t2 > 0x000000000000ffffLL) t2 = 0x0000000000000000LL;
    t1 = (r1>>16&0x000000000000ffffLL)-(r2>>16&0x000000000000ffffLL);
    if (t1 > 0x000000000000ffffLL) t1 = 0x0000000000000000LL;
    t0 = (r1    &0x000000000000ffffLL)-(r2    &0x000000000000ffffLL);
    if (t0 > 0x000000000000ffffLL) t0 = 0x0000000000000000LL;
    ex1_outd = (t3<<48)|(t2<<32)|(t1<<16)|(t0);
    break;
  case OP_MLUH: /* (11bit*4)*9bit r1.pos*r2.pos */
    t3 = (r1>>48&0x00000000000007ffLL)*(r2&0x00000000000001ffLL);
    if (t3 > 0x000000000000ffffLL) t3 = 0x000000000000ffffLL;
    t2 = (r1>>32&0x00000000000007ffLL)*(r2&0x00000000000001ffLL);
    if (t2 > 0x000000000000ffffLL) t2 = 0x000000000000ffffLL;
    t1 = (r1>>16&0x00000000000007ffLL)*(r2&0x00000000000001ffLL);
    if (t1 > 0x000000000000ffffLL) t1 = 0x000000000000ffffLL;
    t0 = (r1    &0x00000000000007ffLL)*(r2&0x00000000000001ffLL);
    if (t0 > 0x000000000000ffffLL) t0 = 0x000000000000ffffLL;
    ex1_outd = (t3<<48)|(t2<<32)|(t1<<16)|(t0);
    break;
  case OP_MMRG: /* 8bit*2 3in r1.b4|r2.b4|r3.b4|0->w1, r1.b0|r2.b0|r3.b0|0->w0 */
    ex1_outd = ((r1&0x000000ff00000000LL)<<24) | ((r2&0x000000ff00000000LL)<<16) | ((r3&0x000000ff00000000LL)<<8)
             | ((r1&0x00000000000000ffLL)<<24) | ((r2&0x00000000000000ffLL)<<16) | ((r3&0x00000000000000ffLL)<<8);
    break;
  case OP_MSSAD: /* 16bit*4 8bit*8 2in r1.h3+df(r2.b7,r3.b7)+df(r2.b6,r3.b6)->d.h3
                                       r1.h2+df(r2.b5,r3.b5)+df(r2.b4,r3.b4)->d.h2
                                       r1.h1+df(r2.b3,r3.b3)+df(r2.b2,r3.b2)->d.h1
                                       r1.h0+df(r2.b1,r3.b1)+df(r2.b0,r3.b0)->d.h0 */
    t3 = (r1>>48&0x000000000000ffffLL) + ad(r2>>56&0x00000000000000ffLL, r3>>56&0x00000000000000ffLL) + ad(r2>>48&0x00000000000000ffLL, r3>>48&0x00000000000000ffLL);
    if (t3 > 0x000000000000ffffLL) t3 = 0x000000000000ffffLL;
    t2 = (r1>>32&0x000000000000ffffLL) + ad(r2>>40&0x00000000000000ffLL, r3>>40&0x00000000000000ffLL) + ad(r2>>32&0x00000000000000ffLL, r3>>32&0x00000000000000ffLL);
    if (t2 > 0x000000000000ffffLL) t2 = 0x000000000000ffffLL;
    t1 = (r1>>16&0x000000000000ffffLL) + ad(r2>>24&0x00000000000000ffLL, r3>>24&0x00000000000000ffLL) + ad(r2>>16&0x00000000000000ffLL, r3>>16&0x00000000000000ffLL);
    if (t1 > 0x000000000000ffffLL) t1 = 0x000000000000ffffLL;
    t0 = (r1    &0x000000000000ffffLL) + ad(r2>> 8&0x00000000000000ffLL, r3>> 8&0x00000000000000ffLL) + ad(r2    &0x00000000000000ffLL, r3    &0x00000000000000ffLL);
    if (t0 > 0x000000000000ffffLL) t0 = 0x000000000000ffffLL;
    ex1_outd = (t3<<48)|(t2<<32)|(t1<<16)|(t0);
    break;
  case OP_MSAD: /* 16bit*4 8bit*8 2in df(r1.b7,r2.b7)+df(r1.b6,r2.b6)->d.h3
                                      df(r1.b5,r2.b5)+df(r1.b4,r2.b4)->d.h2
                                      df(r1.b3,r2.b3)+df(r1.b2,r2.b2)->d.h1
                                      df(r1.b1,r2.b1)+df(r1.b0,r2.b0)->d.h0 */
    t3 = ad(r1>>56&0x00000000000000ffLL, r2>>56&0x00000000000000ffLL) + ad(r1>>48&0x00000000000000ffLL, r2>>48&0x00000000000000ffLL);
    if (t3 > 0x000000000000ffffLL) t3 = 0x000000000000ffffLL;
    t2 = ad(r1>>40&0x00000000000000ffLL, r2>>40&0x00000000000000ffLL) + ad(r1>>32&0x00000000000000ffLL, r2>>32&0x00000000000000ffLL);
    if (t2 > 0x000000000000ffffLL) t2 = 0x000000000000ffffLL;
    t1 = ad(r1>>24&0x00000000000000ffLL, r2>>24&0x00000000000000ffLL) + ad(r1>>16&0x00000000000000ffLL, r2>>16&0x00000000000000ffLL);
    if (t1 > 0x000000000000ffffLL) t1 = 0x000000000000ffffLL;
    t0 = ad(r1>> 8&0x00000000000000ffLL, r2>> 8&0x00000000000000ffLL) + ad(r1    &0x00000000000000ffLL, r2    &0x00000000000000ffLL);
    if (t0 > 0x000000000000ffffLL) t0 = 0x000000000000ffffLL;
    ex1_outd = (t3<<48)|(t2<<32)|(t1<<16)|(t0);
    break;
  case OP_MINL3: /* 16bit*4 3in (r3.h3<r3.h2)?r1.h3|r3.h3:r2.h3|r3.h2->d.w1
                                (r3.h1<r3.h0)?r1.h1|r3.h1:r2.h1|r3.h0->d.w0 */
    t3 = r3>>48&0x000000000000ffffLL;
    t2 = r3>>32&0x000000000000ffffLL;
    t1 = r3>>16&0x000000000000ffffLL;
    t0 = r3    &0x000000000000ffffLL;
    if (t3<t2) t2 = (r1&0xffff000000000000LL)|(r3>>16&0x0000ffff00000000LL);
    else       t2 = (r2&0xffff000000000000LL)|(r3    &0x0000ffff00000000LL);
    if (t1<t0) t0 = (r1&0x00000000ffff0000LL)|(r3>>16&0x000000000000ffffLL);
    else       t0 = (r2&0x00000000ffff0000LL)|(r3    &0x000000000000ffffLL);
    ex1_outd = t2 | t0;
    break;
  case OP_MINL: /* 16bit*4 2in (r1.h2<r2.h2)?r1.w1:r2.w1->d.w1
	                       (r1.h0<r2.h0)?r1.w0:r2.w0->d.w0 */
    if ((r1&0x0000ffff00000000LL)<(r2&0x0000ffff00000000LL)) t2 = r1&0xffffffff00000000LL;
    else                                                     t2 = r2&0xffffffff00000000LL;
    if ((r1&0x000000000000ffffLL)<(r2&0x000000000000ffffLL)) t0 = r1&0x00000000ffffffffLL;
    else                                                     t0 = r2&0x00000000ffffffffLL;
    ex1_outd = t2 | t0;
   break;
  case OP_MH2BW: /* 16bit*4 2in r1.b6|r1.b4|r2.b6|r2.b4|r1.b2|r1.b0|r2.b2|r2.b0 */
    ex1_outd = (((r1>>48&0x000000000000ff00LL) ? 255 : (r1>>48&0x00000000000000ffLL))<<56)
             | (((r1>>32&0x000000000000ff00LL) ? 255 : (r1>>32&0x00000000000000ffLL))<<48)
             | (((r2>>48&0x000000000000ff00LL) ? 255 : (r2>>48&0x00000000000000ffLL))<<40)
             | (((r2>>32&0x000000000000ff00LL) ? 255 : (r2>>32&0x00000000000000ffLL))<<32)
             | (((r1>>16&0x000000000000ff00LL) ? 255 : (r1>>16&0x00000000000000ffLL))<<24)
             | (((r1    &0x000000000000ff00LL) ? 255 : (r1    &0x00000000000000ffLL))<<16)
             | (((r2>>16&0x000000000000ff00LL) ? 255 : (r2>>16&0x00000000000000ffLL))<< 8)
             | (((r2    &0x000000000000ff00LL) ? 255 : (r2    &0x00000000000000ffLL))    );
    break;
  case OP_MCAS: /* 16bit*2 2in (r1.h2<r2.h2)?0:0xff->d.b1
                               (r1.h0<r2.h0)?0:0xff->d.b0 */
    t2 = ((r1&0x0000ffff00000000LL)<(r2&0x0000ffff00000000LL))?0:0x000000ff00000000LL;
    t0 = ((r1&0x000000000000ffffLL)<(r2&0x000000000000ffffLL))?0:0x00000000000000ffLL;
    ex1_outd = t2 | t0;
    break;
  case OP_MMID3: /* 8bit*8 3in bytewise compare and output middle */
    t1 = ((r1&0xff00000000000000LL)<(r2&0xff00000000000000LL)?(r1&0xff00000000000000LL):(r2&0xff00000000000000LL))
       | ((r1&0x00ff000000000000LL)<(r2&0x00ff000000000000LL)?(r1&0x00ff000000000000LL):(r2&0x00ff000000000000LL))
       | ((r1&0x0000ff0000000000LL)<(r2&0x0000ff0000000000LL)?(r1&0x0000ff0000000000LL):(r2&0x0000ff0000000000LL))
       | ((r1&0x000000ff00000000LL)<(r2&0x000000ff00000000LL)?(r1&0x000000ff00000000LL):(r2&0x000000ff00000000LL))
       | ((r1&0x00000000ff000000LL)<(r2&0x00000000ff000000LL)?(r1&0x00000000ff000000LL):(r2&0x00000000ff000000LL))
       | ((r1&0x0000000000ff0000LL)<(r2&0x0000000000ff0000LL)?(r1&0x0000000000ff0000LL):(r2&0x0000000000ff0000LL))
       | ((r1&0x000000000000ff00LL)<(r2&0x000000000000ff00LL)?(r1&0x000000000000ff00LL):(r2&0x000000000000ff00LL))
       | ((r1&0x00000000000000ffLL)<(r2&0x00000000000000ffLL)?(r1&0x00000000000000ffLL):(r2&0x00000000000000ffLL));
    t2 = ((r1&0xff00000000000000LL)>(r2&0xff00000000000000LL)?(r1&0xff00000000000000LL):(r2&0xff00000000000000LL))
       | ((r1&0x00ff000000000000LL)>(r2&0x00ff000000000000LL)?(r1&0x00ff000000000000LL):(r2&0x00ff000000000000LL))
       | ((r1&0x0000ff0000000000LL)>(r2&0x0000ff0000000000LL)?(r1&0x0000ff0000000000LL):(r2&0x0000ff0000000000LL))
       | ((r1&0x000000ff00000000LL)>(r2&0x000000ff00000000LL)?(r1&0x000000ff00000000LL):(r2&0x000000ff00000000LL))
       | ((r1&0x00000000ff000000LL)>(r2&0x00000000ff000000LL)?(r1&0x00000000ff000000LL):(r2&0x00000000ff000000LL))
       | ((r1&0x0000000000ff0000LL)>(r2&0x0000000000ff0000LL)?(r1&0x0000000000ff0000LL):(r2&0x0000000000ff0000LL))
       | ((r1&0x000000000000ff00LL)>(r2&0x000000000000ff00LL)?(r1&0x000000000000ff00LL):(r2&0x000000000000ff00LL))
       | ((r1&0x00000000000000ffLL)>(r2&0x00000000000000ffLL)?(r1&0x00000000000000ffLL):(r2&0x00000000000000ffLL));
    ex1_outd = ((r3&0xff00000000000000LL)<(t1&0xff00000000000000LL)?(t1&0xff00000000000000LL):((r3&0xff00000000000000LL)<(t2&0xff00000000000000LL)?(r3&0xff00000000000000LL):(t2&0xff00000000000000LL)))
             | ((r3&0x00ff000000000000LL)<(t1&0x00ff000000000000LL)?(t1&0x00ff000000000000LL):((r3&0x00ff000000000000LL)<(t2&0x00ff000000000000LL)?(r3&0x00ff000000000000LL):(t2&0x00ff000000000000LL)))
             | ((r3&0x0000ff0000000000LL)<(t1&0x0000ff0000000000LL)?(t1&0x0000ff0000000000LL):((r3&0x0000ff0000000000LL)<(t2&0x0000ff0000000000LL)?(r3&0x0000ff0000000000LL):(t2&0x0000ff0000000000LL)))
             | ((r3&0x000000ff00000000LL)<(t1&0x000000ff00000000LL)?(t1&0x000000ff00000000LL):((r3&0x000000ff00000000LL)<(t2&0x000000ff00000000LL)?(r3&0x000000ff00000000LL):(t2&0x000000ff00000000LL)))
             | ((r3&0x00000000ff000000LL)<(t1&0x00000000ff000000LL)?(t1&0x00000000ff000000LL):((r3&0x00000000ff000000LL)<(t2&0x00000000ff000000LL)?(r3&0x00000000ff000000LL):(t2&0x00000000ff000000LL)))
             | ((r3&0x0000000000ff0000LL)<(t1&0x0000000000ff0000LL)?(t1&0x0000000000ff0000LL):((r3&0x0000000000ff0000LL)<(t2&0x0000000000ff0000LL)?(r3&0x0000000000ff0000LL):(t2&0x0000000000ff0000LL)))
             | ((r3&0x000000000000ff00LL)<(t1&0x000000000000ff00LL)?(t1&0x000000000000ff00LL):((r3&0x000000000000ff00LL)<(t2&0x000000000000ff00LL)?(r3&0x000000000000ff00LL):(t2&0x000000000000ff00LL)))
             | ((r3&0x00000000000000ffLL)<(t1&0x00000000000000ffLL)?(t1&0x00000000000000ffLL):((r3&0x00000000000000ffLL)<(t2&0x00000000000000ffLL)?(r3&0x00000000000000ffLL):(t2&0x00000000000000ffLL)));
    break;
  case OP_MMAX3: /* 8bit*8 3in bytewise compare and output maximum */
    t1 = ((r1&0xff00000000000000LL)>(r2&0xff00000000000000LL)?(r1&0xff00000000000000LL):(r2&0xff00000000000000LL))
       | ((r1&0x00ff000000000000LL)>(r2&0x00ff000000000000LL)?(r1&0x00ff000000000000LL):(r2&0x00ff000000000000LL))
       | ((r1&0x0000ff0000000000LL)>(r2&0x0000ff0000000000LL)?(r1&0x0000ff0000000000LL):(r2&0x0000ff0000000000LL))
       | ((r1&0x000000ff00000000LL)>(r2&0x000000ff00000000LL)?(r1&0x000000ff00000000LL):(r2&0x000000ff00000000LL))
       | ((r1&0x00000000ff000000LL)>(r2&0x00000000ff000000LL)?(r1&0x00000000ff000000LL):(r2&0x00000000ff000000LL))
       | ((r1&0x0000000000ff0000LL)>(r2&0x0000000000ff0000LL)?(r1&0x0000000000ff0000LL):(r2&0x0000000000ff0000LL))
       | ((r1&0x000000000000ff00LL)>(r2&0x000000000000ff00LL)?(r1&0x000000000000ff00LL):(r2&0x000000000000ff00LL))
       | ((r1&0x00000000000000ffLL)>(r2&0x00000000000000ffLL)?(r1&0x00000000000000ffLL):(r2&0x00000000000000ffLL));
    ex1_outd = ((t1&0xff00000000000000LL)>(r3&0xff00000000000000LL)?(t1&0xff00000000000000LL):(r3&0xff00000000000000LL))
             | ((t1&0x00ff000000000000LL)>(r3&0x00ff000000000000LL)?(t1&0x00ff000000000000LL):(r3&0x00ff000000000000LL))
             | ((t1&0x0000ff0000000000LL)>(r3&0x0000ff0000000000LL)?(t1&0x0000ff0000000000LL):(r3&0x0000ff0000000000LL))
             | ((t1&0x000000ff00000000LL)>(r3&0x000000ff00000000LL)?(t1&0x000000ff00000000LL):(r3&0x000000ff00000000LL))
             | ((t1&0x00000000ff000000LL)>(r3&0x00000000ff000000LL)?(t1&0x00000000ff000000LL):(r3&0x00000000ff000000LL))
             | ((t1&0x0000000000ff0000LL)>(r3&0x0000000000ff0000LL)?(t1&0x0000000000ff0000LL):(r3&0x0000000000ff0000LL))
             | ((t1&0x000000000000ff00LL)>(r3&0x000000000000ff00LL)?(t1&0x000000000000ff00LL):(r3&0x000000000000ff00LL))
             | ((t1&0x00000000000000ffLL)>(r3&0x00000000000000ffLL)?(t1&0x00000000000000ffLL):(r3&0x00000000000000ffLL));
    break;
  case OP_MMIN3: /* 8bit*8 3in bytewise compare and output minimum */
    t1 = ((r1&0xff00000000000000LL)<(r2&0xff00000000000000LL)?(r1&0xff00000000000000LL):(r2&0xff00000000000000LL))
       | ((r1&0x00ff000000000000LL)<(r2&0x00ff000000000000LL)?(r1&0x00ff000000000000LL):(r2&0x00ff000000000000LL))
       | ((r1&0x0000ff0000000000LL)<(r2&0x0000ff0000000000LL)?(r1&0x0000ff0000000000LL):(r2&0x0000ff0000000000LL))
       | ((r1&0x000000ff00000000LL)<(r2&0x000000ff00000000LL)?(r1&0x000000ff00000000LL):(r2&0x000000ff00000000LL))
       | ((r1&0x00000000ff000000LL)<(r2&0x00000000ff000000LL)?(r1&0x00000000ff000000LL):(r2&0x00000000ff000000LL))
       | ((r1&0x0000000000ff0000LL)<(r2&0x0000000000ff0000LL)?(r1&0x0000000000ff0000LL):(r2&0x0000000000ff0000LL))
       | ((r1&0x000000000000ff00LL)<(r2&0x000000000000ff00LL)?(r1&0x000000000000ff00LL):(r2&0x000000000000ff00LL))
       | ((r1&0x00000000000000ffLL)<(r2&0x00000000000000ffLL)?(r1&0x00000000000000ffLL):(r2&0x00000000000000ffLL));
    ex1_outd = ((t1&0xff00000000000000LL)<(r3&0xff00000000000000LL)?(t1&0xff00000000000000LL):(r3&0xff00000000000000LL))
             | ((t1&0x00ff000000000000LL)<(r3&0x00ff000000000000LL)?(t1&0x00ff000000000000LL):(r3&0x00ff000000000000LL))
             | ((t1&0x0000ff0000000000LL)<(r3&0x0000ff0000000000LL)?(t1&0x0000ff0000000000LL):(r3&0x0000ff0000000000LL))
             | ((t1&0x000000ff00000000LL)<(r3&0x000000ff00000000LL)?(t1&0x000000ff00000000LL):(r3&0x000000ff00000000LL))
             | ((t1&0x00000000ff000000LL)<(r3&0x00000000ff000000LL)?(t1&0x00000000ff000000LL):(r3&0x00000000ff000000LL))
             | ((t1&0x0000000000ff0000LL)<(r3&0x0000000000ff0000LL)?(t1&0x0000000000ff0000LL):(r3&0x0000000000ff0000LL))
             | ((t1&0x000000000000ff00LL)<(r3&0x000000000000ff00LL)?(t1&0x000000000000ff00LL):(r3&0x000000000000ff00LL))
             | ((t1&0x00000000000000ffLL)<(r3&0x00000000000000ffLL)?(t1&0x00000000000000ffLL):(r3&0x00000000000000ffLL));
    break;
  case OP_MMAX: /* 8bit*8 2in bytewise compare and output maximum */
    ex1_outd = ((r1&0xff00000000000000LL)>(r2&0xff00000000000000LL)?(r1&0xff00000000000000LL):(r2&0xff00000000000000LL))
             | ((r1&0x00ff000000000000LL)>(r2&0x00ff000000000000LL)?(r1&0x00ff000000000000LL):(r2&0x00ff000000000000LL))
             | ((r1&0x0000ff0000000000LL)>(r2&0x0000ff0000000000LL)?(r1&0x0000ff0000000000LL):(r2&0x0000ff0000000000LL))
             | ((r1&0x000000ff00000000LL)>(r2&0x000000ff00000000LL)?(r1&0x000000ff00000000LL):(r2&0x000000ff00000000LL))
             | ((r1&0x00000000ff000000LL)>(r2&0x00000000ff000000LL)?(r1&0x00000000ff000000LL):(r2&0x00000000ff000000LL))
             | ((r1&0x0000000000ff0000LL)>(r2&0x0000000000ff0000LL)?(r1&0x0000000000ff0000LL):(r2&0x0000000000ff0000LL))
             | ((r1&0x000000000000ff00LL)>(r2&0x000000000000ff00LL)?(r1&0x000000000000ff00LL):(r2&0x000000000000ff00LL))
             | ((r1&0x00000000000000ffLL)>(r2&0x00000000000000ffLL)?(r1&0x00000000000000ffLL):(r2&0x00000000000000ffLL));
    break;
  case OP_MMIN: /* 8bit*8 2in bytewise compare and output minimum */
    ex1_outd = ((r1&0xff00000000000000LL)<(r2&0xff00000000000000LL)?(r1&0xff00000000000000LL):(r2&0xff00000000000000LL))
             | ((r1&0x00ff000000000000LL)<(r2&0x00ff000000000000LL)?(r1&0x00ff000000000000LL):(r2&0x00ff000000000000LL))
             | ((r1&0x0000ff0000000000LL)<(r2&0x0000ff0000000000LL)?(r1&0x0000ff0000000000LL):(r2&0x0000ff0000000000LL))
             | ((r1&0x000000ff00000000LL)<(r2&0x000000ff00000000LL)?(r1&0x000000ff00000000LL):(r2&0x000000ff00000000LL))
             | ((r1&0x00000000ff000000LL)<(r2&0x00000000ff000000LL)?(r1&0x00000000ff000000LL):(r2&0x00000000ff000000LL))
             | ((r1&0x0000000000ff0000LL)<(r2&0x0000000000ff0000LL)?(r1&0x0000000000ff0000LL):(r2&0x0000000000ff0000LL))
             | ((r1&0x000000000000ff00LL)<(r2&0x000000000000ff00LL)?(r1&0x000000000000ff00LL):(r2&0x000000000000ff00LL))
             | ((r1&0x00000000000000ffLL)<(r2&0x00000000000000ffLL)?(r1&0x00000000000000ffLL):(r2&0x00000000000000ffLL));
    break;
  case OP_MAJ: /* (((x) & (y))^((x) & (z))^((y) & (z))) */
    ex1_outd = (r1&0xffffffff00000000LL) | (((r1 & r2)^(r1 & r3)^(r2 & r3))&0xffffffffLL);
    break;
  case OP_CH: /*  (((x) & (y))^(~(x) & (z))) */
    ex1_outd = (r1&0xffffffff00000000LL) | (((r1 & r2)^(~r1 & r3))&0xffffffffLL);
    break;
  default:
    printf("emax6lib: exe: undefined op_ex1=%d\n", op_ex1);
    break;
  }

  switch (op_ex2) {
  case OP_NOP:
    if (op_ex1 == OP_SFMA)
      softu64(2, ex1_outd_sfma, &ex2_outd, NULL, r1, r2, r3, r4);
    else
      ex2_outd = ex1_outd;
    break;
  case OP_AND: /* 64bit 2in logical and s1&s2 */
    ex2_outd = ex1_outd & r4;
    break;
  case OP_OR: /* 64bit 2in logical or s1|s2 */
    ex2_outd = ex1_outd | r4;
    break;
  case OP_XOR: /* 64bit 2in logical xor s1^s2 */
    ex2_outd = ex1_outd ^ r4;
    break;
  case OP_SUMHH: /* 16bit*4 1in & s1.h3+s1.h2->d.h3, s1.h1+s1.h0->d.h1 */
    t3 = ex1_outd>>48&0x000000000000ffffLL;
    t2 = ex1_outd>>32&0x000000000000ffffLL;
    t1 = ex1_outd>>16&0x000000000000ffffLL;
    t0 = ex1_outd    &0x000000000000ffffLL;
    t3 += t2;
    if (t3 > 0x000000000000ffffLL) t3 = 0x000000000000ffffLL;
    t1 += t0;
    if (t1 > 0x000000000000ffffLL) t1 = 0x000000000000ffffLL;
    ex2_outd = (t3<<48)|(t1<<16);
    break;
  case OP_SUMHL: /* 16bit*4 1in & s1.h3+s1.h2->d.h2, s1.h1+s1.h0->d.h0 */
    t3 = ex1_outd>>48&0x000000000000ffffLL;
    t2 = ex1_outd>>32&0x000000000000ffffLL;
    t1 = ex1_outd>>16&0x000000000000ffffLL;
    t0 = ex1_outd    &0x000000000000ffffLL;
    t2 += t3;
    if (t2 > 0x000000000000ffffLL) t2 = 0x000000000000ffffLL;
    t0 += t1;
    if (t0 > 0x000000000000ffffLL) t0 = 0x000000000000ffffLL;
    ex2_outd = (t2<<32)|(t0);
    break;
//case OP_WSWAP: /* 32bit 2in swap and mask words */
//  ex2_outd = ((ex1_outd<<32)|(ex1_outd>>32)) & r4;
//  break;
  case OP_ROTS: /* hi-32bit #define ROTRIGHT (((a) >> (b)) | ((a) << (32-(b)))) */
    t2 = ex1_outd & 0xffffffff00000000LL;
    ro10 = r4>>32 & 0xff;
    ro11 = r4>>40 & 0xff;
    ro12 = r4>>48 & 0xff;
    t0 = ex1_outd & 0x00000000ffffffffLL;
    ro00 = r4     & 0xff;
    ro01 = r4>> 8 & 0xff;
    ro02 = r4>>16 & 0xff;
    ex2_outd = (((t2>>ro12|t2<<(32-ro12))^(t2>>ro11|t2<<(32-ro11))^(t2>>ro10|t2<<(32-ro10)))&0xffffffff00000000LL)
              |(((t0>>ro02|t0<<(32-ro02))^(t0>>ro01|t0<<(32-ro01))^(t0>>ro00|t0<<(32-ro00)))&0x00000000ffffffffLL);
    break;
  default:
    printf("emax6lib: exe: undefined op_ex2=%d\n", op_ex2);
    break;
  }

  switch (op_ex3) {
  case OP_NOP:
    if (op_ex1 == OP_SFMA)
      softu64(3, NULL, &ex2_outd, d, r1, r2, r3, r4);
    else
      if (d) *d = ex2_outd;
    break;
  case OP_SLL: /* 32bit*2 2in 32bit logical shift to left */
    t1 = (Ull)(ex2_outd    &0xffffffff00000000LL)<<r5;
    t0 = (Ull)(ex2_outd<<r5&0x00000000ffffffffLL);
    if (d) *d = t1 | t0;
    break;
  case OP_SRL: /* 32bit*2 2in 32bit logical shift to right */
    t1 = (Ull)(ex2_outd>>r5&0xffffffff00000000LL);
    t0 = (Ull)(ex2_outd    &0x00000000ffffffffLL)>>r5;
    if (d) *d = t1 | t0;
    break;
  case OP_SRAA: /* 32bit*2 2in 32bit arith shift to right (bit63,31 is ext.) */
    t1 = (Sll)(ex2_outd    )>>r5&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<32)>>r5&0xffffffff00000000LL;
    if (d) *d = t1 | (t0>>32);
    break;
  case OP_SRAB: /* 32bit*2 2in 32bit arith shift to right (bit55,23 is ext.) */
    t1 = (Sll)(ex2_outd<< 8)>>(r5+8)&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<40)>>(r5+8)&0xffffffff00000000LL;
    if (d) *d = t1 | (t0>>32);
    break;
//case OP_SRAC: /* 32bit*2 2in 32bit arith shift to right (bit47,15 is ext.) */
//  t1 = (Sll)(ex2_outd<<16)>>(r5+16)&0xffffffff00000000LL;
//  t0 = (Sll)(ex2_outd<<48)>>(r5+16)&0xffffffff00000000LL;
//  if (d) *d = t1 | (t0>>32);
//  break;
//case OP_SRAD: /* 32bit*2 2in 32bit arith shift to right (bit39,7 is ext.) */
//  t1 = (Sll)(ex2_outd<<24)>>(r5+24)&0xffffffff00000000LL;
//  t0 = (Sll)(ex2_outd<<56)>>(r5+24)&0xffffffff00000000LL;
//  if (d) *d = t1 | (t0>>32);
//  break;
  case OP_SRLM: /* 16bit*4 2in 16bit arith shift to right */
    t3 = (Ull)(ex2_outd    )>>r5&0xffff000000000000LL;
    t2 = (Ull)(ex2_outd<<16)>>r5&0xffff000000000000LL;
    t1 = (Ull)(ex2_outd<<32)>>r5&0xffff000000000000LL;
    t0 = (Ull)(ex2_outd<<48)>>r5&0xffff000000000000LL;
    if (d) *d = t3 | (t2>>16) | (t1>>32) | (t0>>48);
    break;
  default:
    printf("emax6lib: exe: undefined op_ex3=%d\n", op_ex3);
    break;
  }

  return (retval);
}

void /*__attribute__((always_inline))*/
mex(Uint op_mex2, Uchar **d2, Uchar *base2, Ull ofs2, Uint op_mex1, Uchar **d1, Uchar *base1, Ull ofs1, Ull limit, Ull s2, Ull s1)
{
  /* limit:  0, 8, 16, .... 4096, 8192, 16384, 32768     */
  /* encode: 0, 1, 2,  3,   10    11    12     13 (4bit) */
  Uint limit2 = limit*2;
  Uint ss2 = s2>>32;
  Uint ss1 = s1>>32;

  switch (op_mex1) {
  case OP_NOP:
    *d1 = base1;
    break;
  case OP_ALWAYS: /* base++ 対応 */
    *d1 = base1 + ofs1;
    break;
  case OP_CMPA_GE:
    //d1自分(ss1)がffffffffなら停止. base1==limit2なら停止. base2==limit なら前進
    if (!limit) /* sparse matrix */
      *d1 = base1 + ((ss1!=0xffffffff && ss2>=ss1) ? ofs1:0);
    else { /* merge sort */
      if ((base2==limit && base1+ofs1==limit2)||(base2+ofs2==limit && base1==limit2))
	*d1 = limit;
      else
	*d1 = base1 + (base1!=limit2 && ((base2!=limit  && ss2>=ss1)||base2==limit ) ? ofs1:0);
    }
    break;
  default:
    printf("emax6lib: mex: undefined op_mex1=%d\n", op_mex1);
    break;
  }  

  switch (op_mex2) {
  case OP_NOP:
    *d2 = base2;
    break;
  case OP_ALWAYS: /* base++ 対応 */
    *d2 = base2 + ofs2;
    break;
  case OP_CMPA_LE:
    //d2自分(ss2)がffffffffなら停止. base2==limit なら停止. base1==limit2なら前進
    if (!limit) /* sparse matrix */
      *d2 = base2 + ((ss2!=0xffffffff && ss2<=ss1) ? ofs2:0);
    else { /* merge sort */
      if ((base2==limit && base1+ofs1==limit2)||(base2+ofs2==limit && base1==limit2))
	*d2 = 0;
      else
	*d2 = base2 + (base2!=limit  && ((base1!=limit2 && ss2<=ss1)||base1==limit2) ? ofs2:0);
    }
    break;
  default:
    printf("emax6lib: mex: undefined op_mex2=%d\n", op_mex2);
    break;
  }  
}

Ull __attribute__((always_inline))
eam(Ull ofs, Uchar msk)
{
  switch (msk) {
  case  MSK_D0: return (ofs);
  case  MSK_W1: return (ofs>>32);
  case  MSK_W0: return (ofs&0x00000000ffffffffLL);
  case  MSK_H3: return (ofs>>48&0x000000000000ffffLL);
  case  MSK_H2: return (ofs>>32&0x000000000000ffffLL);
  case  MSK_H1: return (ofs>>16&0x000000000000ffffLL);
  case  MSK_H0: return (ofs&0x000000000000ffffLL);
  case  MSK_B7: return (ofs>>56&0x00000000000000ffLL);
  case  MSK_B6: return (ofs>>48&0x00000000000000ffLL);
  case  MSK_B5: return (ofs>>40&0x00000000000000ffLL);
  case  MSK_B4: return (ofs>>32&0x00000000000000ffLL);
  case  MSK_B3: return (ofs>>24&0x00000000000000ffLL);
  case  MSK_B2: return (ofs>>16&0x00000000000000ffLL);
  case  MSK_B1: return (ofs>>8&0x00000000000000ffLL);
  case  MSK_B0: return (ofs&0x00000000000000ffLL);
  default: printf("emax6lib: eag: undefined msk=%d\n", msk); return (0LL);;
  }
}

void /*__attribute__((always_inline))*/
eag(Ull *adr, Ull base, Ull ofs)
{
  *adr = base + ofs;
}

void /*__attribute__((always_inline))*/
mop(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint len, Uint blk, Uchar force, Ull ptop, Uint plen)
{
  Ull adr, ofs;

  eag(&adr, base, eam(offset, msk));
  mmp(op_mm, ex, d, adr, top, len, blk);
}

void /*__attribute__((always_inline))*/
mo4(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint len, Uint blk, Uchar force, Ull ptop, Uint plen)
{
  Ull adr, ofs;

  eag(&adr, base, eam(offset, msk));
  mmp(op_mm, ex, d, adr, top, len, blk);
}

int emax6_unaligned_load_valid; /* mop(BR[][][1]adr+8); mop(BR[][][0]adr);連続指定を想定し,1の場合highが有効,0の場合無効  */
Ull emax6_unaligned_load_high;  /* mop(BR[][][1]adr+8); mop(BR[][][0]adr);連続指定を想定し,high側を一次保存しlow側にmerge */

void /*__attribute__((always_inline))*/
mmp(Uint op_mm, Ull ex, Ull *d, Ull adr, Ull top, Uint len, Uint blk)
{
  Ull c1, c0, load64;

#if defined(__i386)
  adr &= (1LL<<32)-1;
  top &= (1LL<<32)-1;
#endif  

  if (!((op_mm==OP_LDRQ && blk) || op_mm==OP_LDDMQ || op_mm==OP_TR) && (!adr || !top)) return; /* NULL skip DMA */

#define CHECK_MMP_MARGIN 12
  if (!((op_mm==OP_LDRQ && blk) || op_mm==OP_LDDMQ || op_mm==OP_TR) && ex && len && (adr < top || adr >= top+len*sizeof(Uint)+CHECK_MMP_MARGIN)) {
    printf("mmp: adr=%08.8x_%08.8x out of range (top=%08.8x_%08.8x len=%dB)\n", (Uint)(adr>>32), (Uint)adr, (Uint)(top>>32), (Uint)top, len*sizeof(Uint));
    fflush(stdout);
  }

  c1 = ex>>1&1;
  c0 = ex   &1;

  switch (op_mm) {
  case OP_NOP:
    break;

    /* MOP */
  case OP_LDR: /* 64bit lmm LMM is preloaded, random-access */
    load64 = *(Ull*)(adr&~7LL);
    if ((adr&7) == 0)
      *d = load64;
    else if (!emax6_unaligned_load_valid) { /* BR[][][1] */
      emax6_unaligned_load_valid = 1;
      emax6_unaligned_load_high = load64;
      *d = load64 >> (adr&7)*8;
    }
    else { /* BR[][][0] */
      emax6_unaligned_load_valid = 0; 
      *d = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;
    }
    break;
  case OP_LDWR: /* u32bit lmm LMM is preloaded, random-access */
    *d = (Ull)*(Uint*)(adr&~3LL);
    break;
//case OP_LDHR: /* u16bit lmm LMM is preloaded, random-access */
//  *d = (Ull)(Uint)*(Ushort*)(adr&~1LL);
//  break;
  case OP_LDBR: /* u8bit lmm LMM is preloaded, random-access */
    *d = (Ull)(Uint)*(Uchar*)adr;
    break;
  case OP_STR: /* 64bit lmm LMM is drained. random-access */
    if (c1) *((Uint*)(adr&~7LL)+1) = *d>>32;
    if (c0) *((Uint*)(adr&~7LL)  ) = *d;
    break;
  case OP_STWR: /* 32bit lmm LMM is drained. random-access */
    if (c0) *(Uint*)(adr&~3LL) = *d;
    break;
//case OP_STHR: /* 16bit lmm LMM is drained. random-access */
//  if (c0) *(Ushort*)(adr&~1LL) = *d;
//  break;
  case OP_STBR: /* 8bit lmm LMM is drained. random-access */
    if (c0) *(Uchar*)adr = *d;
    break;

    /* MO4 */
  case OP_LDRQ: /* 64bit*4 lmm LMM is preloaded, random-access */
    switch (blk) {
    case 0: /* normal */
      /* adr=0,32,64,... */
      *(d+0) = *((Ull*)(adr&~31LL)+0);
      *(d+1) = *((Ull*)(adr&~31LL)+1);
      *(d+2) = *((Ull*)(adr&~31LL)+2);
      *(d+3) = *((Ull*)(adr&~31LL)+3);
      break;
    case 1: /* block_size=16-members */
      /* adr=0,32,64,... memadr = mem(top + (adr/32/16*ptr)) + (adr/32/&15)*4 */
      *(d+0) = *(*(Ull**)(top + (adr/32/16*sizeof(Ull*))) + (adr/32&15)*4 + 0);
      *(d+1) = *(*(Ull**)(top + (adr/32/16*sizeof(Ull*))) + (adr/32&15)*4 + 1);
      *(d+2) = *(*(Ull**)(top + (adr/32/16*sizeof(Ull*))) + (adr/32&15)*4 + 2);
      *(d+3) = *(*(Ull**)(top + (adr/32/16*sizeof(Ull*))) + (adr/32&15)*4 + 3);
      break;
    case 2: /* block_size=32-members */
      /* adr=0,32,64,... memadr = mem(top + (adr/32/32*ptr)) + (adr/32/&31)*4 */
      *(d+0) = *(*(Ull**)(top + (adr/32/32*sizeof(Ull*))) + (adr/32&31)*4 + 0);
      *(d+1) = *(*(Ull**)(top + (adr/32/32*sizeof(Ull*))) + (adr/32&31)*4 + 1);
      *(d+2) = *(*(Ull**)(top + (adr/32/32*sizeof(Ull*))) + (adr/32&31)*4 + 2);
      *(d+3) = *(*(Ull**)(top + (adr/32/32*sizeof(Ull*))) + (adr/32&31)*4 + 3);
      break;
    default:/* block_size=64-members */
      /* adr=0,32,64,... memadr = mem(top + (adr/32/64*ptr)) + (adr/32/&63)*4 */
      *(d+0) = *(*(Ull**)(top + (adr/32/64*sizeof(Ull*))) + (adr/32&63)*4 + 0);
      *(d+1) = *(*(Ull**)(top + (adr/32/64*sizeof(Ull*))) + (adr/32&63)*4 + 1);
      *(d+2) = *(*(Ull**)(top + (adr/32/64*sizeof(Ull*))) + (adr/32&63)*4 + 2);
      *(d+3) = *(*(Ull**)(top + (adr/32/64*sizeof(Ull*))) + (adr/32&63)*4 + 3);
      break;
    }
    break;
  case OP_LDDMQ: /* 64bit*4 mem Direct access to MM */
    if (c0) {
      *(d+0) = *((Ull*)(adr&~31LL)+0);
      *(d+1) = *((Ull*)(adr&~31LL)+1);
      *(d+2) = *((Ull*)(adr&~31LL)+2);
      *(d+3) = *((Ull*)(adr&~31LL)+3);
    }
    break;
  case OP_STRQ: /* 64bit*4 lmm LMM is drained. random-access */
    *((Ull*)(adr&~31LL)+0) = *(d+0);
    *((Ull*)(adr&~31LL)+1) = *(d+1);
    *((Ull*)(adr&~31LL)+2) = *(d+2);
    *((Ull*)(adr&~31LL)+3) = *(d+3);
    break;
  case OP_TR: /* 64bit*4 exec Send transaction */
    /* addrをtransaction()指定に使用 */
    if (c0) {
      Ull (*trans)() = top;
      (trans)(*(d+0), *(d+1), *(d+2), *(d+3));
    }
    break;
  default:
    printf("emax6lib: mmp: undefined op_mm=%d\n", op_mm);
    break;
  }
}
#endif
@


1.189
log
@*** empty log message ***
@
text
@d1660 1
a1660 1
mex(Uint op_mex2, Uchar **d2, Uchar *base2, Uint op_mex1, Uchar **d1, Uchar *base1, Ull limit, Ull ofs, Ull s2, Ull s1)
d1673 1
a1673 1
    *d1 = base1 + ofs;
d1678 1
a1678 1
      *d1 = base1 + ((ss1!=0xffffffff && ss2>=ss1) ? ofs:0);
d1680 1
a1680 1
      if ((base2==limit && base1+ofs==limit2)||(base2+ofs==limit && base1==limit2))
d1683 1
a1683 1
	*d1 = base1 + (base1!=limit2 && ((base2!=limit  && ss2>=ss1)||base2==limit ) ? ofs:0);
d1696 1
a1696 1
    *d2 = base2 + ofs;
d1701 1
a1701 1
      *d2 = base2 + ((ss2!=0xffffffff && ss2<=ss1) ? ofs:0);
d1703 1
a1703 1
      if ((base2==limit && base1+ofs==limit2)||(base2+ofs==limit && base1==limit2))
d1706 1
a1706 1
	*d2 = base2 + (base2!=limit  && ((base1!=limit2 && ss2<=ss1)||base1==limit2) ? ofs:0);
@


1.188
log
@*** empty log message ***
@
text
@d1660 1
a1660 1
mex(Uint op_mx, Uchar **d2, Uchar *base2, Uchar **d1, Uchar *base1, Ull limit, Ull ofs, Ull s2, Ull s1)
d1668 1
a1668 1
  switch (op_mx) {
a1669 1
    *d2 = base2;
a1672 1
    *d2 = base2 + ofs;
d1675 1
a1675 2
  case OP_CMPA_LEGE:
    //d2自分(ss2)がffffffffなら停止. base2==limit なら停止. base1==limit2なら前進
d1677 1
a1677 2
    if (!limit) { /* sparse matrix */
      *d2 = base2 + ((ss2!=0xffffffff && ss2<=ss1) ? ofs:0);
d1679 5
d1685 17
d1703 1
a1703 1
      if ((base2==limit && base1+ofs==limit2)||(base2+ofs==limit && base1==limit2)) {
d1705 1
a1705 3
	*d1 = limit;
      }
      else {
a1706 2
	*d1 = base1 + (base1!=limit2 && ((base2!=limit  && ss2>=ss1)||base2==limit ) ? ofs:0);
      }
d1710 1
a1710 1
    printf("emax6lib: mex: undefined op_mx=%d\n", op_mx);
@


1.187
log
@*** empty log message ***
@
text
@d1690 2
a1691 2
	*d2 = base2 + (base2!=limit   && ((base1!=limit2 && ss2<=ss1)||base1==limit2) ? ofs:0);
	*d1 = base1 + (base1!=limit*2 && ((base2!=limit  && ss2>=ss1)||base2==limit ) ? ofs:0);
@


1.186
log
@*** empty log message ***
@
text
@d1664 1
d1678 2
a1679 2
    //d2自分(ss2)がffffffffなら停止. base2==limitなら停止. base1==limitなら前進
    //d1自分(ss1)がffffffffなら停止. base1==limitなら停止. base2==limitなら前進
d1685 1
a1685 1
      if ((base2==limit && base1+ofs==limit)||(base2+ofs==limit && base1==limit)) {
d1687 1
a1687 1
	*d1 = 0;
d1690 2
a1691 2
	*d2 = base2 + (base2!=limit && ((base1!=limit && ss2<=ss1)||base1==limit) ? ofs:0);
	*d1 = base1 + (base1!=limit && ((base2!=limit && ss2>=ss1)||base2==limit) ? ofs:0);
@


1.185
log
@*** empty log message ***
@
text
@d1660 1
a1660 1
mex(Uint op_mx, Uchar **d, Uchar *base, Ull ofs, Ull s2, Ull s1)
d1662 2
d1669 2
a1670 1
    *d = base;
d1673 2
a1674 1
    *d = base + ofs;
d1676 17
a1692 5
  case OP_CMPA_LE:
    *d = base + ((ss1!=0xffffffff && ss2<=ss1) ? ofs:0); /* sparse matrix */
    break;
  case OP_CMPA_GE:
    *d = base + ((ss2!=0xffffffff && ss2>=ss1) ? ofs:0); /* sparse matrix */
@


1.184
log
@*** empty log message ***
@
text
@d1747 1
a1747 1
  if (!((op_mm==OP_LDRQ && blk) || op_mm==OP_LDDMQ || op_mm==OP_TR) && len && (adr < top || adr >= top+len*sizeof(Uint)+CHECK_MMP_MARGIN)) {
@


1.183
log
@*** empty log message ***
@
text
@d1744 1
a1744 1
  if (!((op_mm==OP_LDRQ && blk) || op_mm==OP_LDDMQ || op_mm==OP_TR) && !adr) return; /* NULL skip DMA */
d1747 1
a1747 1
  if (!((op_mm==OP_LDRQ && blk) || op_mm==OP_LDDMQ || op_mm==OP_TR) && top && (adr < top || adr >= top+len*sizeof(Uint)+CHECK_MMP_MARGIN)) {
@


1.182
log
@*** empty log message ***
@
text
@d1744 1
a1744 1
  if (!((op_mm==OP_LDRQ && blk) || op_mm==OP_LDDMQ || op_mm==OP_TR) && (!adr || !top)) return; /* NULL skip DMA */
d1747 1
a1747 1
  if (!((op_mm==OP_LDRQ && blk) || op_mm==OP_LDDMQ || op_mm==OP_TR) && (adr < top || adr >= top+len*sizeof(Uint)+CHECK_MMP_MARGIN)) {
@


1.181
log
@*** empty log message ***
@
text
@d603 1
a603 1
         || (lmmc_stat== 9 && !lmmc_ofsz && !lmm_readz)                                                                                                                              /* ●7 lmp & !readz */
d609 3
a611 3
    if      (lmmc_stat== 9                    ) { mark=1;                                                          dmadr=lmmicp->top+(Sll)(int)lmmicp->ofs;dmlen=lmmicp->len;dmrw=0;}/* ●5 lmp */
    else if (lmmc_stat==12 || lmmc_stat==14   ) { mark=0;emax6.lmmd[i][j]|=(1<<c);                                                                                                  }/* ●6 lmw/lmx */
    else if (lmmc_stat==13                    ) { mark=  emax6.lmmd[m][j]& (1<<c); emax6.lmmd[m][j]|=((!lastdist)<<c);dmadr=lmmicp->top;dmlen=lmmicp->len;dmrw=1;                   }/* ●6 lmd & dirty */
d613 2
a614 2
//  else if (lmmc_stat==11                    ) { mark=1;                             } /*     LDDMQ */
//  else if (lmmc_stat==15                    ) { mark=1;                             } /*     TR */
d616 1
a616 1
    else                                        { mark=0;                             } /* skip pdrain/pload */
@


1.180
log
@*** empty log message ***
@
text
@d609 1
a609 1
    if      (lmmc_stat== 9                    ) { mark=1;                                                             dmadr=lmmicp->top;dmlen=lmmicp->len;dmrw=0;                   }/* ●5 lmp */
@


1.179
log
@*** empty log message ***
@
text
@d1181 1
d1538 2
a1539 2
  case OP_MAJ: /* (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z))) */
    ex1_outd = r1<<32 | (((r1 & r2) ^ (r1 & r3) ^ (r2 & r3))&0xffffffffLL);
d1541 2
a1542 2
  case OP_CH: /*  (((x) & (y)) ^ (~(x) & (z))) */
    ex1_outd = r1<<32 | (((r1 & r2) ^ (~r1 & r3))&0xffffffffLL);
d1591 10
a1600 6
    t0 = ex1_outd >> 32;
    t1 = r4     & 0xff;
    t2 = r4>> 8 & 0xff;
    t3 = r4>>16 & 0xff;
    ex2_outd = ((t0>>t3|(t0<<(32-t3))) ^ (t0>>t2|(t0<<(32-t2))) ^ (t0>>t1|(t0<<(32-t1))))<<32
              |(ex1_outd & 0xffffffffLL);
@


1.178
log
@*** empty log message ***
@
text
@d1537 6
d1589 8
@


1.177
log
@*** empty log message ***
@
text
@d726 18
a743 17
  /* kick dma_ctrl (Simple Mode) */
  /* 1. ZDMA_CH_STATUS レジスタを読み出し、STATEが00または11(DMAがIDLEステート) になるまで待つ. */
  /*    DMAがPAUSEステートの場合、「チャネル一時停止」で説明する手順に従って PAUSE ステートを終了. */

  // 最後に移動
       
  /* 2. ZDMA_CH_CTRL0レジスタの POINT_TYPE (ビット 6) を 0 に設定 */
  /*    データソースバッファのアドレスの LSB を ZDMA_CH_SRC_DSCR_WORD0レジスタに書き込む */
  /*    データソースバッファのアドレスの MSB を ZDMA_CH_SRC_DSCR_WORD1レジスタに書き込む */
  /* 3. データデスティネーションバッファのアドレスの LSB を ZDMA_CH_DST_DSCR_WORD0レジスタに書き込む */
  /*    データデスティネーションバッファのアドレスの MSB を ZDMA_CH_DST_DSCR_WORD1レジスタに書き込む */
  /* 4. Simple Modeでは、SRCトランザクションサイズとDSTトランザクションサイズの両方を設定する必要がある */
  /*    DMA は SRCトランザクションサイズを使用しますが、両方のレジスタを設定しておく必要がある */
  /*    ZDMA_CH_SRC_DSCR_WORD2 レジスタにソースデータサイズを書き込む */
  /*    ZDMA_CH_DST_DSCR_WORD2 レジスタにデスティネーショントランザクションサイズを書き込む */
  /*    SRCトランザクションサイズとDSTトランザクションサイズは必ず同じ */
  if (emax6.dmalen > 0) {
d775 7
a781 7
  /* 5. 必要に応じ,ZDMA_CH_DST_DSCR_WORD3およびZDMA_CH_SRC_DSCR_WORD3レジスタでINTRを1にセットし割り込みを有効にする */
  /* 6. ソースおよびデスティネーションバッファがキャッシュコヒーレントとして割り当てられているかフラッシュされている場合, */
  /*    COHRNTをセットする必要はない. それ以外の場合,ソースおよびデスティネーションバッファがキャッシュコヒーレントとして */
  /*    割り当てられていない、またはフラッシュされていない場合、ZDMA_CH_SRC_DSCR_WORD3およびZDMA_CH_DST_DSCR_WORD3レジスタで */
  /*    それぞれ COHRNTをセットする. COHRNTビットは LPD-DMA の場合のみ有効. FPD-DMAはコヒーレンシをサポートしない. */
  /* 7. ZDMA_CH_CTRL2レジスタのENビットをセットして,DMA転送に使用するDMAチャネルを有効にする. */
  /*    DMAを有効にした後、「エラー条件」に示すエラー条件をチェックする. */
d791 1
d795 5
a803 8
    }    
    *(Uint*)dst = *(Uint*)src;
  }
#else
  /*printf("emax_info.lmm_mmap-emax_info.ddr_mmap=%08.8x_%08.8x\n", (Uint)((emax_info.lmm_mmap-emax_info.ddr_mmap)>>32), (Uint)(emax_info.lmm_mmap-emax_info.ddr_mmap));*/
  if (emax6.rw == 0) { /* mem->lmm */
    dst = emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_mmap;
    src = emax6.ddraddr;
d805 3
a807 3
    printf("emax6.lmmaddr:%08.8x_%08.8x <- emax6.ddraddr:%08.8x_%08.8x\n",
           (Uint)((Ull)((Ull*)emax6.lmmaddr)>>32), (Uint)(Ull)((Ull*)emax6.lmmaddr),
           (Uint)((Ull)((Ull*)emax6.ddraddr)>>32), (Uint)(Ull)((Ull*)emax6.ddraddr));
d809 27
a835 20
  }
  else { /* lmm->mem */
    dst = emax6.ddraddr;
    src = emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_mmap;
#if 0
    printf("emax6.lmmaddr:%08.8x_%08.8x -> emax6.ddraddr:%08.8x_%08.8x\n",
           (Uint)((Ull)((Ull*)emax6.lmmaddr)>>32), (Uint)(Ull)((Ull*)emax6.lmmaddr),
           (Uint)((Ull)((Ull*)emax6.ddraddr)>>32), (Uint)(Ull)((Ull*)emax6.ddraddr));
#endif
  }
  /* srcとdstは32Bアラインされており,片側のみ非アラインになることはない */
  pio_words = emax6.dmalen+1;
  if (src & (sizeof(Ull)-1) & sizeof(Uint)) { /* 4B-access 0,4 */
    *(Uint*)dst = *(Uint*)src;
    src += sizeof(Uint);
    dst += sizeof(Uint);
    pio_words--;
  }
  if (pio_words >= 2) {
    if (src & (sizeof(Dll)-1) & sizeof(Ull)) { /* 8B-access 0,4 */
d841 5
a845 8
  }
  if (pio_words >= 4) {
    if (pio_loop = pio_words/(sizeof(Dll)/sizeof(Uint))) {
      for(pio_i=0; pio_i<pio_loop; pio_i++)
	*((Dll*)dst + pio_i) = *((Dll*)src + pio_i);
      pio_words -= pio_loop*(sizeof(Dll)/sizeof(Uint));
      src += pio_loop*sizeof(Dll);
      dst += pio_loop*sizeof(Dll);
a847 13
  if (pio_words >= 2) { /* 8B-access */
    *(Ull*)dst = *(Ull*)src;
    src += sizeof(Ull);
    dst += sizeof(Ull);
    pio_words-=2;
  }
  if (pio_words >= 1) { /* 4B-access */
    *(Uint*)dst = *(Uint*)src;
    src += sizeof(Uint);
    dst += sizeof(Uint);
    pio_words--;
  }
#endif
@


1.176
log
@*** empty log message ***
@
text
@a743 3
      do {
	status = ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_STATUS & 3;
      } while (status != 0 && status != 3);
d760 1
a760 3
      do {
	status = ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_STATUS & 3;
      } while (status != 0 && status != 3);
@


1.175
log
@*** empty log message ***
@
text
@d626 1
a626 1
//printf("drain: adr=%08.8x len=%08.8x nxt=%08.8x\n", (Uint)dmaadr, (Uint)dmalen, (Uint)dmnxt);
@


1.174
log
@*** empty log message ***
@
text
@d705 1
a705 1
printf("        rw=0x%x ddraddr=%08.8x lmmaddr=%08.8x dmalen=0x%x", emax6.rw, (Uint)emax6.ddraddr, (Uint)emax6.lmmaddr, (Uint)emax6.dmalen);
@


1.173
log
@*** empty log message ***
@
text
@d705 1
a705 1
printf("        rw=%d ddraddr=%08.8x lmmaddr=%08.8x dmalen=%d", emax6.rw, (Uint)emax6.ddraddr, (Uint)emax6.lmmaddr, (Uint)emax6.dmalen);
d810 5
a814 3
    /*printf("(emax6.lmmaddr+pio_loop):%08.8x_%08.8x <- (emax6.ddraddr + pio_loop):%08.8x_%08.8x\n",
           (Uint)((Ull)((Ull*)emax6.lmmaddr + pio_loop)>>32), (Uint)(Ull)((Ull*)emax6.lmmaddr + pio_loop),
           (Uint)((Ull)((Ull*)emax6.ddraddr + pio_loop)>>32), (Uint)(Ull)((Ull*)emax6.ddraddr + pio_loop));*/
d819 5
a823 3
    /*printf("(emax6.lmmaddr+pio_loop):%08.8x_%08.8x -> (emax6.ddraddr + pio_loop):%08.8x_%08.8x\n",
           (Uint)((Ull)((Ull*)emax6.lmmaddr + pio_loop)>>32), (Uint)(Ull)((Ull*)emax6.lmmaddr + pio_loop),
           (Uint)((Ull)((Ull*)emax6.ddraddr + pio_loop)>>32), (Uint)(Ull)((Ull*)emax6.ddraddr + pio_loop));*/
@


1.172
log
@*** empty log message ***
@
text
@d359 1
a359 1
  char *UIO_AXI_BRAM_CTRL = "axi_bram_ctrl\n";
d368 2
d400 1
a400 1
    else if (is_target_dev(namelist[dir]->d_name, UIO_AXI_BRAM_CTRL)) {
d404 1
a404 1
	printf("open failed. %s", UIO_AXI_BRAM_CTRL);
d407 1
a407 1
      printf("%s: %s", path, UIO_AXI_BRAM_CTRL);
@


1.171
log
@*** empty log message ***
@
text
@d278 1
d372 1
a378 1
      printf("%s: %s", path, UIO_DMA);
d387 1
d392 1
a392 1
	printf("fd_reg mmap() failed.\n");
a396 1
      printf("%s: %s", path, UIO_AXI_CHIP2CHIP);
d405 1
d410 1
a410 1
	printf("fd_reg mmap() failed.\n");
a414 1
      printf("%s: %s", path, UIO_AXI_BRAM_CTRL);
d423 1
d428 1
a428 1
	printf("fd_ddr mmap() failed.\n");
a430 1
      printf("%s: %s", path, UIO_DDR_HIGH);
@


1.170
log
@*** empty log message ***
@
text
@d358 1
d397 18
@


1.169
log
@*** empty log message ***
@
text
@d312 1
a312 1
static int is_dma_dev(char *d_name)
d324 1
a324 1
  if (strcmp(name, "dma\n") != 0) return 0;
d356 3
a358 27

  if ((fd_reg = open("/dev/uio8", O_RDWR | O_SYNC)) == -1) {
    printf("open(\"/dev/uio8\", ...) failed.\n");
    return (NULL);
  }
  if ((fd_ddr = open("/dev/uio9", O_RDWR | O_SYNC)) == -1) {
    printf("open(\"/dev/uio9\", ...) failed.\n");
    return (NULL);
  }

  // mmap(cache-off) 4KB aligned
  emax_info.reg_phys = REG_BASE_PHYS;
  emax_info.reg_mmap = (Ull)mmap(NULL, REG_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd_reg, 0); /* 4GB */
  if (emax_info.reg_mmap == MAP_FAILED) {
    printf("fd_reg mmap() failed.\n");
    return (NULL);
  }
  emax_info.lmm_phys = LMM_BASE_PHYS;
  emax_info.lmm_mmap = emax_info.reg_mmap + (LMM_BASE_PHYS - REG_BASE_PHYS);

  // mmap(cache-on)  4KB aligned
  emax_info.ddr_phys = DDR_BASE_PHYS;
  emax_info.ddr_mmap = (Ull)mmap(NULL, DDR_MMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd_ddr, 0); /* 2GB */
  if (emax_info.ddr_mmap == MAP_FAILED) {
    printf("fd_ddr mmap() failed.\n");
    return (NULL);
  }
d365 15
a379 1
    if (!is_dma_dev(namelist[dir]->d_name)) {
d381 30
a410 1
      continue;
d412 1
a412 1
    if ((reg_size = get_reg_size(namelist[dir]->d_name)) == 0) {
a415 12

    sprintf(path, "/dev/%s", namelist[dir]->d_name);
    free(namelist[dir]);
    if ((fd_dma = open(path, O_RDWR | O_SYNC)) == -1)
      continue;
    emax_info.dma_phys = DMA_BASE_PHYS;
    emax_info.dma_mmap = (Ull)mmap(NULL, reg_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd_dma, 0);
    close(fd_dma);
    if (emax_info.dma_mmap == MAP_FAILED)
      continue;
    fd_dma_found++;
    break;
@


1.168
log
@*** empty log message ***
@
text
@d153 1
a153 1
    Ull  stat; /* +0000 bit7-4:LMRING, bit3-0:EXRING */
@


1.167
log
@*** empty log message ***
@
text
@d199 1
a199 1
  struct lmmi lmmi[EMAX_NCHIP][EMAX_DEPTH][EMAX_WIDTH][2]; /* lmmi for host (len/ofs/top are resolved) */
d201 1
a201 1
  Uchar lmmd[EMAX_DEPTH][EMAX_WIDTH]; /* chip#7,6,..,0:clean, 1:dirty, exec後store箇所に1, drain直後0 */
@


1.166
log
@*** empty log message ***
@
text
@d1632 3
a1640 3
  case OP_ALWAYS: /* base++ 対応 */
    *d = base + ofs;
    break;
@


1.165
log
@*** empty log message ***
@
text
@d551 2
a552 2
  static Ull concat_adr; /* NULL:invalid, !NULL:top_addr */
  static int concat_len; /* byte-len */
d599 3
a601 3
	if (!concat_adr) { concat_adr = dmadr; concat_len = dmlen; }
	else             { concat_len += dmlen+1; }
	if (concat_len < 8192) mark = 0;
d604 1
a604 1
	if (concat_adr)  { concat_len += dmlen+1; }
d610 3
a612 3
	if (!concat_adr) { concat_adr = dmadr; concat_len = dmlen; }
	else             { concat_len += dmlen+1; }
	if (concat_len < 8192) mark = 0;
d615 1
a615 1
	if (concat_adr)  { concat_len += dmlen+1; }
d625 1
a625 1
      emax6.ddraddr = (concat_adr)?concat_adr:dmadr; /* address should be 4B-aligned */
d627 1
a627 1
      emax6.dmalen  = (concat_adr)?concat_len:dmlen; /* length should be # of words */
d638 1
a638 1
	  emax6.ddraddr = (concat_adr)?concat_adr:dmadr; /* address should be 4B-aligned */
d640 1
a640 1
	  emax6.dmalen  = (concat_adr)?concat_len:dmlen; /* length should be # of words */
d678 1
a678 1
    concat_adr = 0;
@


1.164
log
@*** empty log message ***
@
text
@d542 9
d555 7
a561 13
  if ((mode==0 && phase == 1) || phase == 2 || phase == 3) { /* (array && drain) || load || exec */
    lmmc_topz =  (emax6.lmmi[c][i][j][emax6.lmmic].top == 0);
    lmmc_ofsz =  (emax6.lmmi[c][i][j][emax6.lmmic].ofs == 0);
    lmmo_stat =  (emax6.lmmi[c][m][j][emax6.lmmio].v<<3)|(emax6.lmmi[c][m][j][emax6.lmmio].rw<<2)|(emax6.lmmi[c][m][j][emax6.lmmio].f<<1)|(emax6.lmmi[c][m][j][emax6.lmmio].p); /* v|rw|f|p */
    lmmc_stat = ((emax6.lmmi[c][i][j][emax6.lmmic].v & ~emax6.lmmi[c][i][j][emax6.lmmic].hcopy & ~emax6.lmmi[c][i][j][emax6.lmmic].vcopy & ((emax6.lmmi[c][i][j][emax6.lmmic].f&emax6.lmmi[c][i][j][emax6.lmmic].p) | !lmmc_topz))<<3)
                                                                                          /* v= ~copy & (OP_LDDMQ/OP_TR または ptop!=NULL) */
	        |(emax6.lmmi[c][i][j][emax6.lmmic].rw<<2)|(emax6.lmmi[c][i][j][emax6.lmmic].f<<1)|(emax6.lmmi[c][i][j][emax6.lmmic].p); /* v|rw|f|p */
    lmm_ready =  (emax6.lmmi[c][m][j][emax6.lmmio].v && emax6.lmmi[c][m][j][emax6.lmmio].blk == emax6.lmmi[c][i][j][emax6.lmmic].blk
		                                     && emax6.lmmi[c][m][j][emax6.lmmio].len == emax6.lmmi[c][i][j][emax6.lmmic].len
                                                     && emax6.lmmi[c][m][j][emax6.lmmio].top == emax6.lmmi[c][i][j][emax6.lmmic].top);
    lmm_readz =  (emax6.lmmi[c][m][j][emax6.lmmio].v && emax6.lmmi[c][m][j][emax6.lmmio].blk == emax6.lmmi[c][i][j][emax6.lmmic].blk
		                                     && emax6.lmmi[c][m][j][emax6.lmmio].len == emax6.lmmi[c][i][j][emax6.lmmic].len
		                                     &&(emax6.lmmi[c][m][j][emax6.lmmio].top+(Sll)(int)emax6.lmmi[c][m][j][emax6.lmmio].ofs) == emax6.lmmi[c][i][j][emax6.lmmic].top);
d566 5
a570 31
  if      (mode==0 && phase == 1) { /* drain */
    if      (lmmo_stat==12 && lmmc_stat!=13 && (emax6.lmmd[m][j]&1<<c)) { mark = 1; emax6.lmmd[m][j] &= ~(1<<c);} /* ●2 lmw&!lmd drain */
    else if (lmmo_stat==14 && !lmm_ready    && (emax6.lmmd[m][j]&1<<c)) { /* concat_adr=0        adr0,L=0        | adr1,L=0        | adr2,L=0        */
                                                                          /* concat_adr=adr0,L=0 adr0,L=0,mark=0 | adr1,L=0        | adr2,L=0        */
                                                                          /* concat_adr=adr0,L=1          mark=0 | adr1,L=0,mark=0 | adr2,L=0        */
                                                                          /* concat_adr=adr0,L=2          mark=0 |          mark=0 | adr2,L=0,mark=1 */
#if 1
//printf("lmx drain: adr=%08.8x len=%08.8x adr=%08.8x\n", (Uint)emax6.lmmi[c][m][j][emax6.lmmio].top, (Uint)emax6.lmmi[c][m][j][emax6.lmmio].len, (Uint)emax6.lmmi[c][(m+1)%EMAX_DEPTH][j][emax6.lmmio].top);
                                                                          if ((emax6.lmmd[(m+1)%EMAX_DEPTH][j]&1<<c) && (emax6.lmmi[c][m][j][emax6.lmmio].top+(emax6.lmmi[c][m][j][emax6.lmmio].len+1)*sizeof(Uint)) == emax6.lmmi[c][(m+1)%EMAX_DEPTH][j][emax6.lmmio].top) {
									    if (!concat_adr) { concat_adr  = emax6.lmmi[c][m][j][emax6.lmmio].top;
									                       concat_len  = emax6.lmmi[c][m][j][emax6.lmmio].len;   }
								            else             { concat_len += emax6.lmmi[c][m][j][emax6.lmmio].len+1; }
									    if (concat_len < 8192)
									      mark = 0;
									    else
									      mark = 1;
								          }
									  else {
									    if (!concat_adr) {}
									    else             { concat_len += emax6.lmmi[c][m][j][emax6.lmmio].len+1; }
									    mark = 1;
									  }
#else
                                                                          mark = 1;
#endif
									            emax6.lmmd[m][j] &= ~(1<<c);} /* ●4 lmx      drain */
    else                                                                { mark = 0;                             }
  }
  else if (mode==1 && phase == 1) { /* drain */
    if (                                       (emax6.lmmd[i][j]&1<<c)) { mark = 1; emax6.lmmd[i][j] &= ~(1<<c);} /* ☆  drain_dirty_lmm */
    else                                                                { mark = 0;                             }
d573 5
a577 28
    if      (lmmc_stat== 8               && !lmm_ready)                 { mark = 1;                             } /* ●1 lmr & !ready */
    else if (lmmc_stat== 9 && !lmmc_ofsz && !lmm_readz)                 { mark = 1;                             } /* ●7 lmp & !readz */
    else if (lmmc_stat==10)                                             { mark = 1;                             } /* ●3 lmf always load */
    else if (lmmc_stat==14               && !lmm_ready)                 { /* concat_adr=0        adr0,L=0        | adr1,L=0        | adr2,L=0        */
                                                                          /* concat_adr=adr0,L=0 adr0,L=0,mark=0 | adr1,L=0        | adr2,L=0        */
                                                                          /* concat_adr=adr0,L=1          mark=0 | adr1,L=0,mark=0 | adr2,L=0        */
                                                                          /* concat_adr=adr0,L=2          mark=0 |          mark=0 | adr2,L=0,mark=1 */
#if 1
//printf("lmx load: adr=%08.8x len=%08.8x adr=%08.8x\n", (Uint)emax6.lmmi[c][i][j][emax6.lmmic].top, (Uint)emax6.lmmi[c][i][j][emax6.lmmic].len, (Uint)emax6.lmmi[c][(i+1)%EMAX_DEPTH][j][emax6.lmmic].top);
                                                                          if (emax6.lmmi[c][(i+1)%EMAX_DEPTH][j][emax6.lmmic].v && (emax6.lmmi[c][i][j][emax6.lmmic].top+(emax6.lmmi[c][i][j][emax6.lmmic].len+1)*sizeof(Uint)) == emax6.lmmi[c][(i+1)%EMAX_DEPTH][j][emax6.lmmic].top) {
									    if (!concat_adr) { concat_adr  = emax6.lmmi[c][i][j][emax6.lmmic].top;
									                       concat_len  = emax6.lmmi[c][i][j][emax6.lmmic].len;   }
								            else             { concat_len += emax6.lmmi[c][i][j][emax6.lmmic].len+1; }
									    if (concat_len < 8192)
									      mark = 0;
									    else
									      mark = 1;
								          }
									  else {
									    if (!concat_adr) {}
									    else             { concat_len += emax6.lmmi[c][i][j][emax6.lmmic].len+1; }
                                                                            mark = 1;
									  }
#else
                                                                          mark = 1;
#endif
                                                                                                                } /* ●3 lmx always load */
    else                                                                { mark = 0;                             } /* skip load */
d580 3
a582 3
    if      (lmmc_stat== 9                                            ) { mark = 1;                             } /* ●5 lmp */
    else if (lmmc_stat==12 || lmmc_stat==14                           ) { mark = 0; emax6.lmmd[i][j] |=  (1<<c);} /* ●6 lmw/lmx */
    else if (lmmc_stat==13)                       { mark = (emax6.lmmd[m][j]&1<<c); emax6.lmmd[m][j] |= ((!lastdist)<<c);} /* ●6 lmd & dirty */
d584 34
a617 2
//  else if (lmmc_stat==11                                            ) { mark = 1;                             } /*     LDDMQ */
//  else if (lmmc_stat==15                                            ) { mark = 1;                             } /*     TR */
a618 1
    else                                                                { mark = 0;                             } /* skip pdrain/pload */
d623 1
d625 1
a625 2
      emax6.rw     = 1; /* lmm->mem */
      emax6.ddraddr = (concat_adr)?concat_adr:(mode==0)?emax6.lmmi[c][m][j][emax6.lmmio].top:emax6.lmmi[c][i][j][emax6.lmmic].top; /* address should be 4B-aligned */
d627 1
a627 1
      emax6.dmalen  = (concat_adr)?concat_len:(mode==0)?emax6.lmmi[c][m][j][emax6.lmmio].len:emax6.lmmi[c][i][j][emax6.lmmic].len; /* length should be # of words */
d629 2
a630 3
    else if (phase == 3 && emax6.lmmi[c][i][j][emax6.lmmic].rw==1) { /* pdrain */
      emax6.rw     = 1; /* lmm->mem */
      emax6.ddraddr = emax6.lmmi[c][i][j][emax6.lmmic].top+(Sll)(int)emax6.lmmi[c][i][j][emax6.lmmic].ofs; /* ★★★PDRAIN address should be 4B-aligned */
d632 1
a632 1
      emax6.dmalen  = emax6.lmmi[c][i][j][emax6.lmmic].len; /* length should be # of words */
d634 3
a636 4
    else if (phase == 2                                               /* load */
	  ||(phase == 3 && emax6.lmmi[c][i][j][emax6.lmmic].rw==0)) { /* pload *//* address should be 4B-aligned *//* length should be # of words */
      emax6.rw     = 0; /* mem->lmm */
      if (emax6.lmmi[c][i][j][emax6.lmmic].blk==0) { /* inf */
d638 1
a638 1
	  emax6.ddraddr = (concat_adr)?concat_adr:emax6.lmmi[c][i][j][emax6.lmmic].top; /* address should be 4B-aligned */
d640 1
a640 1
	  emax6.dmalen  = (concat_adr)?concat_len:emax6.lmmi[c][i][j][emax6.lmmic].len; /* length should be # of words */
d643 1
a643 1
	  emax6.ddraddr = emax6.lmmi[c][i][j][emax6.lmmic].top+(Sll)(int)emax6.lmmi[c][i][j][emax6.lmmic].ofs; /* ★★★PLOAD address should be 4B-aligned */
d645 1
a645 1
	  emax6.dmalen  = emax6.lmmi[c][i][j][emax6.lmmic].len; /* length should be # of words */
d654 1
a654 1
	  emax6.plist = emax6.lmmi[c][i][j][emax6.lmmic].top+emax6.blkcount*8; /* address should be 4B-aligned */
d656 2
a657 2
	  emax6.plist = emax6.lmmi[c][i][j][emax6.lmmic].top+emax6.blkcount*8+(Sll)(int)emax6.lmmi[c][i][j][emax6.lmmic].ofs; /* ★★★PLOAD address should be 4B-aligned */
	emax6.blksize  = 32<<emax6.lmmi[c][i][j][emax6.lmmic].blk; /* max:10bit */
d660 1
a660 1
	  emax6.lmmblklen = emax6.lmmi[c][i][j][emax6.lmmic].len; /* length should be # of words */
@


1.163
log
@*** empty log message ***
@
text
@d542 1
a542 1
  static int concat_adr; /* NULL:invalid, !NULL:top_addr */
d569 3
a571 2
  //printf("lmx drain: adr=%08.8x len=%08.8x adr=%08.8x\n", (Uint)emax6.lmmi[c][m][j][emax6.lmmio].top, (Uint)emax6.lmmi[c][m][j][emax6.lmmio].len, (Uint)emax6.lmmi[c][(m+1)%EMAX_DEPTH][j][emax6.lmmio].top);
                                                                          if (m < EMAX_DEPTH-1 && (emax6.lmmd[(m+1)%EMAX_DEPTH][j]&1<<c) && (emax6.lmmi[c][m][j][emax6.lmmio].top+(emax6.lmmi[c][m][j][emax6.lmmio].len+1)*sizeof(Uint)) == emax6.lmmi[c][(m+1)%EMAX_DEPTH][j][emax6.lmmio].top) {
d575 4
a578 1
									    mark = 0;
d585 3
d603 3
a605 2
  //printf("lmx load: adr=%08.8x len=%08.8x adr=%08.8x\n", (Uint)emax6.lmmi[c][i][j][emax6.lmmic].top, (Uint)emax6.lmmi[c][i][j][emax6.lmmic].len, (Uint)emax6.lmmi[c][(i+1)%EMAX_DEPTH][j][emax6.lmmic].top);
                                                                          if (i < EMAX_DEPTH-1 && emax6.lmmi[c][(i+1)%EMAX_DEPTH][j][emax6.lmmic].v && (emax6.lmmi[c][i][j][emax6.lmmic].top+(emax6.lmmi[c][i][j][emax6.lmmic].len+1)*sizeof(Uint)) == emax6.lmmi[c][(i+1)%EMAX_DEPTH][j][emax6.lmmic].top) {
d609 4
a612 1
									    mark = 0;
d619 3
@


1.162
log
@*** empty log message ***
@
text
@d542 3
d549 1
a549 2
    lmmo_stat = ((emax6.lmmi[c][m][j][emax6.lmmio].v)<<3)
	        |(emax6.lmmi[c][m][j][emax6.lmmio].rw<<2)|(emax6.lmmi[c][m][j][emax6.lmmio].f<<1)|(emax6.lmmi[c][m][j][emax6.lmmio].p); /* v|rw|f|p */
d561 2
d565 17
a581 1
    else if (lmmo_stat==14 && !lmm_ready    && (emax6.lmmd[m][j]&1<<c)) { mark = 1; emax6.lmmd[m][j] &= ~(1<<c);} /* ●4 lmx      drain */
d592 17
a608 1
    else if (lmmc_stat==14               && !lmm_ready)                 { mark = 1;                             } /* ●3 lmx always load */
d626 1
a626 1
      emax6.ddraddr = (mode==0)?emax6.lmmi[c][m][j][emax6.lmmio].top:emax6.lmmi[c][i][j][emax6.lmmic].top; /* address should be 4B-aligned */
d628 1
a628 1
      emax6.dmalen  = (mode==0)?emax6.lmmi[c][m][j][emax6.lmmio].len:emax6.lmmi[c][i][j][emax6.lmmic].len; /* length should be # of words */
d636 1
a636 1
    else if (phase == 2                                            /* load */
d640 6
a645 3
	if (phase == 2) /* load */
	  emax6.ddraddr = emax6.lmmi[c][i][j][emax6.lmmic].top; /* address should be 4B-aligned */
	else
d647 3
a649 2
	emax6.lmmaddr   = emax6.ddraddr;
	emax6.dmalen    = emax6.lmmi[c][i][j][emax6.lmmic].len; /* length should be # of words */
d681 1
@


1.161
log
@*** empty log message ***
@
text
@d491 9
a499 9
  printf("SIML_cycle: ARM:%llu DRAIN:%llu CONF:%llu REGV:%llu RANGE:%llu LOAD:%llu EXEC:%llu total:%llu\n",
	 nanosec[NANOS_ARM],
	 nanosec[NANOS_DRAIN],
	 nanosec[NANOS_CONF],
	 nanosec[NANOS_REGV],
	 nanosec[NANOS_RANGE],
	 nanosec[NANOS_LOAD],
	 nanosec[NANOS_EXEC],
	 nanosec[NANOS_TOTAL]);
d501 9
a509 9
  printf("usec: ARM:%llu DRAIN:%llu CONF:%llu REGV:%llu RANGE:%llu LOAD:%llu EXEC:%llu total:%llu\n",
	 nanosec[NANOS_ARM]/1000,
	 nanosec[NANOS_DRAIN]/1000,
	 nanosec[NANOS_CONF]/1000,
	 nanosec[NANOS_REGV]/1000,
	 nanosec[NANOS_RANGE]/1000,
	 nanosec[NANOS_LOAD]/1000,
	 nanosec[NANOS_EXEC]/1000,
	 nanosec[NANOS_TOTAL]/1000);
@


1.160
log
@*** empty log message ***
@
text
@d501 9
a509 9
  printf("nanosec: ARM:%llu DRAIN:%llu CONF:%llu REGV:%llu RANGE:%llu LOAD:%llu EXEC:%llu total:%llu\n",
	 nanosec[NANOS_ARM],
	 nanosec[NANOS_DRAIN],
	 nanosec[NANOS_CONF],
	 nanosec[NANOS_REGV],
	 nanosec[NANOS_RANGE],
	 nanosec[NANOS_LOAD],
	 nanosec[NANOS_EXEC],
	 nanosec[NANOS_TOTAL]);
@


1.159
log
@*** empty log message ***
@
text
@d1699 2
a1700 2
  case OP_LDWR: /* s32bit lmm LMM is preloaded, random-access */
    *d = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);
d1702 2
a1703 8
  case OP_LDUWR: /* u32bit lmm LMM is preloaded, random-access */
    *d = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);
    break;
//case OP_LDHR: /* s16bit lmm LMM is preloaded, random-access */
//  *d = (Ull)(Uint)(int)*(short*)(adr&~1LL)<<32 | (Ull)(Uint)(int)*(short*)(adr&~1LL);
//  break;
//case OP_LDUHR: /* u16bit lmm LMM is preloaded, random-access */
//  *d = (Ull)(Uint)*(Ushort*)(adr&~1LL)<<32 | (Ull)(Uint)*(Ushort*)(adr&~1LL);
d1705 2
a1706 5
  case OP_LDBR: /* s8bit lmm LMM is preloaded, random-access */
    *d = (Ull)(Uint)(int)*(char*)adr<<32 | (Ull)(Uint)(int)*(char*)adr;
    break;
  case OP_LDUBR: /* u8bit lmm LMM is preloaded, random-access */
    *d = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;
@


1.158
log
@*** empty log message ***
@
text
@d1105 13
d1119 1
a1119 1
exe(Uint op_ex1, Ull *d, Ull r1, Uint exp1, Ull r2, Uint exp2, Ull r3, Uint exp3, Uint op_ex2, Ull r4, Uint op_ex3, Ull r5)
d1123 1
d1131 3
a1133 15
  switch (exp1) {
  case EXP_H3210:                                                                    break;
  case EXP_B7632: r1 = (r1>>8&0x00ff000000ff0000LL) | (r1>>16&0x000000ff000000ffLL); break;
  case EXP_B5410: r1 = (r1<<8&0x00ff000000ff0000LL) | (r1    &0x000000ff000000ffLL); break;
  }
  switch (exp2) {
  case EXP_H3210:                                                                    break;
  case EXP_B7632: r2 = (r2>>8&0x00ff000000ff0000LL) | (r2>>16&0x000000ff000000ffLL); break;
  case EXP_B5410: r2 = (r2<<8&0x00ff000000ff0000LL) | (r2    &0x000000ff000000ffLL); break;
  }
  switch (exp3) {
  case EXP_H3210:                                                                    break;
  case EXP_B7632: r3 = (r3>>8&0x00ff000000ff0000LL) | (r3>>16&0x000000ff000000ffLL); break;
  case EXP_B5410: r3 = (r3<<8&0x00ff000000ff0000LL) | (r3    &0x000000ff000000ffLL); break;
  }
d1609 2
a1610 2
void /*__attribute__((always_inline))*/
eam(Ull *ofs, Ull offset, Uchar msk)
d1613 16
a1628 47
  case  MSK_D0:
    break;
  case  MSK_W1:		
    offset = offset>>32;
    break;
  case  MSK_W0:
    offset = offset&0x00000000ffffffffLL;
    break;
  case  MSK_H3:
    offset = offset>>48&0x000000000000ffffLL;
    break;
  case  MSK_H2:
    offset = offset>>32&0x000000000000ffffLL;
    break;
  case  MSK_H1:
    offset = offset>>16&0x000000000000ffffLL;
    break;
  case  MSK_H0:
    offset = offset&0x000000000000ffffLL;
    break;
  case  MSK_B7:
    offset = offset>>56&0x00000000000000ffLL;
    break;
  case  MSK_B6:
    offset = offset>>48&0x00000000000000ffLL;
    break;
  case  MSK_B5:
    offset = offset>>40&0x00000000000000ffLL;
    break;
  case  MSK_B4:
    offset = offset>>32&0x00000000000000ffLL;
    break;
  case  MSK_B3:
    offset = offset>>24&0x00000000000000ffLL;
    break;
  case  MSK_B2:
    offset = offset>>16&0x00000000000000ffLL;
    break;
  case  MSK_B1:
    offset = offset>>8&0x00000000000000ffLL;
    break;
  case  MSK_B0:
    offset = offset&0x00000000000000ffLL;
    break;
  default:
    printf("emax6lib: eag: undefined msk=%d\n", msk);
    break;
a1629 2

  *ofs = offset;
d1643 1
a1643 2
  eam(&ofs, offset, msk);
  eag(&adr, base, ofs);
d1652 1
a1652 2
  eam(&ofs, offset, msk);
  eag(&adr, base, ofs);
@


1.157
log
@*** empty log message ***
@
text
@d1702 1
a1702 1
  if (!((op_mm==OP_LDRQ && blk) || op_mm==OP_LDDMQ) && (!adr || !top)) return; /* NULL skip DMA */
d1705 1
a1705 1
  if (!((op_mm==OP_LDRQ && blk) || op_mm==OP_LDDMQ) && (adr < top || adr >= top+len*sizeof(Uint)+CHECK_MMP_MARGIN)) {
@


1.156
log
@*** empty log message ***
@
text
@d1702 1
a1702 1
  if (!adr || !top) return; /* NULL skip DMA */
d1705 1
a1705 1
  if (!(op_mm==OP_LDRQ && blk) && (adr < top || adr >= top+len*sizeof(Uint)+CHECK_MMP_MARGIN)) {
@


1.155
log
@*** empty log message ***
@
text
@d1703 3
a1705 3
  
#define CHECK_MMP_MARGINE 12
  if (adr < top || adr >= top+len*sizeof(Uint)+CHECK_MMP_MARGINE) {
@


1.154
log
@*** empty log message ***
@
text
@d864 1
d1152 15
d1583 26
a1608 1
eag(Ull *adr, Ull base, Ull offset, Uchar msk)
d1660 7
a1666 1
  *adr = base + offset;
d1672 1
a1672 1
  Ull adr;
d1674 2
a1675 1
  eag(&adr, base, offset, msk);
d1682 1
a1682 1
  Ull adr;
d1684 2
a1685 1
  eag(&adr, base, offset, msk);
@


1.153
log
@*** empty log message ***
@
text
@d558 1
d561 1
a561 1
    else if (lmmo_stat==14                  && (emax6.lmmd[m][j]&1<<c)) { mark = 1; emax6.lmmd[m][j] &= ~(1<<c);} /* ●4 lmx      drain */
d572 1
a572 1
    else if (lmmc_stat==14)                                             { mark = 1;                             } /* ●3 lmx always load */
@


1.152
log
@*** empty log message ***
@
text
@d8 1
a8 1
/******************************** GET_NANOSEC **********************************/
a11 2
Ull nanosec_sav;
Ull nanosec[NANOS_CLASS];
d13 16
a28 13
reset_nanosec()
{
  int i;
  for (i=0; i<NANOS_CLASS; i++)
    nanosec[i] = 0;
#if defined(ARMSIML)
  nanosec_sav = _getclk(0);
#else
  struct timespec ts;
  clock_gettime(0, &ts); /*CLOCK_REALTIME*/
  nanosec_sav = 1000000000*ts.tv_sec + ts.tv_nsec;
#endif
}
d30 3
a32 17
get_nanosec(int class)
{
  Ull nanosec_now;
#if defined(ARMSIML)
  nanosec_now = _getclk(0);
  nanosec[class] += nanosec_now - nanosec_sav;
  nanosec[NANOS_TOTAL] += nanosec_now - nanosec_sav;
  nanosec_sav = nanosec_now;
#else
  struct timespec ts;
  clock_gettime(0, &ts); /*CLOCK_REALTIME*/
  nanosec_now = 1000000000*ts.tv_sec + ts.tv_nsec;
  nanosec[class] += nanosec_now - nanosec_sav;
  nanosec[NANOS_TOTAL] += nanosec_now - nanosec_sav;
  nanosec_sav = nanosec_now;
#endif
}
d34 3
a36 24
show_nanosec()
{
#if defined(ARMSIML)
  printf("SIML_cycle: ARM:%llu DRAIN:%llu CONF:%llu REGV:%llu RANGE:%llu LOAD:%llu EXEC:%llu total:%llu\n",
	 nanosec[NANOS_ARM],
	 nanosec[NANOS_DRAIN],
	 nanosec[NANOS_CONF],
	 nanosec[NANOS_REGV],
	 nanosec[NANOS_RANGE],
	 nanosec[NANOS_LOAD],
	 nanosec[NANOS_EXEC],
	 nanosec[NANOS_TOTAL]);
#else
  printf("nanosec: ARM:%llu DRAIN:%llu CONF:%llu REGV:%llu RANGE:%llu LOAD:%llu EXEC:%llu total:%llu\n",
	 nanosec[NANOS_ARM],
	 nanosec[NANOS_DRAIN],
	 nanosec[NANOS_CONF],
	 nanosec[NANOS_REGV],
	 nanosec[NANOS_RANGE],
	 nanosec[NANOS_LOAD],
	 nanosec[NANOS_EXEC],
	 nanosec[NANOS_TOTAL]);
#endif
}
d260 2
d450 64
a828 3
#define ad(a,b)   ((a)<(b)?(b)-(a):(a)-(b))
#define ss(a,b)   ((a)<(b)?   0   :(a)-(b))

a897 23
typedef struct {
  Uint  f : 23;
  Uint  e :  8;
  Uint  s :  1;
} f32bit;

typedef struct {
  Uint  e :  6;
  Uint  b :  1;
  Uint  s :  1;
} u7bit;

typedef struct {
  Uint  e :  7;
  Uint  s :  1;
} u8bit;

typedef struct {
  Uchar u[8];
} u64bit;

#define abs(a)     ((a)>  0 ? (a) :-(a)    )

d1773 1
@


1.151
log
@*** empty log message ***
@
text
@a942 2
     /* 0:urand0 */
     /* 1:urand1 */
d944 4
a947 2
  static Ull urand0_seed = 0xc3c3c3c3a5a5a5a5LL; /* reset */
  static Ull urand1_seed = 0x123456789abcdef0LL; /* reset */
d951 4
a954 12
  if (no == 2) {
    urand0_seed ^= (urand0_seed<<29);
    urand0_seed ^= (urand0_seed>>27);
    urand0_seed ^= (urand0_seed<<37);
    return (urand0_seed);
  }
  else {
    urand1_seed ^= (urand1_seed<<29);
    urand1_seed ^= (urand1_seed>>27);
    urand1_seed ^= (urand1_seed<<37);
    return (urand1_seed);
  }
d996 1
d1003 2
d1006 2
d1011 2
a1013 2
      Ull u2 = urand(0);
      Ull u3 = urand(1);
d1021 2
a1022 2
      s2[i] = shfl(s2[i], u2);
      s3[i] = shfl(s3[i], u3);
d1027 4
a1030 4
      for (j=0; j<SPU_DATA_BITS; j++) {
	int k = j * (sizeof(Ull)*8/(SPU_DATA_BITS+1)); /* SPU_DATA_BITS=15なら4bit毎 */
	s2[i] |= ((u2>>k&SPU_DATA_BITS)<=s2e)<<j;
	s3[i] |= ((u3>>k&SPU_DATA_BITS)<=s3e)<<j;
d1043 1
a1043 1
    for (j=0; j<SPU_DATA_BITS; j++) {
@


1.150
log
@*** empty log message ***
@
text
@d1052 2
a1053 2
    pc = pc>>r4; // r4=2 for MNIST/CIFAR10
    nc = nc>>r4; // r4=3 for test021
@


1.149
log
@*** empty log message ***
@
text
@d1052 2
a1053 2
    pc = (pc*(SPU_DATA_BITS+1)/8)>>r4; // SPU_DATA_BITS=15の場合,4倍密,8MACなら32倍. r4=4 for MNIST/CIFAR10
    nc = (nc*(SPU_DATA_BITS+1)/8)>>r4; // SPU_DATA_BITS=15の場合,4倍密,8MACなら32倍. r4=3 for test021
@


1.148
log
@*** empty log message ***
@
text
@d942 3
a944 1
Ull urand()
d946 2
a947 1
  static Ull urand_seed = 0xc3c3c3c3a5a5a5a5LL; /* reset */
d951 12
a962 4
  urand_seed ^= (urand_seed<<29);
  urand_seed ^= (urand_seed>>27);
  urand_seed ^= (urand_seed<<37);
  return (urand_seed); 
d1015 2
a1016 2
      Ull u2 = urand();
      Ull u3 = urand();
@


1.147
log
@*** empty log message ***
@
text
@d998 2
a999 3
//#define SPU_DATA_BITS 32 err=0.06
//#define SPU_DATA_BITS 16 err=0.10
#define SPU_DATA_BITS 16
d1007 2
a1008 2
  int s2e   = (r2>>(i*8))&0x7f; s2e = s2e<64?s2e:63; /* 0-63 */
  int s3e   = (r3>>(i*8))&0x7f; s3e = s3e<64?s3e:63; /* 0-63 */
d1016 1
a1016 1
      // 乱数を4bit毎に使用.入力値の6bitがほとんど15以下であることを利用(63近くなると誤差が出るはず)
d1020 3
a1022 2
	s2[i] |= ((u2>>(j*4)&15)<s2e)<<j;
	s3[i] |= ((u3>>(j*4)&15)<s3e)<<j;
d1028 1
a1028 1
      o1[i] = ss[i]<<63|(o1[i]&0x7fffffffLL);// stage2の出力は(先頭符号bit|SPU_DATA_BITS bit-1) * 8
d1041 2
a1042 2
    pc = pc*(float)r4/SPU_DATA_BITS; // r4=16 for MNIST
    nc = nc*(float)r4/SPU_DATA_BITS; // r4=32 for test021
@


1.146
log
@*** empty log message ***
@
text
@d1018 6
a1023 8
      s2[i] = ((u2>>60&15)<s2e)<<15 | ((u2>>56&15)<s2e)<<14 | ((u2>>52&15)<s2e)<<13 | ((u2>>48&15)<s2e)<<12
            | ((u2>>44&15)<s2e)<<11 | ((u2>>40&15)<s2e)<<10 | ((u2>>36&15)<s2e)<< 9 | ((u2>>32&15)<s2e)<< 8
            | ((u2>>28&15)<s2e)<< 7 | ((u2>>24&15)<s2e)<< 6 | ((u2>>20&15)<s2e)<< 5 | ((u2>>16&15)<s2e)<< 4
            | ((u2>>12&15)<s2e)<< 3 | ((u2>> 8&15)<s2e)<< 2 | ((u2>> 4&15)<s2e)<< 1 | ((u2>> 0&15)<s2e)<< 0;
      s3[i] = ((u3>>60&15)<s3e)<<15 | ((u3>>56&15)<s3e)<<14 | ((u3>>52&15)<s3e)<<13 | ((u3>>48&15)<s3e)<<12
            | ((u3>>44&15)<s3e)<<11 | ((u3>>40&15)<s3e)<<10 | ((u3>>36&15)<s3e)<< 9 | ((u3>>32&15)<s3e)<< 8
            | ((u3>>28&15)<s3e)<< 7 | ((u3>>24&15)<s3e)<< 6 | ((u3>>20&15)<s3e)<< 5 | ((u3>>16&15)<s3e)<< 4
            | ((u3>>12&15)<s3e)<< 3 | ((u3>> 8&15)<s3e)<< 2 | ((u3>> 4&15)<s3e)<< 1 | ((u3>> 0&15)<s3e)<< 0;
d1028 1
a1028 1
      o1[i] = ss[i]<<63|(o1[i]&0x7fffffffffffffffLL);// stage2の出力は(先頭符号bit|SPU_DATA_BITS bit-1) * 8
@


1.145
log
@*** empty log message ***
@
text
@d954 1
a954 1
Ull shfl(Ull in)
a956 2
  Ull r;
  r = urand();
d998 4
d1005 2
d1008 3
a1010 2
  int s2e   = (r2>>(i*8))&0x7f; s2e = s2e<64?s2e:63;
  int s3e   = (r3>>(i*8))&0x7f; s3e = s3e<64?s3e:63;
d1014 14
a1027 2
      s2[i] = shfl(s2[i]);
      s3[i] = shfl(s3[i]);
d1029 2
a1030 3
#define SNAPSHOT_LENGTH 32
      o1[i] = s2[i] & s3[i];                         // 1*1=1になる 実際は上位SNAPSHOT_LENGTHのみAND
      o1[i] = ss[i]<<63|(o1[i]&0x7fffffffffffffffLL);// stage2の出力は(先頭符号bit|追加SNAPSHOT_LEN bit) * 8
d1036 2
a1037 2
    // 正数/負数グループごとに，冒頭部分をスナップショット
    for (j=0; j<SNAPSHOT_LENGTH; j++) {
d1043 2
a1044 2
    pc = pc*(float)r4/SNAPSHOT_LENGTH; // r4=16 for MNIST
    nc = nc*(float)r4/SNAPSHOT_LENGTH; // r4=32 for test021
@


1.144
log
@*** empty log message ***
@
text
@d949 2
a950 2
  urand_seed ^= (urand_seed>>33);
  urand_seed ^= (urand_seed<<31);
@


1.143
log
@*** empty log message ***
@
text
@d942 12
d958 1
a958 1
  r = ((Ull)rand()<<33)^((Ull)rand()<<16)^(Ull)rand();
@


1.142
log
@*** empty log message ***
@
text
@d1036 1
a1036 1
#if defined(SPIKE_TRACE)
@


1.141
log
@*** empty log message ***
@
text
@d1059 2
@


1.140
log
@*** empty log message ***
@
text
@d800 1
a800 1
void   __attribute__((always_inline))
d823 1
a823 1
void   __attribute__((always_inline))
d1061 1
a1061 1
int    __attribute__((always_inline))
d1523 1
a1523 1
void   __attribute__((always_inline))
d1579 1
a1579 1
void   __attribute__((always_inline))
d1588 1
a1588 1
void   __attribute__((always_inline))
@


1.139
log
@*** empty log message ***
@
text
@d996 1
a996 1
      // 下位63bit内でシャッフル
@


1.138
log
@*** empty log message ***
@
text
@d800 1
a800 1
void __attribute__((always_inline))
d823 1
a823 1
void __attribute__((always_inline))
d828 4
a831 4
    exe(op_ex1, (d+0), (Ull)r1, exp1, *(r2+0), exp2, *(r3+0), exp3, OP_NOP, 0LL, OP_NOP, (Ull)r5);
    exe(op_ex1, (d+0), *(d+0),  exp1, *(r2+1), exp2, *(r3+1), exp3, OP_NOP, 0LL, OP_NOP, (Ull)r5);
    exe(op_ex1, (d+0), *(d+0),  exp1, *(r2+2), exp2, *(r3+2), exp3, OP_NOP, 0LL, OP_NOP, (Ull)r5);
    exe(op_ex1, (d+0), *(d+0),  exp1, *(r2+3), exp2, *(r3+3), exp3, OP_NOP, 0LL, OP_NOP, (Ull)r5);
d977 4
a980 1
int softu64(Ull *o, Ull r1, Ull r2, Ull r3, Ull r5) /* o <- s1 + s2 * s3 */
d983 2
a984 2
  int ss[8];
  Ull s2[8], s3[8], sm[8];
d987 13
a999 15
  for (i=0; i<8; i++) { /* s2 * s3 -> ad2 */
    ss[i] = (r2>>(i*8))&0x80 ^ (r3>>(i*8))&0x80;
int s2e   = (r2>>(i*8))&0x7f; s2e = s2e<64?s2e:63;
int s3e   = (r3>>(i*8))&0x7f; s3e = s3e<64?s3e:63;
    s2[i] = (Ull)0x7fffffffffffffffLL>>(63-s2e); //乗算は6bit*6bit->6bit
    s3[i] = (Ull)0x7fffffffffffffffLL>>(63-s3e); //乗算は6bit*6bit->6bit
    // 下位64bit内でシャッフル
    s2[i] = shfl(s2[i]);
    s3[i] = shfl(s3[i]);
    // s2*s3 各要素のstochastic乗算
    sm[i] = s2[i] & s3[i]; // 1*1=1になる
  }
  pc = 0;
  nc = 0;
  // 正数/負数グループごとに，冒頭部分をスナップショット
d1001 32
a1032 4
  for (j=0; j<SNAPSHOT_LENGTH; j++) {
    for (i=0; i<8; i++) { /* s2 * s3 -> ad2 */
      if (!ss[i]) pc += (sm[i] & (1LL<<j))!=0;
      else        nc += (sm[i] & (1LL<<j))!=0;
d1034 2
a1035 18
  }
  pc = pc*(float)r5/SNAPSHOT_LENGTH; // r5=16 for MNIST
  nc = nc*(float)r5/SNAPSHOT_LENGTH; // r5=32 for test021
  // s1をさらに加算
  if (!(r1&0x80)) pc += (r1&0x7f); /* merge pos s1 s1.eは最大7bit */
  else            nc += (r1&0x7f); /* merge neg s1 s1.eは最大7bit */
  // 正数と負数の加算(s1:7bit + s2*s3:6bit->7bit)
  if (pc >= nc) {
    os = 0x00; /* pos */
    oc = pc-nc; /* # of 1 */
  }
  else {
    os = 0x80; /* neg */
    oc = nc-pc; /* # of 1 */
  }
  if (oc >= 128) oc = 127;
  *o = os|oc;

d1037 18
a1054 16
  if (enable_x11) {
    int i;
    u8bit r2_u8;
    u8bit r3_u8;
    float r1_f32;
    float r2_f32;
    float r3_f32;
    float o1_f32;
    convu8tof32(&o1_f32, *(u8bit*)o);   /* for graph */
    convu8tof32(&r1_f32, *(u8bit*)&r1); /* for graph */
    for (i=0; i<8; i++) { /* s2 * s3 -> ad2 */
      *(Uchar*)&r2_u8 = r2>>(i*8)&0xff;
      *(Uchar*)&r3_u8 = r3>>(i*8)&0xff;
      convu8tof32(&r2_f32, r2_u8); /* for graph */
      convu8tof32(&r3_f32, r3_u8); /* for graph */
      r1_f32 += r2_f32*r3_f32;
d1056 2
a1057 1
    x11_softu64_dist(r1_f32, o1_f32);
a1058 1
#endif
d1061 1
a1061 1
int __attribute__((always_inline))
d1069 1
d1106 1
a1106 1
    softu64(&ex1_outd, r1, r2, r3, r4);
d1427 4
a1430 1
    ex2_outd = ex1_outd;
d1473 4
a1476 1
    if (d) *d = ex2_outd;
d1523 1
a1523 1
void __attribute__((always_inline))
d1579 1
a1579 1
void __attribute__((always_inline))
d1588 1
a1588 1
void __attribute__((always_inline))
@


1.137
log
@*** empty log message ***
@
text
@d1090 1
a1090 1
    softu64(&ex1_outd, r1, r2, r3, r5);
@


1.136
log
@*** empty log message ***
@
text
@d974 3
d1022 22
@


1.135
log
@*** empty log message ***
@
text
@d827 6
d842 4
a851 5
  exe(op_ex1, (d+0), *(r1+0), exp1, *(r2+0), exp2, *(r3+0), exp3, OP_NOP, 0LL, OP_NOP, 0LL);
  exe(op_ex1, (d+1), *(r1+1), exp1, *(r2+1), exp2, *(r3+1), exp3, OP_NOP, 0LL, OP_NOP, 0LL);
  exe(op_ex1, (d+2), *(r1+2), exp1, *(r2+2), exp2, *(r3+2), exp3, OP_NOP, 0LL, OP_NOP, 0LL);
  exe(op_ex1, (d+3), *(r1+3), exp1, *(r2+3), exp2, *(r3+3), exp3, OP_NOP, 0LL, OP_NOP, 0LL);

d869 152
d1064 3
@


1.134
log
@*** empty log message ***
@
text
@d1393 1
a1393 2
//void __attribute__((always_inline))
void
@


1.133
log
@*** empty log message ***
@
text
@d1406 1
a1406 1
#define CHECK_MMP_MARGINE 0
@


1.132
log
@*** empty log message ***
@
text
@d1393 2
a1394 1
void __attribute__((always_inline))
d1399 12
a1410 1
  if (!top) return; /* NULL skip DMA */
@


1.131
log
@*** empty log message ***
@
text
@d557 1
a557 1
      emax6.ddraddr = (mode==0)?emax6.lmmi[c][m][j][emax6.lmmio].top:emax6.lmmi[c][i][j][emax6.lmmic].top; /* address should be 8B-aligned */
d559 1
a559 1
      emax6.dmalen  = (mode==0)?emax6.lmmi[c][m][j][emax6.lmmio].len:emax6.lmmi[c][i][j][emax6.lmmic].len; /* length should be # of dwords */
d563 1
a563 1
      emax6.ddraddr = emax6.lmmi[c][i][j][emax6.lmmic].top+(Sll)(int)emax6.lmmi[c][i][j][emax6.lmmic].ofs; /* ★★★PDRAIN address should be 8B-aligned */
d565 1
a565 1
      emax6.dmalen  = emax6.lmmi[c][i][j][emax6.lmmic].len; /* length should be # of dwords */
d568 1
a568 1
	  ||(phase == 3 && emax6.lmmi[c][i][j][emax6.lmmic].rw==0)) { /* pload *//* address should be 8B-aligned *//* length should be # of dwords */
d572 1
a572 1
	  emax6.ddraddr = emax6.lmmi[c][i][j][emax6.lmmic].top; /* address should be 8B-aligned */
d574 1
a574 1
	  emax6.ddraddr = emax6.lmmi[c][i][j][emax6.lmmic].top+(Sll)(int)emax6.lmmi[c][i][j][emax6.lmmic].ofs; /* ★★★PLOAD address should be 8B-aligned */
d576 1
a576 1
	emax6.dmalen    = emax6.lmmi[c][i][j][emax6.lmmic].len; /* length should be # of dwords */
d584 1
a584 1
	  emax6.plist = emax6.lmmi[c][i][j][emax6.lmmic].top+emax6.blkcount*8; /* address should be 8B-aligned */
d586 1
a586 1
	  emax6.plist = emax6.lmmi[c][i][j][emax6.lmmic].top+emax6.blkcount*8+(Sll)(int)emax6.lmmi[c][i][j][emax6.lmmic].ofs; /* ★★★PLOAD address should be 8B-aligned */
d590 1
a590 1
	  emax6.lmmblklen = emax6.lmmi[c][i][j][emax6.lmmic].len; /* length should be # of dwords */
d592 1
a592 1
	emax6.ddraddr    = emax6.plist; /* address should be 8B-aligned */
d647 2
a648 2
      *(Ull*)&(((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD0) = emax6.ddraddr-emax_info.ddr_mmap+emax_info.ddr_phys;     /* address should be 8B-aligned */
      ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Ull);                                      /* length should be # of dwords */
d650 1
a650 1
      ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Ull);                                      /* length should be # of dwords */
d666 1
a666 1
      ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].dmrp = (1LL<<63)|((emax6.dmalen+1)*sizeof(Ull)<<40)|(emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_phys);
d669 3
a671 3
      ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Ull);                                      /* length should be # of dwords */
      *(Ull*)&(((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD0) = emax6.ddraddr-emax_info.ddr_mmap+emax_info.ddr_phys;     /* address should be 8B-aligned */
      ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Ull);                                      /* length should be # of dwords */
d703 1
a703 6
    if (src & (sizeof(Ull)-1) & sizeof(Uint)) { /* 4B-access 0,4 */
      *(Uint*)(dst+0) = *(Uint*)(src+0);
      *(Uint*)(dst+4) = *(Uint*)(src+4);
    }
    else /* 8B-access 0,4 */
      *(Ull*) (dst+0) = *(Ull*) (src+0);
d722 1
a722 1
  pio_words = (emax6.dmalen+1)*2;
@


1.130
log
@*** empty log message ***
@
text
@d617 4
d1403 2
@


1.129
log
@*** empty log message ***
@
text
@d1397 1
a1397 1
  Ull c1, c0;
d1408 11
a1418 15
    {
      Ull load64 = *(Ull*)(adr&~7LL);
      if ((adr&7) == 0) {
	emax6_unaligned_load_valid = 0; 
	*d = load64;
      }
      else if (!emax6_unaligned_load_valid) { /* BR[][][1] */
	emax6_unaligned_load_valid = 1;
	emax6_unaligned_load_high = load64;
	*d = load64 >> (adr&7)*8;
      }
      else { /* BR[][][0] */
	emax6_unaligned_load_valid = 0; 
	*d = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;
      }
@


1.128
log
@*** empty log message ***
@
text
@d1410 1
a1410 1
      if (adr&7 == 0) {
d1421 1
a1421 1
	*d = emax6_unaligned_load_high >> (8-(adr&7))*8 | load64 >> (adr&7)*8;
@


1.127
log
@*** empty log message ***
@
text
@d1391 3
d1408 16
a1423 1
    *d = *(Ull*)(adr&~7LL);
@


1.126
log
@*** empty log message ***
@
text
@d1012 3
a1014 5
#if 0
  case OP_CCAT: /* 32bit 2in s1<<32|s2 concatenate */
    ex1_outd = (r1<<32)|(r2);
    break;
#endif
d1260 3
a1262 3
  case OP_WSWAP: /* 32bit 2in swap and mask words */
    ex2_outd = ((ex1_outd<<32)|(ex1_outd>>32)) & r4;
    break;
d1292 10
a1301 12
#if 0
  case OP_SRAC: /* 32bit*2 2in 32bit arith shift to right (bit47,15 is ext.) */
    t1 = (Sll)(ex2_outd<<16)>>(r5+16)&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<48)>>(r5+16)&0xffffffff00000000LL;
    if (d) *d = t1 | (t0>>32);
    break;
  case OP_SRAD: /* 32bit*2 2in 32bit arith shift to right (bit39,7 is ext.) */
    t1 = (Sll)(ex2_outd<<24)>>(r5+24)&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<56)>>(r5+24)&0xffffffff00000000LL;
    if (d) *d = t1 | (t0>>32);
    break;
#endif
d1413 6
a1418 8
#if 0
  case OP_LDHR: /* s16bit lmm LMM is preloaded, random-access */
    *d = (Ull)(Uint)(int)*(short*)(adr&~1LL)<<32 | (Ull)(Uint)(int)*(short*)(adr&~1LL);
    break;
  case OP_LDUHR: /* u16bit lmm LMM is preloaded, random-access */
    *d = (Ull)(Uint)*(Ushort*)(adr&~1LL)<<32 | (Ull)(Uint)*(Ushort*)(adr&~1LL);
    break;
#endif
d1432 3
a1434 5
#if 0
  case OP_STHR: /* 16bit lmm LMM is drained. random-access */
    if (c0) *(Ushort*)(adr&~1LL) = *d;
    break;
#endif
@


1.125
log
@*** empty log message ***
@
text
@d1012 1
d1016 1
@


1.124
log
@*** empty log message ***
@
text
@d1292 1
d1303 1
d1415 1
d1422 1
d1436 1
d1440 1
@


1.123
log
@*** empty log message ***
@
text
@d1134 1
a1134 1
    t2 = ((r1&0x0000ffff00000000LL)<(r2&0x0000ffff00000000LL))?0:0x000000000000ff00LL;
@


1.122
log
@*** empty log message ***
@
text
@d1408 1
a1408 1
    *d = (Sll)*(int*)(adr&~3LL);
d1411 1
a1411 1
    *d = (Ull)*(Uint*)(adr&~3LL);
d1414 1
a1414 1
    *d = (Sll)*(short*)(adr&~1LL);
d1417 1
a1417 1
    *d = (Ull)*(Ushort*)(adr&~1LL);
d1420 1
a1420 1
    *d = (Sll)*(char*)adr;
d1423 1
a1423 1
    *d = (Ull)*(Uchar*)adr;
@


1.121
log
@*** empty log message ***
@
text
@d730 7
a736 5
  if (src & (sizeof(Dll)-1) & sizeof(Ull)) { /* 8B-access 0,4 */
    *(Ull*)dst = *(Ull*)src;
    src += sizeof(Ull);
    dst += sizeof(Ull);
    pio_words-=2;
d738 8
a745 7

  if (pio_loop = pio_words/(sizeof(Dll)/sizeof(Uint))) {
    for(pio_i=0; pio_i<pio_loop; pio_i++)
      *((Dll*)dst + pio_i) = *((Dll*)src + pio_i);
    pio_words -= pio_loop*(sizeof(Dll)/sizeof(Uint));
    src += pio_loop*sizeof(Dll);
    dst += pio_loop*sizeof(Dll);
a746 1

@


1.120
log
@*** empty log message ***
@
text
@a553 1
  /*printf("====DMA mode=%x phase=%x i=%x m=%x j=%x lmmic/o=%x/%x lmmc_stat=%x(dirty=%x) lmmo_stat=%x(dirty=%x) mark=%x\n", mode, phase, i, m, j, emax6.lmmic, emax6.lmmio, lmmc_stat, emax6.lmmd[i][j], lmmo_stat, emax6.lmmd[m][j], mark);*/
d604 4
@


1.119
log
@*** empty log message ***
@
text
@d187 3
a189 2
    Ull  stat; /* +0000 *//* bit7-4:LMRING, bit3-0:EXRING */
    Ull  dmy0;
@


1.118
log
@*** empty log message ***
@
text
@d190 3
a192 2
    Uint cid;  /* +0014 chip# ( set by write to cmd ) */
    Ull  dmy1;
d194 1
a194 1
    Ull  dmy2;
@


1.117
log
@*** empty log message ***
@
text
@d999 2
a1000 2
    c1 = r1>>1&1;
    c0 = r1   &1;
@


1.116
log
@*** empty log message ***
@
text
@d805 2
a806 2
    index1 = ((c3>>1&1)<<3)|((c2>>1&1)<<2)|((c1>>1&1)<<1)|(c0>>1&1);
    index0 = ((c3   &1)<<3)|((c2   &1)<<2)|((c1   &1)<<1)|(c0   &1);
d971 1
a971 1
    ex1_outd = (c1<<1)|c0;
d976 1
a976 1
    ex1_outd = (c1<<1)|c0;
d981 1
a981 1
    ex1_outd = (c1<<1)|c0;
d986 1
a986 1
    ex1_outd = (c1<<1)|c0;
d991 1
a991 1
    ex1_outd = (c1<<1)|c0;
d996 1
a996 1
    ex1_outd = (c1<<1)|c0;
@


1.115
log
@*** empty log message ***
@
text
@d1253 2
a1254 2
  case OP_WSWAP: /* 32bit 2in swap words */
    ex2_outd = (ex1_outd<<32)|(ex1_outd>>32);
@


1.114
log
@*** empty log message ***
@
text
@d635 3
d654 3
@


1.113
log
@*** empty log message ***
@
text
@d651 1
a651 1
      ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].dmrp = (1LL<<63)|((emax6.dmalen+1)*sizeof(Ull)<<40)|(emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_phys+0x20000000);
@


1.112
log
@*** empty log message ***
@
text
@d195 1
a195 1
    Ull  dmy3;
d639 4
d645 8
d657 6
a670 4
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_CTRL2 = 1;
    do {
      status = ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_STATUS & 3;
    } while (status != 0 && status != 3);
@


1.111
log
@*** empty log message ***
@
text
@d225 1
d612 4
a615 1
  ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].csel = j; /* DMA/LDDMQ/TRANS用に対象colセット */
@


1.110
log
@*** empty log message ***
@
text
@d629 1
a629 17
  if (emax6.dmalen == 0) {
    if (emax6.rw == 0) { /* mem->lmm */
      dst = emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_mmap;
      src = emax6.ddraddr;
    }
    else { /* lmm->mem */
      dst = emax6.ddraddr;
      src = emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_mmap;
    }    
    if (src & (sizeof(Ull)-1) & sizeof(Uint)) { /* 4B-access 0,4 */
      *(Uint*)(dst+0) = *(Uint*)(src+0);
      *(Uint*)(dst+4) = *(Uint*)(src+4);
    }
    else /* 8B-access 0,4 */
      *(Ull*) (dst+0) = *(Ull*) (src+0);
  }
  else {
d661 16
@


1.109
log
@*** empty log message ***
@
text
@d629 15
a643 11
  if (emax6.rw == 0) { /* mem->lmm */
    *(Ull*)&(((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD0) = emax6.ddraddr-emax_info.ddr_mmap+emax_info.ddr_phys;     /* address should be 8B-aligned */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Ull);                                      /* length should be # of dwords */
    *(Ull*)&(((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD0) = emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_phys;     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Ull);                                      /* length should be # of dwords */
  }
  else { /* lmm->mem */
    *(Ull*)&(((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD0) = emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_phys;     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Ull);                                      /* length should be # of dwords */
    *(Ull*)&(((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD0) = emax6.ddraddr-emax_info.ddr_mmap+emax_info.ddr_phys;     /* address should be 8B-aligned */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD2 = (emax6.dmalen+1)*sizeof(Ull);                                      /* length should be # of dwords */
d645 13
d665 11
a675 10
  ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_CTRL2 = 1;
  do {
    status = ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_STATUS & 3;
  } while (status != 0 && status != 3);
  switch (status) {
  case 0:
    break;
  default: /* case 3 */
    printf("emax6_check_lmmi_and_dma(): ZDMA_CH_STATUS=%d (malfunction)\n", status);
    return (0);
@


1.108
log
@*** empty log message ***
@
text
@d197 2
a198 2
    struct conf                    conf[EMAX_DEPTH][EMAX_WIDTH];  /* +2000-3fff */
    struct {Ull  br[UNIT_WIDTH];}  breg[EMAX_DEPTH][EMAX_WIDTH];  /* +4000-5fff *//* unit[cid][EMAX_DEPTH].breg[x][EMAX_WIDTH].br[UNIT_WIDTH] is used */
d211 2
a212 2
        Ull  dmy6 ;}           addr[EMAX_DEPTH][EMAX_WIDTH];  /* +6000-7fff */
    struct {Ull  reg[UNIT_WIDTH];} lddmrw[EMAX_DEPTH][EMAX_WIDTH];/* +8000-9fff *//* lddmq/trans-r,lddmq-w */
@


1.107
log
@*** empty log message ***
@
text
@d781 1
d860 1
d863 1
a863 1
    f2.i = (Uint)(r2>>32);
d868 1
a868 1
    f2.i = (Uint)(r2);
@


1.106
log
@*** empty log message ***
@
text
@d187 10
a196 9
    Ull stat; /* +0000 *//* bit7-4:LMRING, bit3-0:EXRING */
    Ull dmy0;
    Ull cmd;  /* +0010 host writes Ull "0|cmd" then chip# is propagated to succesors */
    Ull dmy1;
    Ull adtr; /* +0020 */
    Ull dmy2;
    Ull csel; /* +0030 */
    Ull dmy3;
    Ull dmy4[1016];
@


1.105
log
@*** empty log message ***
@
text
@d227 2
a228 1
  Ull   mapdist           : 6; /* current mapdist */
d482 1
a482 1
emax6_check_lmmi_and_dma(int mode, int phase, int mapdist, int c, int i, int j)
d486 1
a486 1
  /* mapdist */
d489 1
a489 1
  /* lmmi更新後に呼ばれる. lmd関連はlmd位置を基準にlmr/lmxを検査(+mapdistの理由) */
d491 4
a494 4
  /* mapdist=>0の場合,前回lmw/lmx位置は,"lmmi[i+mapdist][lmmio]" */
  /* 従来,lmdの場合,SCONしてもしなくてもEXECと同時にDRAIN (mapdist=0の場合はlmmの半分をlmd/lmwに使い分ける前提) */
  /* mapdist=0の場合,DYNAMIC_SCONは無意味なので従来通り */
  /* mapdist>0の場合,DYNAMIC_SCONかつSCON有りは従来通り */
d497 1
a497 1
  int k, m = (i+mapdist)%EMAX_DEPTH; /* lmmo-index */
d541 1
a541 1
    else if (lmmc_stat==13)                       { mark = (emax6.lmmd[m][j]&1<<c); emax6.lmmd[m][j] |= ((!mapdist)<<c);} /* ●6 lmd & dirty */
a628 4
#if 0
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD0 = (Uint)((emax6.ddraddr-emax_info.ddr_mmap+emax_info.ddr_phys));     /* address should be 8B-aligned */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD1 = (Uint)((emax6.ddraddr-emax_info.ddr_mmap+emax_info.ddr_phys)>>32); /* address should be 8B-aligned */
#endif
a630 4
#if 0
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD0 = (Uint)((emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_phys));     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD1 = (Uint)((emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_phys)>>32); /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
#endif
a634 4
#if 0
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD0 = (Uint)((emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_phys));     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD1 = (Uint)((emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_phys)>>32); /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
#endif
a636 4
#if 0
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD0 = (Uint)((emax6.ddraddr-emax_info.ddr_mmap+emax_info.ddr_phys));     /* address should be 8B-aligned */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD1 = (Uint)((emax6.ddraddr-emax_info.ddr_mmap+emax_info.ddr_phys)>>32); /* address should be 8B-aligned */
#endif
@


1.104
log
@*** empty log message ***
@
text
@d488 8
@


1.103
log
@*** empty log message ***
@
text
@d50 1
a50 1
  printf("EMAX6_cycle: ARM:%llu DRAIN:%llu CONF:%llu REGV:%llu RANGE:%llu LOAD:%llu EXEC:%llu total:%llu\n",
d60 1
a60 1
  printf("EMAX6_nanosec: ARM:%llu DRAIN:%llu CONF:%llu REGV:%llu RANGE:%llu LOAD:%llu EXEC:%llu total:%llu\n",
@


1.102
log
@*** empty log message ***
@
text
@d7 65
d748 1
@


1.101
log
@*** empty log message ***
@
text
@d163 2
a164 2
  struct lmmi lmmi[2][EMAX_NCHIP][EMAX_DEPTH][EMAX_WIDTH]; /* lmmi for host (len/ofs/top are resolved) */
  Ull   lmmi_bitmap[EMAX_WIDTH];      /* based on lmmi[2][*][EMAX_WIDTH].v */
d434 5
a438 5
    lmmc_topz =  (emax6.lmmi[emax6.lmmic][c][i][j].top == 0);
    lmmc_ofsz =  (emax6.lmmi[emax6.lmmic][c][i][j].ofs == 0);
    lmmo_stat = ((emax6.lmmi[emax6.lmmio][c][m][j].v)<<3)
	        |(emax6.lmmi[emax6.lmmio][c][m][j].rw<<2)|(emax6.lmmi[emax6.lmmio][c][m][j].f<<1)|(emax6.lmmi[emax6.lmmio][c][m][j].p); /* v|rw|f|p */
    lmmc_stat = ((emax6.lmmi[emax6.lmmic][c][i][j].v & ~emax6.lmmi[emax6.lmmic][c][i][j].hcopy & ~emax6.lmmi[emax6.lmmic][c][i][j].vcopy & ((emax6.lmmi[emax6.lmmic][c][i][j].f&emax6.lmmi[emax6.lmmic][c][i][j].p) | !lmmc_topz))<<3)
d440 7
a446 7
	        |(emax6.lmmi[emax6.lmmic][c][i][j].rw<<2)|(emax6.lmmi[emax6.lmmic][c][i][j].f<<1)|(emax6.lmmi[emax6.lmmic][c][i][j].p); /* v|rw|f|p */
    lmm_ready =  (emax6.lmmi[emax6.lmmio][c][m][j].v && emax6.lmmi[emax6.lmmio][c][m][j].blk == emax6.lmmi[emax6.lmmic][c][i][j].blk
		                                     && emax6.lmmi[emax6.lmmio][c][m][j].len == emax6.lmmi[emax6.lmmic][c][i][j].len
                                                     && emax6.lmmi[emax6.lmmio][c][m][j].top == emax6.lmmi[emax6.lmmic][c][i][j].top);
    lmm_readz =  (emax6.lmmi[emax6.lmmio][c][m][j].v && emax6.lmmi[emax6.lmmio][c][m][j].blk == emax6.lmmi[emax6.lmmic][c][i][j].blk
		                                     && emax6.lmmi[emax6.lmmio][c][m][j].len == emax6.lmmi[emax6.lmmic][c][i][j].len
		                                     &&(emax6.lmmi[emax6.lmmio][c][m][j].top+(Sll)(int)emax6.lmmi[emax6.lmmio][c][m][j].ofs) == emax6.lmmi[emax6.lmmic][c][i][j].top);
d480 1
a480 1
      emax6.ddraddr = (mode==0)?emax6.lmmi[emax6.lmmio][c][m][j].top:emax6.lmmi[emax6.lmmic][c][i][j].top; /* address should be 8B-aligned */
d482 1
a482 1
      emax6.dmalen  = (mode==0)?emax6.lmmi[emax6.lmmio][c][m][j].len:emax6.lmmi[emax6.lmmic][c][i][j].len; /* length should be # of dwords */
d484 1
a484 1
    else if (phase == 3 && emax6.lmmi[emax6.lmmic][c][i][j].rw==1) { /* pdrain */
d486 1
a486 1
      emax6.ddraddr = emax6.lmmi[emax6.lmmic][c][i][j].top+(Sll)(int)emax6.lmmi[emax6.lmmic][c][i][j].ofs; /* ★★★PDRAIN address should be 8B-aligned */
d488 1
a488 1
      emax6.dmalen  = emax6.lmmi[emax6.lmmic][c][i][j].len; /* length should be # of dwords */
d491 1
a491 1
	  ||(phase == 3 && emax6.lmmi[emax6.lmmic][c][i][j].rw==0)) { /* pload *//* address should be 8B-aligned *//* length should be # of dwords */
d493 1
a493 1
      if (emax6.lmmi[emax6.lmmic][c][i][j].blk==0) { /* inf */
d495 1
a495 1
	  emax6.ddraddr = emax6.lmmi[emax6.lmmic][c][i][j].top; /* address should be 8B-aligned */
d497 1
a497 1
	  emax6.ddraddr = emax6.lmmi[emax6.lmmic][c][i][j].top+(Sll)(int)emax6.lmmi[emax6.lmmic][c][i][j].ofs; /* ★★★PLOAD address should be 8B-aligned */
d499 1
a499 1
	emax6.dmalen    = emax6.lmmi[emax6.lmmic][c][i][j].len; /* length should be # of dwords */
d507 1
a507 1
	  emax6.plist = emax6.lmmi[emax6.lmmic][c][i][j].top+emax6.blkcount*8; /* address should be 8B-aligned */
d509 2
a510 2
	  emax6.plist = emax6.lmmi[emax6.lmmic][c][i][j].top+emax6.blkcount*8+(Sll)(int)emax6.lmmi[emax6.lmmic][c][i][j].ofs; /* ★★★PLOAD address should be 8B-aligned */
	emax6.blksize  = 32<<emax6.lmmi[emax6.lmmic][c][i][j].blk; /* max:10bit */
d513 1
a513 1
	  emax6.lmmblklen = emax6.lmmi[emax6.lmmic][c][i][j].len; /* length should be # of dwords */
@


1.100
log
@*** empty log message ***
@
text
@d164 2
a165 2
  Ull   lmmi_bitmap[EMAX_WIDTH];               /* based on lmmi[2][*][EMAX_WIDTH].v */
  Uchar lmmd[EMAX_DEPTH][EMAX_WIDTH];          /* 0:clean, 1:dirty,   exec後store箇所に1, drain直後0 */
d449 3
a451 3
    if      (lmmo_stat==12 && lmmc_stat!=13 && emax6.lmmd[m][j]) { mark = 1; emax6.lmmd[m][j] = 0;} /* ●2 lmw&!lmd drain */
    else if (lmmo_stat==14                  && emax6.lmmd[m][j]) { mark = 1; emax6.lmmd[m][j] = 0;} /* ●4 lmx      drain */
    else                                                         { mark = 0;                      }
d454 2
a455 2
    if (                                       emax6.lmmd[i][j]) { mark = 1; emax6.lmmd[i][j] = 0;} /* ☆  drain_dirty_lmm */
    else                                                         { mark = 0;                      }
d458 5
a462 5
    if      (lmmc_stat== 8               && !lmm_ready)          { mark = 1;                      } /* ●1 lmr & !ready */
    else if (lmmc_stat== 9 && !lmmc_ofsz && !lmm_readz)          { mark = 1;                      } /* ●7 lmp & !readz */
    else if (lmmc_stat==10)                                      { mark = 1;                      } /* ●3 lmf always load */
    else if (lmmc_stat==14)                                      { mark = 1;                      } /* ●3 lmx always load */
    else                                                         { mark = 0;                      } /* skip load */
d465 3
a467 3
    if      (lmmc_stat== 9                                     ) { mark = 1;                      } /* ●5 lmp */
    else if (lmmc_stat==12 || lmmc_stat==14                    ) { mark = 0; emax6.lmmd[i][j] = 1;} /* ●6 lmw/lmx */
    else if (lmmc_stat==13)                       { mark = emax6.lmmd[m][j]; emax6.lmmd[m][j] = !mapdist;} /* ●6 lmd & dirty */
d469 2
a470 2
//  else if (lmmc_stat==11                                     ) { mark = 1;                      } /*     LDDMQ */
//  else if (lmmc_stat==15                                     ) { mark = 1;                      } /*     TR */
d472 1
a472 1
    else                                                         { mark = 0;                      } /* skip pdrain/pload */
d476 1
a476 1
  /*printf("====DMA mode=%x phase=%x i=%x m=%x j=%x lmmic/o=%x/%x lmmc_stat=%x(dirty=%x) lmmo_stat=%x(dirty=%x) mark=%x\n", mode, phase, i, m, j, emax6.lmmic, emax6.lmmio, lmmc_stat, emax6.lmmd[c][i][j], lmmo_stat, emax6.lmmd[c][m][j], mark);*/
@


1.99
log
@*** empty log message ***
@
text
@d124 1
a124 2
    Uint cmd;  /* +0010 host writes Ull "0|cmd" then chip is propagated to succesors */
    Uint chip; /* +0014 */
@


1.98
log
@*** empty log message ***
@
text
@d124 2
a125 1
    Ull cmd;  /* +0010 */
d221 2
a222 2
#define REG_AREA_SIZE    0x0000a000
#define LMM_MAP_TOP 	 0x60000000
@


1.97
log
@*** empty log message ***
@
text
@d215 1
a215 1
#define REG_BASE2_PHYS	 0x50010000
@


1.96
log
@*** empty log message ***
@
text
@d163 1
a163 1
  struct lmmi lmmi[2][EMAX_DEPTH][EMAX_WIDTH]; /* lmmi for host (len/ofs/top are resolved) */
d416 1
a416 1
emax6_check_lmmi_and_dma(int mode, int phase, int mapdist, int i, int j)
d434 5
a438 5
    lmmc_topz =  (emax6.lmmi[emax6.lmmic][i][j].top == 0);
    lmmc_ofsz =  (emax6.lmmi[emax6.lmmic][i][j].ofs == 0);
    lmmo_stat = ((emax6.lmmi[emax6.lmmio][m][j].v)<<3)
	        |(emax6.lmmi[emax6.lmmio][m][j].rw<<2)|(emax6.lmmi[emax6.lmmio][m][j].f<<1)|(emax6.lmmi[emax6.lmmio][m][j].p); /* v|rw|f|p */
    lmmc_stat = ((emax6.lmmi[emax6.lmmic][i][j].v & ~emax6.lmmi[emax6.lmmic][i][j].hcopy & ~emax6.lmmi[emax6.lmmic][i][j].vcopy & ((emax6.lmmi[emax6.lmmic][i][j].f&emax6.lmmi[emax6.lmmic][i][j].p) | !lmmc_topz))<<3)
d440 7
a446 7
	        |(emax6.lmmi[emax6.lmmic][i][j].rw<<2)|(emax6.lmmi[emax6.lmmic][i][j].f<<1)|(emax6.lmmi[emax6.lmmic][i][j].p); /* v|rw|f|p */
    lmm_ready =  (emax6.lmmi[emax6.lmmio][m][j].v && emax6.lmmi[emax6.lmmio][m][j].blk == emax6.lmmi[emax6.lmmic][i][j].blk
		                                  && emax6.lmmi[emax6.lmmio][m][j].len == emax6.lmmi[emax6.lmmic][i][j].len
                                                  && emax6.lmmi[emax6.lmmio][m][j].top == emax6.lmmi[emax6.lmmic][i][j].top);
    lmm_readz =  (emax6.lmmi[emax6.lmmio][m][j].v && emax6.lmmi[emax6.lmmio][m][j].blk == emax6.lmmi[emax6.lmmic][i][j].blk
		                                  && emax6.lmmi[emax6.lmmio][m][j].len == emax6.lmmi[emax6.lmmic][i][j].len
		                                  &&(emax6.lmmi[emax6.lmmio][m][j].top+(Sll)(int)emax6.lmmi[emax6.lmmio][m][j].ofs) == emax6.lmmi[emax6.lmmic][i][j].top);
d476 1
a476 1
  /*printf("====DMA mode=%x phase=%x i=%x m=%x j=%x lmmic/o=%x/%x lmmc_stat=%x(dirty=%x) lmmo_stat=%x(dirty=%x) mark=%x\n", mode, phase, i, m, j, emax6.lmmic, emax6.lmmio, lmmc_stat, emax6.lmmd[i][j], lmmo_stat, emax6.lmmd[m][j], mark);*/
d480 1
a480 1
      emax6.ddraddr = (mode==0)?emax6.lmmi[emax6.lmmio][m][j].top:emax6.lmmi[emax6.lmmic][i][j].top; /* address should be 8B-aligned */
d482 1
a482 1
      emax6.dmalen  = (mode==0)?emax6.lmmi[emax6.lmmio][m][j].len:emax6.lmmi[emax6.lmmic][i][j].len; /* length should be # of dwords */
d484 1
a484 1
    else if (phase == 3 && emax6.lmmi[emax6.lmmic][i][j].rw==1) { /* pdrain */
d486 1
a486 1
      emax6.ddraddr = emax6.lmmi[emax6.lmmic][i][j].top+(Sll)(int)emax6.lmmi[emax6.lmmic][i][j].ofs; /* ★★★PDRAIN address should be 8B-aligned */
d488 1
a488 1
      emax6.dmalen  = emax6.lmmi[emax6.lmmic][i][j].len; /* length should be # of dwords */
d491 1
a491 1
	  ||(phase == 3 && emax6.lmmi[emax6.lmmic][i][j].rw==0)) { /* pload *//* address should be 8B-aligned *//* length should be # of dwords */
d493 1
a493 1
      if (emax6.lmmi[emax6.lmmic][i][j].blk==0) { /* inf */
d495 1
a495 1
	  emax6.ddraddr = emax6.lmmi[emax6.lmmic][i][j].top; /* address should be 8B-aligned */
d497 1
a497 1
	  emax6.ddraddr = emax6.lmmi[emax6.lmmic][i][j].top+(Sll)(int)emax6.lmmi[emax6.lmmic][i][j].ofs; /* ★★★PLOAD address should be 8B-aligned */
d499 1
a499 1
	emax6.dmalen    = emax6.lmmi[emax6.lmmic][i][j].len; /* length should be # of dwords */
d507 1
a507 1
	  emax6.plist = emax6.lmmi[emax6.lmmic][i][j].top+emax6.blkcount*8; /* address should be 8B-aligned */
d509 2
a510 2
	  emax6.plist = emax6.lmmi[emax6.lmmic][i][j].top+emax6.blkcount*8+(Sll)(int)emax6.lmmi[emax6.lmmic][i][j].ofs; /* ★★★PLOAD address should be 8B-aligned */
	emax6.blksize  = 32<<emax6.lmmi[emax6.lmmic][i][j].blk; /* max:10bit */
d513 1
a513 1
	  emax6.lmmblklen = emax6.lmmi[emax6.lmmic][i][j].len; /* length should be # of dwords */
@


1.95
log
@*** empty log message ***
@
text
@d121 29
a149 26
  Ull stat; /* +0000 *//* bit7-4:LMRING, bit3-0:EXRING */
  Ull dmy0;
  Ull cmd;  /* +0010 */
  Ull dmy1;
  Ull adtr; /* +0020 */
  Ull dmy2;
  Ull csel; /* +0030 */
  Ull dmy3;
  Ull dmy4[1016];
  struct conf                    conf[EMAX_DEPTH][EMAX_WIDTH];  /* +2000 */
  struct {Ull  br[UNIT_WIDTH];}  breg[EMAX_DEPTH][EMAX_WIDTH];  /* +4000 *//* unit[cid][EMAX_DEPTH].breg[x][EMAX_WIDTH].br[UNIT_WIDTH] is used */
  struct {Uint ea0b ; /* ea0 base   (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
        /*Ull  dmy0 :14;*/
          Uint ea0o ; /* ea0 offset (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
        /*Ull  dmy1 :14;*/
          Uint ea1b ; /* ea1 base   (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
        /*Ull  dmy2 :14;*/
          Uint ea1o ; /* ea1 offset (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
        /*Ull  dmy3 :14;*/
          Uint top  ; /* LMM-top virtual-address */
        /*Ull  dmy4 : 1;*/
          Uint bot  ; /* LMM-bot virtual-address */
        /*Ull  dmy5 : 1;*/
          Ull  dmy6 ;}           addr[EMAX_DEPTH][EMAX_WIDTH];  /* +6000 */
  struct {Ull  reg[UNIT_WIDTH];} lddmrw[EMAX_DEPTH][EMAX_WIDTH];/* +8000 *//* lddmq/trans-r,lddmq-w */
}; /* 0000-9fff */
d536 1
a536 1
  ((struct reg_ctrl*)emax6.reg_ctrl)->csel = j; /* DMA/LDDMQ/TRANS用に対象colセット */
@


1.94
log
@*** empty log message ***
@
text
@d789 6
@


1.93
log
@*** empty log message ***
@
text
@d531 1
a531 1
  Uint dst, src;
@


1.92
log
@*** empty log message ***
@
text
@d372 31
a402 31
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_ERR_CTRL          = 0x00000001;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_ISR            = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_IMR            = 0x00000FFF;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_IEN            = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_IDS            = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_CTRL0          = 0x00000080;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_CTRL1          = 0x000003FF;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_FCI            = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_STATUS         = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DATA_ATTR      = 0x04C3D30F; /* Note - AxCACHE: 0011 value recomended by Xilinx. */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DSCR_ATTR      = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD0 = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD1 = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD2 = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD3 = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD0 = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD1 = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD2 = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD3 = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_WR_ONLY_WORD0  = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_WR_ONLY_WORD1  = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_WR_ONLY_WORD2  = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_WR_ONLY_WORD3  = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_START_LSB  = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_START_MSB  = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_START_LSB  = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_START_MSB  = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_RATE_CTRL      = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_IRQ_SRC_ACCT   = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_IRQ_DST_ACCT   = 0x00000000;
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_CTRL2          = 0x00000000;
@


1.91
log
@*** empty log message ***
@
text
@d435 1
a435 1
    lmmc_stat = ((emax6.lmmi[emax6.lmmic][i][j].v & ~emax6.lmmi[emax6.lmmic][i][j].copy & ((emax6.lmmi[emax6.lmmic][i][j].f&emax6.lmmi[emax6.lmmic][i][j].p) | !lmmc_topz))<<3)
@


1.90
log
@*** empty log message ***
@
text
@d161 1
a161 1
  Ull   lmmi_bitmap[EMAX_WIDTH];               /* copy of lmmi[2][*][EMAX_WIDTH].v */
@


1.89
log
@*** empty log message ***
@
text
@a1284 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1287 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1290 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1293 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1296 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1299 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1302 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1305 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1309 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1312 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1315 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1320 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
a1360 1
    if (adr < top || adr >= top+len*sizeof(Ull)) printf("emax6lib: mmp: adr=%08.8x out of range (top=%08.8x, bot=%08.8x\n", (Uint)adr, (Uint)top, (Uint)(top+len*sizeof(Ull)-1));
@


1.88
log
@*** empty log message ***
@
text
@d1285 1
d1289 1
d1293 1
d1297 1
d1301 1
d1305 1
d1309 1
d1313 1
d1318 1
d1322 1
d1326 1
d1332 1
d1373 1
@


1.87
log
@*** empty log message ***
@
text
@d159 1
@


1.86
log
@*** empty log message ***
@
text
@d412 1
a412 1
emax6_check_lmmi_and_dma(int mode, int phase, int md, int i, int j)
d419 1
a419 1
  int k, m = (i+md)%EMAX_DEPTH; /* lmmo-index */
d463 1
a463 1
    else if (lmmc_stat==13                  && emax6.lmmd[m][j]) { mark = 1; emax6.lmmd[m][j] = 0;} /* ●6 lmd & dirty */
@


1.85
log
@*** empty log message ***
@
text
@d729 4
a732 4
  exe(op_ex1, *(r1+0), exp1, *(r2+0), exp2, *(r3+0), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (d+0));
  exe(op_ex1, *(r1+1), exp1, *(r2+1), exp2, *(r3+1), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (d+1));
  exe(op_ex1, *(r1+2), exp1, *(r2+2), exp2, *(r3+2), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (d+2));
  exe(op_ex1, *(r1+3), exp1, *(r2+3), exp2, *(r3+3), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (d+3));
@


1.84
log
@*** empty log message ***
@
text
@d308 1
@


1.83
log
@*** empty log message ***
@
text
@d225 11
a236 2
#define EMAX_DEVNAME "/dev/imax0"
int emax_fd;
d259 42
d306 14
a319 2
  if ((emax_fd = open(EMAX_DEVNAME, O_RDWR|O_SYNC )) == -1) {
    printf("emax_open(): Invalid EMAX_DEVNAME: '%s'\n", EMAX_DEVNAME);
a323 4
  emax_info.dma_phys = DMA_BASE_PHYS;
  emax_info.dma_mmap = (Ull)mmap(0,DMA_MMAP_SIZE,PROT_READ|PROT_WRITE,MAP_SHARED,emax_fd,DMA_BASE_PHYS);

  // mmap(cache-off) 4KB aligned
d325 5
a329 3
  emax_info.reg_mmap = (Ull)mmap(0,REG_MMAP_SIZE,PROT_READ|PROT_WRITE,MAP_SHARED,emax_fd,REG_BASE_PHYS);

  // mmap(cache-off) 4KB aligned
d335 8
a342 1
  emax_info.ddr_mmap = (Ull)mmap(0,DDR_MMAP_SIZE,PROT_READ|PROT_WRITE,MAP_SHARED,emax_fd,DDR_BASE_PHYS);
d344 59
a402 1
  return (emax_fd);
@


1.82
log
@*** empty log message ***
@
text
@d130 16
a145 16
  struct conf                   conf[EMAX_DEPTH][EMAX_WIDTH];  /* +2000 */
  struct {Ull br[UNIT_WIDTH];}  breg[EMAX_DEPTH][EMAX_WIDTH];  /* +4000 *//* unit[cid][EMAX_DEPTH].breg[x][EMAX_WIDTH].br[UNIT_WIDTH] is used */
  struct {Ull ea0b :32; /* ea0 base   (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
        /*Ull dmy0 :14;*/
          Ull ea0o :32; /* ea0 offset (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
        /*Ull dmy1 :14;*/
          Ull ea1b :32; /* ea1 base   (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
        /*Ull dmy2 :14;*/
          Ull ea1o :32; /* ea1 offset (for avoiding ld-mask-st, should be extended to 32bits (lower 18bit is available)) */
        /*Ull dmy3 :14;*/
          Ull top  :32; /* LMM-top virtual-address */
        /*Ull dmy4 : 1;*/
          Ull bot  :32; /* LMM-bot virtual-address */
        /*Ull dmy5 : 1;*/
          Ull dmy6 :64;}        addr[EMAX_DEPTH][EMAX_WIDTH];  /* +6000 */
  struct {Ull reg[UNIT_WIDTH];} lddmrw[EMAX_DEPTH][EMAX_WIDTH];/* +8000 *//* lddmq/trans-r,lddmq-w */
d424 1
d427 2
d430 1
d433 2
d438 1
d441 2
d444 1
d447 2
@


1.81
log
@*** empty log message ***
@
text
@d406 1
a406 1
#if defined (ARMZYNQ) && defined(FPDDMA)
@


1.80
log
@*** empty log message ***
@
text
@a154 3
  Ull   v                 : 1; /* 0:empty, 1:unuse */
  Ull   tid               :12; /* owner thread of EMAX */
  Ull   mode              : 2; /* 1:normal array, 2:drain_dirty_lmm */
@


1.79
log
@*** empty log message ***
@
text
@d406 2
a407 2
  Ull *dst, *src;
  Ull pio_loop, pio_len;
d463 2
a464 2
    dst = (Ull*)(emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_mmap);
    src = (Ull*)emax6.ddraddr;
d470 2
a471 2
    dst = (Ull*)emax6.ddraddr;
    src = (Ull*)(emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_mmap);
d477 33
a509 32
  if      (((Uint)src & (sizeof(Dll)-1)) == 0 && ((Uint)dst & (sizeof(Dll)-1)) == 0 && emax6.dmalen > 0) {
    if (emax6.dmalen & 1) { /* srcとdstが16Bアライン & emax6.dmalenが奇数(dword数=偶数) */
      pio_len = (emax6.dmalen-1)/2;
      for(pio_loop=0; pio_loop<=pio_len; pio_loop++)
	*((Dll*)dst + pio_loop) = *((Dll*)src + pio_loop);
    }
    else { /* srcとdstが16Bアライン & emax6.dmalenが偶数(dword数=奇数) */
      pio_len = (emax6.dmalen-2)/2;
      for(pio_loop=0; pio_loop<=pio_len; pio_loop++)
	*((Dll*)dst + pio_loop) = *((Dll*)src + pio_loop);
      *(dst + emax6.dmalen) = *(src + emax6.dmalen);
    }
  }
  else if (((Uint)src & (sizeof(Dll)-1)) != 0 && ((Uint)dst & (sizeof(Dll)-1)) != 0 && emax6.dmalen > 1 ) {
    if (emax6.dmalen & 1) { /* srcとdstが 8Bアライン & emax6.dmalenが奇数(dword数=偶数) */
      *dst++ = *src++;
      pio_len = (emax6.dmalen-3)/2;
      for(pio_loop=0; pio_loop<=pio_len; pio_loop++)
	*((Dll*)dst + pio_loop) = *((Dll*)src + pio_loop);
      *(dst + emax6.dmalen-1) = *(src + emax6.dmalen-1);
    }
    else { /* srcとdstが 8Bアライン & emax6.dmalenが偶数(dword数=奇数) */
      *dst++ = *src++;
      pio_len = (emax6.dmalen-2)/2;
      for(pio_loop=0; pio_loop<=pio_len; pio_loop++)
	*((Dll*)dst + pio_loop) = *((Dll*)src + pio_loop);
    }
  }
  else { /* その他 */
    pio_len = emax6.dmalen;
    for(pio_loop=0; pio_loop<=pio_len; pio_loop++)
      *(dst + pio_loop) = *(src + pio_loop);
@


1.78
log
@*** empty log message ***
@
text
@d348 1
a348 1
  /*printf("====DMA mode=%x phase=%x i=%x j=%x lmmc_stat=%x lmmo_stat=%x mark=%x\n", mode, phase, i, j, lmmc_stat, lmmo_stat, mark);*/
@


1.77
log
@*** empty log message ***
@
text
@d331 1
a331 1
    else if (lmmc_stat== 9 && !lmmc_ofsz && !lmm_readz)          { mark = 1;                      } /* ●7 lmr & !readz */
@


1.76
log
@*** empty log message ***
@
text
@d406 2
a407 1
  Ull pio_loop;
d463 25
a487 5
    for(pio_loop=0; pio_loop<=emax6.dmalen; pio_loop++){
      /*printf("(emax6.lmmaddr+pio_loop):%08.8x_%08.8x <- (emax6.ddraddr + pio_loop):%08.8x_%08.8x\n",
	     (Uint)((Ull)((Ull*)emax6.lmmaddr + pio_loop)>>32), (Uint)(Ull)((Ull*)emax6.lmmaddr + pio_loop),
	     (Uint)((Ull)((Ull*)emax6.ddraddr + pio_loop)>>32), (Uint)(Ull)((Ull*)emax6.ddraddr + pio_loop));*/
      *((Ull*)(emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_mmap) + pio_loop) = *((Ull*)emax6.ddraddr + pio_loop);
d490 13
a502 6
  else { /* lmm->mem */
    for(pio_loop=0; pio_loop<=emax6.dmalen; pio_loop++){
      /*printf("(emax6.lmmaddr+pio_loop):%08.8x_%08.8x -> (emax6.ddraddr + pio_loop):%08.8x_%08.8x\n",
	     (Uint)((Ull)((Ull*)emax6.lmmaddr + pio_loop)>>32), (Uint)(Ull)((Ull*)emax6.lmmaddr + pio_loop),
	     (Uint)((Ull)((Ull*)emax6.ddraddr + pio_loop)>>32), (Uint)(Ull)((Ull*)emax6.ddraddr + pio_loop));*/
      *((Ull*)emax6.ddraddr + pio_loop) = *((Ull*)(emax6.lmmaddr-emax_info.ddr_mmap+emax_info.lmm_mmap) + pio_loop);
d505 5
@


1.75
log
@*** empty log message ***
@
text
@d163 1
a163 1
  Ull   lmmi_bitmap[2][EMAX_WIDTH];            /* copy of lmmi[2][*][EMAX_WIDTH].v */
d295 1
a295 1
  int k;
d308 2
a309 2
    lmmo_stat = ((emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].v)<<3)
	        |(emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].rw<<2)|(emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].f<<1)|(emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].p); /* v|rw|f|p */
d313 6
a318 6
    lmm_ready =  (emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].v && emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].blk == emax6.lmmi[emax6.lmmic][i][j].blk
		                                                  && emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].len == emax6.lmmi[emax6.lmmic][i][j].len
                                                                  && emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].top == emax6.lmmi[emax6.lmmic][i][j].top);
    lmm_readz =  (emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].v && emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].blk == emax6.lmmi[emax6.lmmic][i][j].blk
		                                                  && emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].len == emax6.lmmi[emax6.lmmic][i][j].len
		                                                  &&(emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].top+(Sll)(int)emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].ofs) == emax6.lmmi[emax6.lmmic][i][j].top);
d321 2
a322 2
    if      (lmmo_stat==12 && lmmc_stat!=13 && emax6.lmmd[i][j]) { mark = 1; emax6.lmmd[i][j] = 0;} /* ●2 lmw&!lmd drain */
    else if (lmmo_stat==14                  && emax6.lmmd[i][j]) { mark = 1; emax6.lmmd[i][j] = 0;} /* ●4 lmx      drain */
d339 1
a339 1
    else if (lmmc_stat==13                  && emax6.lmmd[i][j]) { mark = 1; emax6.lmmd[i][j] = 0;} /* ●6 lmd & dirty */
d352 1
a352 1
      emax6.ddraddr = (mode==0)?emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].top:emax6.lmmi[emax6.lmmic][i][j].top; /* address should be 8B-aligned */
d354 1
a354 1
      emax6.dmalen  = (mode==0)?emax6.lmmi[emax6.lmmio][(i+md)%EMAX_DEPTH][j].len:emax6.lmmi[emax6.lmmic][i][j].len; /* length should be # of dwords */
@


1.74
log
@*** empty log message ***
@
text
@a346 2
printf("====DMA mode=%x phase=%x i=%x j=%x lmmc_stat=%x lmmo_stat=%x mark=%x\n", mode, phase, i, j, lmmc_stat, lmmo_stat, mark);

d348 1
@


1.73
log
@*** empty log message ***
@
text
@d288 1
a288 1
emax6_check_lmmi_and_dma(int mode, int phase, int i, int j)
d292 1
d308 2
a309 2
    lmmo_stat = ((emax6.lmmi[emax6.lmmio][i][j].v                                  )<<3)
	        |(emax6.lmmi[emax6.lmmio][i][j].rw<<2)|(emax6.lmmi[emax6.lmmio][i][j].f<<1)|(emax6.lmmi[emax6.lmmio][i][j].p); /* v|rw|f|p */
d313 6
a318 6
    lmm_ready =  (emax6.lmmi[emax6.lmmio][i][j].v && emax6.lmmi[emax6.lmmio][i][j].blk == emax6.lmmi[emax6.lmmic][i][j].blk
		                                  && emax6.lmmi[emax6.lmmio][i][j].len == emax6.lmmi[emax6.lmmic][i][j].len
                                                  && emax6.lmmi[emax6.lmmio][i][j].top == emax6.lmmi[emax6.lmmic][i][j].top);
    lmm_readz =  (emax6.lmmi[emax6.lmmio][i][j].v && emax6.lmmi[emax6.lmmio][i][j].blk == emax6.lmmi[emax6.lmmic][i][j].blk
		                                  && emax6.lmmi[emax6.lmmio][i][j].len == emax6.lmmi[emax6.lmmic][i][j].len
		                                  &&(emax6.lmmi[emax6.lmmio][i][j].top+(Sll)(int)emax6.lmmi[emax6.lmmio][i][j].ofs) == emax6.lmmi[emax6.lmmic][i][j].top);
d347 2
d353 1
a353 1
      emax6.ddraddr = (mode==0)?emax6.lmmi[emax6.lmmio][i][j].top:emax6.lmmi[emax6.lmmic][i][j].top; /* address should be 8B-aligned */
d355 1
a355 1
      emax6.dmalen  = (mode==0)?emax6.lmmi[emax6.lmmio][i][j].len:emax6.lmmi[emax6.lmmic][i][j].len; /* length should be # of dwords */
@


1.72
log
@*** empty log message ***
@
text
@d458 1
d460 4
a463 2
    for(pio_loop=0;pio_loop <= emax6.dmalen; pio_loop++){
      //printf("(emax6.lmmaddr + pio_loop):0x%016x\n",((Ull*)emax6.lmmaddr + pio_loop));
d468 4
a471 2
    for(pio_loop=0;pio_loop <= emax6.dmalen; pio_loop++){
      //printf("(emax6.ddraddr + pio_loop):0x%016x\n",((Ull*)emax6.ddraddr + pio_loop));
@


1.71
log
@*** empty log message ***
@
text
@d127 3
a129 1
  Ull dmy3[1018];
a211 4
#define DMA_BASE2_PHYS	 0x4ff00000
#define REG_BASE2_PHYS	 0x4ff10000
#define REG_REGV_BRBASE  0x00004000
#define REG_REGV_BREND   0x00005fff
d213 9
a221 1
#define REG_BASE2_SIZE   0x0000a000
d351 1
a351 1
      emax6.lmmaddr = (emax6.ddraddr & ~(sizeof(Ull)*UNIT_WIDTH-1));
d357 1
a357 1
      emax6.lmmaddr = (emax6.ddraddr & ~(sizeof(Ull)*UNIT_WIDTH-1));
d368 1
a368 1
	emax6.lmmaddr   = (emax6.ddraddr & ~(sizeof(Ull)*UNIT_WIDTH-1));
d397 1
a397 1
    emax6_kick_dma();
d401 1
a401 1
emax6_kick_dma()
d404 3
a406 1
#if defined(FPDDMA)
d457 1
a457 2
#else // correspond pio transaction
  Ull pio_loop;
d460 2
a461 2
        //printf("(emax6.lmmaddr + pio_loop):0x%016x\n",((Ull*)emax6.lmmaddr + pio_loop));
        *((Ull*)emax6.lmmaddr + pio_loop) = *((Ull*)emax6.ddraddr + pio_loop);
d466 2
a467 2
        //printf("(emax6.ddraddr + pio_loop):0x%016x\n",((Ull*)emax6.ddraddr + pio_loop));
        *((Ull*)emax6.ddraddr + pio_loop) = *((Ull*)emax6.lmmaddr + pio_loop);
@


1.70
log
@*** empty log message ***
@
text
@d130 12
a141 12
  struct {Ull ea0b :18; /* ea0 base   */
          Ull dmy0 :14;
          Ull ea0o :18; /* ea0 offset */
          Ull dmy1 :14;
          Ull ea1b :18; /* ea1 base   */
          Ull dmy2 :14;
          Ull ea1o :18; /* ea1 offset */
          Ull dmy3 :14;
          Ull top  :31; /* LMM-top virtual-address */
          Ull dmy4 : 1;
          Ull bot  :31; /* LMM-bot virtual-address */
          Ull dmy5 : 1;
d223 1
a223 1
#define EMAX_DEVNAME "/dev/emax6_zynq_drv"
a263 1
  ((struct reg_ctrl*)emax_info.reg_mmap)->cmd = CMD_RESET;  // ★★★ RESET
d398 1
a398 1

d449 15
@


1.69
log
@*** empty log message ***
@
text
@d264 1
a264 1
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_CMD)  = 1LL;  // ★★★ RESET
@


1.68
log
@*** empty log message ***
@
text
@d7 142
d172 4
a175 15
  Ull   rw                    ; /* 0:load(mem->lmm), 1:store(lmm->mem)                               */
  Ull   araddr                ; /* read-address  of mm      v   v   v   v           v                */
  Ull   arlen                 ; /* read-length   of mm      v   v   v   v           1                */
  Ull   awaddr                ; /* write-address of mm                      v                        */
  Ull   awlen                 ; /* write-length  of mm                      v                        */
  Ull   lmm_fmask          : 4; /* mask for first 32B-chunk                                           */
  Ull   lmm_lmask          : 4; /* mask for last  32B-chunk                                           */
  Ull   lmm_nreq              ; /* number of LMM cycles                                               */
  Ull   lmwa                  ; /* -> ea0dr                     v       v                            */
  Ull   lmra                  ; /* -> ea1dr                                 v                        */
  Ull   axi_araddr            ; /* aligned-address of mm    v   v   v   v           v                */
  Ull   axi_arlen             ; /* aligned-length  of mm    v   v   v   v           1                */
  Ull   axi_awaddr            ; /* aligned-address of mm                    v                        */
  Ull   axi_awlen             ; /* aligned-length  of mm                    v                        */
  Ull   axi_wstrb          :32; /* axi byte-enable for 32B                                           */
d345 3
a347 12
      emax6.awaddr = (mode==0)?emax6.lmmi[emax6.lmmio][i][j].top:emax6.lmmi[emax6.lmmic][i][j].top; /* address should be 8B-aligned */
      emax6.awlen  = (mode==0)?emax6.lmmi[emax6.lmmio][i][j].len:emax6.lmmi[emax6.lmmic][i][j].len; /* length should be # of dwords */
      emax6.lmra   = (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1));
      emax6.lmm_fmask = 0xf << ( (emax6.awaddr/sizeof(Ull)            ) & (UNIT_WIDTH-1));
      emax6.lmm_lmask = 0xf >> (~(emax6.awaddr/sizeof(Ull)+emax6.awlen) & (UNIT_WIDTH-1));
      emax6.lmm_nreq  = ((emax6.awaddr/sizeof(Ull)+emax6.awlen)/UNIT_WIDTH) - ((emax6.awaddr/sizeof(Ull))/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
      emax6.axi_awaddr = emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1);
      emax6.axi_awlen  = emax6.lmm_nreq;
      if (emax6.lmm_nreq==0) {
	emax6.lmm_fmask &= emax6.lmm_lmask;
	emax6.lmm_lmask &= emax6.lmm_fmask;
      }
d351 3
a353 12
      emax6.awaddr = emax6.lmmi[emax6.lmmic][i][j].top+(Sll)(int)emax6.lmmi[emax6.lmmic][i][j].ofs; /* ★★★PDRAIN address should be 8B-aligned */
      emax6.awlen  = emax6.lmmi[emax6.lmmic][i][j].len; /* length should be # of dwords */
      emax6.lmra   = (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1));
      emax6.lmm_fmask = 0xf << ( (emax6.awaddr/sizeof(Ull)            ) & (UNIT_WIDTH-1));
      emax6.lmm_lmask = 0xf >> (~(emax6.awaddr/sizeof(Ull)+emax6.awlen) & (UNIT_WIDTH-1));
      emax6.lmm_nreq  = ((emax6.awaddr/sizeof(Ull)+emax6.awlen)/UNIT_WIDTH) - ((emax6.awaddr/sizeof(Ull))/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
      emax6.axi_awaddr = emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1);
      emax6.axi_awlen  = emax6.lmm_nreq;
      if (emax6.lmm_nreq==0) {
	emax6.lmm_fmask &= emax6.lmm_lmask;
	emax6.lmm_lmask &= emax6.lmm_fmask;
      }
d360 1
a360 1
	  emax6.araddr = emax6.lmmi[emax6.lmmic][i][j].top; /* address should be 8B-aligned */
d362 3
a364 12
	  emax6.araddr = emax6.lmmi[emax6.lmmic][i][j].top+(Sll)(int)emax6.lmmi[emax6.lmmic][i][j].ofs; /* ★★★PLOAD address should be 8B-aligned */
	emax6.arlen    = emax6.lmmi[emax6.lmmic][i][j].len; /* length should be # of dwords */
	emax6.lmwa     = (emax6.araddr & ~(sizeof(Ull)*UNIT_WIDTH-1));
	emax6.lmm_fmask = 0xf << ( (emax6.araddr/sizeof(Ull)             ) & (UNIT_WIDTH-1));
	emax6.lmm_lmask = 0xf >> (~(emax6.araddr/sizeof(Ull)+emax6.arlen) & (UNIT_WIDTH-1));
	emax6.lmm_nreq  = ((emax6.araddr/sizeof(Ull)+emax6.arlen)/UNIT_WIDTH) - ((emax6.araddr/sizeof(Ull))/UNIT_WIDTH); /* 0:1cycle, 1:2cycle */
	emax6.axi_araddr = emax6.araddr & ~(sizeof(Ull)*UNIT_WIDTH-1);
	emax6.axi_arlen  = emax6.lmm_nreq;
	if (emax6.lmm_nreq==0) {
	  emax6.lmm_fmask &= emax6.lmm_lmask;
	  emax6.lmm_lmask &= emax6.lmm_fmask;
	}
d380 3
a382 8
	emax6.araddr    = emax6.plist; /* address should be 8B-aligned */
	emax6.arlen     = (emax6.lmmblklen<emax6.blksize)?emax6.lmmblklen:emax6.blksize-1;
	emax6.lmwa      = emax6.lmmblktop;
	emax6.lmm_fmask = 0xf;
	emax6.lmm_lmask = 0xf;
	emax6.lmm_nreq  = emax6.arlen/UNIT_WIDTH; /* 0:1cycle, 1:2cycle */
	emax6.axi_araddr= emax6.araddr;
	emax6.axi_arlen = emax6.lmm_nreq;
d417 6
a422 6
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD0 = (Uint)((emax6.araddr-emax_info.ddr_mmap+emax_info.ddr_phys));     /* address should be 8B-aligned */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD1 = (Uint)((emax6.araddr-emax_info.ddr_mmap+emax_info.ddr_phys)>>32); /* address should be 8B-aligned */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.arlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD0 = (Uint)((emax6.lmwa  -emax_info.ddr_mmap+emax_info.lmm_phys));     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD1 = (Uint)((emax6.lmwa  -emax_info.ddr_mmap+emax_info.lmm_phys)>>32); /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD2 = (emax6.arlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
d425 6
a430 6
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD0 = (Uint)((emax6.lmra  -emax_info.ddr_mmap+emax_info.lmm_phys));     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD1 = (Uint)((emax6.lmra  -emax_info.ddr_mmap+emax_info.lmm_phys)>>32); /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.awlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD0 = (Uint)((emax6.awaddr-emax_info.ddr_mmap+emax_info.ddr_phys));     /* address should be 8B-aligned */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD1 = (Uint)((emax6.awaddr-emax_info.ddr_mmap+emax_info.ddr_phys)>>32); /* address should be 8B-aligned */
    ((struct dma_ctrl*)emax6.dma_ctrl)->ZDMA_CH_DST_DSCR_WORD2 = (emax6.awlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
@


1.67
log
@*** empty log message ***
@
text
@d81 2
@


1.66
log
@*** empty log message ***
@
text
@d358 1
a358 1
emax6_start_with_keep_cache(struct dma_ctrl *dma_ctrl, struct reg_ctrl *reg_ctrl)
d362 1
a362 1
  emax_start_with_keep_cache(dma_ctrl, reg_ctrl); /* start syscall EMAX6 */
d365 1
a365 1
  ((struct reg_ctrl*)emax6.reg_ctrl)->cmd = 3LL; // START
d370 1
a370 1
emax6_start_with_drain_cache(struct dma_ctrl *dma_ctrl, struct reg_ctrl *reg_ctrl)
d374 1
a374 1
  emax_start_with_drain_cache(dma_ctrl, reg_ctrl); /* start syscall EMAX6 */
d377 1
a377 1
  ((struct reg_ctrl*)emax6.reg_ctrl)->cmd = 3LL; // START
@


1.65
log
@*** empty log message ***
@
text
@a14 1
  Ull   retval            : 2; /* 0:normal_end, 1:require L2$invalidation, 2:busy */
a15 3
  Ull   last_dist         : 6; /* latest map_dist */
  Ull   last_row0         : 6; /* physical top of logical unit[][0] */
  Ull   row_count         : 8; /* valid row counter is 6bit */
@


1.64
log
@*** empty log message ***
@
text
@d8 2
a9 9
  volatile struct dma_ctrl *dma_ctrl;  /* DMA control */
  volatile Ull   reg_stat;  /* lmm_mmap+EXI_S_ADDR_STAT */
  volatile Ull   reg_cmd;   /* lmm_mmap+EXI_S_ADDR_CMD */
  volatile Ull   reg_adtr;  /* lmm_mmap+EXI_S_ADDR_ADTR */
  volatile Ull   reg_conf;  /* lmm_mmap+EXI_S_ADDR_CONF */
  volatile struct reg_breg *reg_breg;  /* lmm_mmap+EXI_S_ADDR_BREG */
  volatile struct reg_addr *reg_addr;  /* lmm_mmap+EXI_S_ADDR_ADDR */
  volatile struct lddmr    *reg_lddmr; /* lmm_mmap+EXI_S_ADDR_LDDMQ/TRANS-R */
  volatile struct lddmw    *reg_lddmw; /* lmm_mmap+EXI_S_ADDR_LDDMQ-W */
a86 8
#define EXI_S_ADDR_STAT  0x00000000
#define EXI_S_ADDR_CMD   0x00000010
#define EXI_S_ADDR_ADTR  0x00000020
#define EXI_S_ADDR_CONF  0x00002000
#define EXI_S_ADDR_BREG  0x00004000
#define EXI_S_ADDR_ADDR  0x00006000
#define EXI_S_ADDR_LDDMR 0x00008000
#define EXI_S_ADDR_LDDMW 0x00008000
d320 6
a325 6
    emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD0 = (Uint)((emax6.araddr-emax_info.ddr_mmap+emax_info.ddr_phys));     /* address should be 8B-aligned */
    emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD1 = (Uint)((emax6.araddr-emax_info.ddr_mmap+emax_info.ddr_phys)>>32); /* address should be 8B-aligned */
    emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.arlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
    emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD0 = (Uint)((emax6.lmwa  -emax_info.ddr_mmap+emax_info.lmm_phys));     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD1 = (Uint)((emax6.lmwa  -emax_info.ddr_mmap+emax_info.lmm_phys)>>32); /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD2 = (emax6.arlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
d328 6
a333 6
    emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD0 = (Uint)((emax6.lmra  -emax_info.ddr_mmap+emax_info.lmm_phys));     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD1 = (Uint)((emax6.lmra  -emax_info.ddr_mmap+emax_info.lmm_phys)>>32); /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
    emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.awlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
    emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD0 = (Uint)((emax6.awaddr-emax_info.ddr_mmap+emax_info.ddr_phys));     /* address should be 8B-aligned */
    emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD1 = (Uint)((emax6.awaddr-emax_info.ddr_mmap+emax_info.ddr_phys)>>32); /* address should be 8B-aligned */
    emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD2 = (emax6.awlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
d342 1
a342 1
  emax6.dma_ctrl->ZDMA_CH_CTRL2 = 1;
d344 1
a344 1
    status = emax6.dma_ctrl->ZDMA_CH_STATUS & 3;
d362 1
a362 1
emax6_start_with_keep_cache(volatile int (*conf_top)(), struct emax6 *emax6)
d366 1
a366 1
  emax_start_with_keep_cache(emax6); /* start syscall EMAX6 */
d369 1
a369 1
  *(Ull*)(emax6.reg_cmd) = 3LL; // START
d374 1
a374 1
emax6_start_with_drain_cache(volatile int (*conf_top)(), struct emax6 *emax6)
d378 1
a378 1
  emax_start_with_drain_cache(emax6); /* start syscall EMAX6 */
d381 1
a381 1
  *(Ull*)(emax6.reg_cmd) = 3LL; // START
@


1.63
log
@*** empty log message ***
@
text
@d90 2
a91 2
#define DMA_BASE2_PHYS	 0x000000004ff00000LL
#define REG_BASE2_PHYS	 0x000000004ff10000LL
@


1.62
log
@*** empty log message ***
@
text
@d8 9
a16 9
  struct dma_ctrl *dma_ctrl;  /* DMA control */
  Ull   reg_stat;  /* lmm_mmap+EXI_S_ADDR_STAT */
  Ull   reg_cmd;   /* lmm_mmap+EXI_S_ADDR_CMD */
  Ull   reg_adtr;  /* lmm_mmap+EXI_S_ADDR_ADTR */
  Ull   reg_conf;  /* lmm_mmap+EXI_S_ADDR_CONF */
  struct reg_breg *reg_breg;  /* lmm_mmap+EXI_S_ADDR_BREG */
  struct reg_addr *reg_addr;  /* lmm_mmap+EXI_S_ADDR_ADDR */
  struct lddmr    *reg_lddmr; /* lmm_mmap+EXI_S_ADDR_LDDMQ/TRANS-R */
  struct lddmw    *reg_lddmw; /* lmm_mmap+EXI_S_ADDR_LDDMQ-W */
d168 1
d310 7
d318 49
a366 63
    /* kick dma_ctrl (Simple Mode) */
    /* 1. ZDMA_CH_STATUS レジスタを読み出し、STATEが00または11(DMAがIDLEステート) になるまで待つ. */
    /*    DMAがPAUSEステートの場合、「チャネル一時停止」で説明する手順に従って PAUSE ステートを終了. */
    {
      Uint status;
      do {
	status = emax6.dma_ctrl->ZDMA_CH_STATUS & 3;
      } while (status != 0 && status != 3);
      switch (status) {
      case 0:
	break;
      default: /* case 3 */
	printf("emax6_check_lmmi_and_dma(pre): ZDMA_CH_STATUS=%d (malfunction)\n", status);
	return (0);
      }
    }
    /* 2. ZDMA_CH_CTRL0レジスタの POINT_TYPE (ビット 6) を 0 に設定 */
    /*    データソースバッファのアドレスの LSB を ZDMA_CH_SRC_DSCR_WORD0レジスタに書き込む */
    /*    データソースバッファのアドレスの MSB を ZDMA_CH_SRC_DSCR_WORD1レジスタに書き込む */
    /* 3. データデスティネーションバッファのアドレスの LSB を ZDMA_CH_DST_DSCR_WORD0レジスタに書き込む */
    /*    データデスティネーションバッファのアドレスの MSB を ZDMA_CH_DST_DSCR_WORD1レジスタに書き込む */
    /* 4. Simple Modeでは、SRCトランザクションサイズとDSTトランザクションサイズの両方を設定する必要がある */
    /*    DMA は SRCトランザクションサイズを使用しますが、両方のレジスタを設定しておく必要がある */
    /*    ZDMA_CH_SRC_DSCR_WORD2 レジスタにソースデータサイズを書き込む */
    /*    ZDMA_CH_DST_DSCR_WORD2 レジスタにデスティネーショントランザクションサイズを書き込む */
    /*    SRCトランザクションサイズとDSTトランザクションサイズは必ず同じ */
    if (emax6.rw == 0) { /* mem->lmm */
      emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD0 = (Uint)((emax6.araddr-emax_info.ddr_mmap+emax_info.ddr_phys));     /* address should be 8B-aligned */
      emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD1 = (Uint)((emax6.araddr-emax_info.ddr_mmap+emax_info.ddr_phys)>>32); /* address should be 8B-aligned */
      emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.arlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
      emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD0 = (Uint)((emax6.lmwa  -emax_info.ddr_mmap+emax_info.lmm_phys));     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
      emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD1 = (Uint)((emax6.lmwa  -emax_info.ddr_mmap+emax_info.lmm_phys)>>32); /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
      emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD2 = (emax6.arlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
    }
    else { /* lmm->mem */
      emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD0 = (Uint)((emax6.lmra  -emax_info.ddr_mmap+emax_info.lmm_phys));     /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
      emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD1 = (Uint)((emax6.lmra  -emax_info.ddr_mmap+emax_info.lmm_phys)>>32); /* (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) */
      emax6.dma_ctrl->ZDMA_CH_SRC_DSCR_WORD2 = (emax6.awlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
      emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD0 = (Uint)((emax6.awaddr-emax_info.ddr_mmap+emax_info.ddr_phys));     /* address should be 8B-aligned */
      emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD1 = (Uint)((emax6.awaddr-emax_info.ddr_mmap+emax_info.ddr_phys)>>32); /* address should be 8B-aligned */
      emax6.dma_ctrl->ZDMA_CH_DST_DSCR_WORD2 = (emax6.awlen+1)*sizeof(Ull);                                      /* length should be # of dwords */
    }
    /* 5. 必要に応じ,ZDMA_CH_DST_DSCR_WORD3およびZDMA_CH_SRC_DSCR_WORD3レジスタでINTRを1にセットし割り込みを有効にする */
    /* 6. ソースおよびデスティネーションバッファがキャッシュコヒーレントとして割り当てられているかフラッシュされている場合, */
    /*    COHRNTをセットする必要はない. それ以外の場合,ソースおよびデスティネーションバッファがキャッシュコヒーレントとして */
    /*    割り当てられていない、またはフラッシュされていない場合、ZDMA_CH_SRC_DSCR_WORD3およびZDMA_CH_DST_DSCR_WORD3レジスタで */
    /*    それぞれ COHRNTをセットする. COHRNTビットは LPD-DMA の場合のみ有効. FPD-DMAはコヒーレンシをサポートしない. */
    /* 7. ZDMA_CH_CTRL2レジスタのENビットをセットして,DMA転送に使用するDMAチャネルを有効にする. */
    /*    DMAを有効にした後、「エラー条件」に示すエラー条件をチェックする. */
    emax6.dma_ctrl->ZDMA_CH_CTRL2 = 1;
    {
      Uint status;
      do {
	status = emax6.dma_ctrl->ZDMA_CH_STATUS & 3;
      } while (status != 0 && status != 3);
      switch (status) {
      case 0:
	break;
      default: /* case 3 */
	printf("emax6_check_lmmi_and_dma(post): ZDMA_CH_STATUS=%d (malfunction)\n", status);
	return (0);
      }
    }
d368 2
d399 1
@


1.61
log
@*** empty log message ***
@
text
@d310 63
a372 2
    /* kick dma_ctrl */

d381 1
a381 1
emax6_start_with_keep_cache(Ull conf_top, struct emax6 *emax6)
d393 1
a393 1
emax6_start_with_drain_cache(Ull conf_top, struct emax6 *emax6)
@


1.60
log
@*** empty log message ***
@
text
@d34 1
a34 1
  Ull   blkstat           : 1; /* 0:PTRLIST 1:VERTEXLIST */
a36 1
  Ull   blktop[UNIT_WIDTH]   ; /* block address */
d41 15
a55 8
  Uint  ardyc                 ; /* LMM addr-ready(read)                                               */
  Uint  rrdyc                 ; /* LMM data-ready(read), AXI data-ready(rvalid) counter               */
  Ull   araddr                ; /* read-address  of mm      v   v   v   v           v                 */
  Ull   arlen                 ; /* read-length   of mm      v   v   v   v           1                 */
  Ull   awaddr                ; /* write-address of mm                      v                         */
  Ull   awlen                 ; /* write-length  of mm                      v                         */
  Ull   lmwa                  ; /* -> ea0dr                     v       v                             */
  Ull   lmra                  ; /* -> ea1dr                                 v                         */
d80 3
d120 2
d152 4
d174 1
d200 3
a202 3
    if      ((lmmo_stat==12 && lmmc_stat!=13) && emax6.lmmd[i][j]) mark = 1; /* ●2 lmw&!lmd drain */
    else if ((lmmo_stat==14                 ) && emax6.lmmd[i][j]) mark = 1; /* ●4 lmx      drain */
    else                                                           mark = 0;
d205 2
a206 2
    if (                                         emax6.lmmd[i][j]) mark = 1; /* ☆  drain_dirty_lmm */
    else                                                           mark = 0;
d209 5
a213 4
    if      (lmmc_stat== 8               && !lmm_ready)  mark = 1; /* ●1 lmr & !ready */
    else if (lmmc_stat== 9 && !lmmc_ofsz && !lmm_readz)  mark = 1; /* ●7 lmr & !readz */
    else if (lmmc_stat==10 || lmmc_stat==14)             mark = 1; /* ●3 lmf/lmx always load */
    else                                                 mark = 0; /* skip load */
d216 3
a218 2
    if      (lmmc_stat== 9                    )          mark = 1; /* ●5 lmp */
    else if (lmmc_stat==13 && emax6.lmmd[i][j])          mark = 1; /* ●6 lmd & dirty */
d220 2
a221 2
//  else if (lmmc_stat==11                    )          mark = 1; /*     LDDMQ */
//  else if (lmmc_stat==15                    )          mark = 1; /*     TR */
d223 1
a223 1
    else                                                 mark = 0; /* skip pdrain/pload */
a227 3
    emax6.ardyc = 0;
    emax6.rrdyc = 0;
#if 1
d229 1
d232 10
a241 1
      emax6.lmra   = (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) + emax6.ardyc*sizeof(Ull)*UNIT_WIDTH;
d244 1
d247 10
a256 1
      emax6.lmra   = (emax6.awaddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) + emax6.ardyc*sizeof(Ull)*UNIT_WIDTH;
d260 1
d267 10
a276 1
	emax6.lmwa     = (emax6.araddr & ~(sizeof(Ull)*UNIT_WIDTH-1)) + emax6.rrdyc*sizeof(Ull)*UNIT_WIDTH;
d283 8
a290 19
	switch (emax6.blkstat) {
	case 0: /* PTRLIST */
	  if (phase == 2) /* load */
	    emax6.araddr = emax6.lmmi[emax6.lmmic][i][j].top+emax6.blkcount/4*32; /* address should be 8B-aligned */
	  else
	    emax6.araddr = emax6.lmmi[emax6.lmmic][i][j].top+emax6.blkcount/4*32+(Sll)(int)emax6.lmmi[emax6.lmmic][i][j].ofs; /* ★★★PLOAD address should be 8B-aligned */
	  emax6.arlen    = 3; /* 4 dwords */
	  emax6.blksize  = 32<<emax6.lmmi[emax6.lmmic][i][j].blk; /* max:10bit */
	  if (emax6.blkcount==0) {
	    emax6.lmmblktop = 0; /* ★★★先頭アドレスが0なので,addr_rangeに工夫が必要 */
	    emax6.lmmblklen = emax6.lmmi[emax6.lmmic][i][j].len; /* length should be # of dwords */
	  }
	  break;
	case 1: /* VERTEXLIST */
	  emax6.araddr    = emax6.blktop[emax6.blkcount%4]; /* address should be 8B-aligned */
	  emax6.arlen     = (emax6.lmmblklen<emax6.blksize)?emax6.lmmblklen:emax6.blksize-1;
	  emax6.lmwa      = emax6.lmmblktop + emax6.rrdyc*sizeof(Ull)*UNIT_WIDTH;
	  emax6.lmmblklen = (emax6.lmmblklen<emax6.blksize)?0:(emax6.lmmblklen-emax6.blksize);
	  break;
d292 14
d309 3
a311 1
#endif
d327 1
a327 10
  volatile Ull emax_status;

  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_CONF) = emax_info.acp_phys+(conf-emax_info.acp_mmap);
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_LMMI) = emax_info.acp_phys+(lmmi-emax_info.acp_mmap);
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_REGV) = emax_info.acp_phys+(regv-emax_info.acp_mmap);
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_OFFS) = emax_info.hpp_phys - emax_info.hpp_mmap;
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_MODE) = 1LL;
  do {
    emax_status = *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_STAT);
  } while (emax_status != STATUS_IDLE);
d339 1
a339 10
  volatile Ull emax_status;

  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_CONF) = emax_info.acp_phys+(conf-emax_info.acp_mmap);
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_LMMI) = emax_info.acp_phys+(lmmi-emax_info.acp_mmap);
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_REGV) = emax_info.acp_phys+(regv-emax_info.acp_mmap);
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_OFFS) = emax_info.hpp_phys - emax_info.hpp_mmap;
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_MODE) = 1LL;
  do {
    emax_status = *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_STAT);
  } while (emax_status != STATUS_IDLE);
@


1.59
log
@*** empty log message ***
@
text
@d42 9
d168 1
a168 1
  if ((mode==0 && load_drain == 1) || (load_drain == 0)) { /* (array && drain) || load */
d183 1
a183 1
  if      (mode==0 && load_drain == 1) { /* drain */
d188 1
a188 1
  else if (mode==1 && load_drain == 1) { /* drain */
d192 1
a192 1
  else { /* load */
d198 3
a200 28

#if 0
case STATUS_DRAIN:
  if      (mode==0 && (lmmo_stat==12 && lmmc_stat!=13) && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* ●2 lmw&!lmd drain */
  else if (mode==0 && (lmmo_stat==14                 ) && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* ●4 lmx      drain */
  else if (mode==1 &&                                     emax5[cid].fsm[j].lmmd[i]) mark = 1; /* ☆  drain_dirty_lmm */
  else                                                                               mark = 0; /* skip drain */
  break;
case STATUS_LOAD:
  if      (lmmc_stat== 8               && !lmm_ready)  mark = 1; /* ●1 lmr & !ready */
  else if (lmmc_stat== 9 && !lmmc_ofsz && !lmm_readz)  mark = 1; /* ●7 lmr & !readz */
  else if (lmmc_stat==10 || lmmc_stat==14)             mark = 1; /* ●3 lmf/lmx always load */
  else                                                 mark = 0; /* skip load */
  break;
case STATUS_EXEC:
  /* ●●● OP_IM_PREF,OP_IM_DRAIN,OP_LDDMQ,OP_TRが処理対象 ●●● */
  /*  OP_IM_PREF:  ofsz=0,v=1,rw=0,f=0,p=1 lmmc_stat==9  */
  /*  OP_IM_PREF:  ofsz=1,v=1,rw=0,f=0,p=1 lmmc_stat==9  */
  /*  OP_IM_DRAIN: ofsz=0,v=1,rw=1,f=0,p=1 lmmc_stat==13 */
  /*  OP_IM_DRAIN: ofsz=1,v=1,rw=1,f=0,p=1 lmmc_stat==13 */
  /*  OP_LDDMQ:           v=1,rw=0,f=1,p=1 lmmc_stat==11 */
  /*  OP_TR:              v=1,rw=1,f=1,p=1 lmmc_stat==15 */
  /* ●●● 同一列に複数リクエストがある場合は当面考えない ●●● */
  /*  PREFとDRAINはEXEC以外でもよいが,LDDMQとTR(f=1,p=1)はEXEC時に要対応 */
  /*    ・LDDMQはAXIにRead-req送出,Data受取り,lmwd書き込み */
  /*    ・TRはEMAX制御Regにストア,ARM引き継ぎ              */
  if      (lmmc_stat== 9                             ) mark = 1; /* ●5 lmp */
  else if (lmmc_stat==13 && emax5[cid].fsm[j].lmmd[i]) mark = 1; /* ●6 lmd & dirty */
d202 2
a203 5
  else if (lmmc_stat==11                             ) mark = 1; /*     LDDMQ */
  else if (lmmc_stat==15                             ) mark = 1; /*     TR */
#endif
  else                                                 mark = 0; /* skip pdrain/pload */
  break;
d205 2
d209 23
a231 17
#if 0  
  if (emax5[cid].status==STATUS_DRAIN) { /* drain */
    awaddr = (mode==0)?emax5[cid].fsm[j].lmmo[i].top:emax5[cid].fsm[j].lmmc[i].top; /* address should be 8B-aligned */
    awlen  = (mode==0)?emax5[cid].fsm[j].lmmo[i].len:emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
  }
  else if (emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==1) { /* pdrain */
    emax5[cid].fsm[j].awaddr = emax5[cid].fsm[j].lmmc[i].top+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* ★★★PDRAIN address should be 8B-aligned */
    emax5[cid].fsm[j].awlen  = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
  }
  else if (emax5[cid].status==STATUS_LOAD                                        /* load */
        ||(emax5[cid].status==STATUS_EXEC && emax5[cid].fsm[j].lmmc[i].rw==0)) { /* pload *//* address should be 8B-aligned *//* length should be # of dwords */
    if (emax5[cid].fsm[j].lmmc[i].blk==0) { /* inf */
      if (emax5[cid].status==STATUS_LOAD)
	emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top; /* address should be 8B-aligned */
      else
	emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* ★★★PLOAD address should be 8B-aligned */
      emax5[cid].fsm[j].arlen      = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
d233 1
a233 1
      emax5[cid].fsm[j].blksize    = 0; /* max:10bit */
d235 1
a235 1
    }
d237 20
a256 12
    else { /* 16,32,64 */
      switch (emax5[cid].fsm[j].blkstat) {
      case 0: /* PTRLIST */
	if (emax5[cid].status==STATUS_LOAD)
	  emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top+emax5[cid].fsm[j].blkcount/4*32; /* address should be 8B-aligned */
	else
	  emax5[cid].fsm[j].araddr = emax5[cid].fsm[j].lmmc[i].top+emax5[cid].fsm[j].blkcount/4*32+(Sll)(int)emax5[cid].fsm[j].lmmc[i].ofs; /* ★★★PLOAD address should be 8B-aligned */
	emax5[cid].fsm[j].arlen     = 3; /* 4 dwords */
	emax5[cid].fsm[j].blksize   = 32<<emax5[cid].fsm[j].lmmc[i].blk; /* max:10bit */
	if (emax5[cid].fsm[j].blkcount==0) {
	  emax5[cid].fsm[j].lmmblktop = 0;
	  emax5[cid].fsm[j].lmmblklen = emax5[cid].fsm[j].lmmc[i].len; /* length should be # of dwords */
a257 6
	break;
      case 1: /* VERTEXLIST */
	emax5[cid].fsm[j].araddr    = emax5[cid].fsm[j].blktop[emax5[cid].fsm[j].blkcount%4]; /* address should be 8B-aligned */
	emax5[cid].fsm[j].arlen     = (emax5[cid].fsm[j].lmmblklen<emax5[cid].fsm[j].blksize)?emax5[cid].fsm[j].lmmblklen:emax5[cid].fsm[j].blksize-1;
	emax5[cid].fsm[j].lmmblklen = (emax5[cid].fsm[j].lmmblklen<emax5[cid].fsm[j].blksize)?0:(emax5[cid].fsm[j].lmmblklen-emax5[cid].fsm[j].blksize);
	break;
d259 1
a262 1
#endif
@


1.58
log
@*** empty log message ***
@
text
@a6 24
volatile struct emax_info {
  Ull  dma_phys;     // kern-phys
  Ull  dma_vadr;     // not used
  Ull  dma_mmap;     // user-virt Contiguous 64K register space
  Ull  reg_phys;     // kern-phys
  Ull  reg_vadr;     // not used
  Ull  reg_mmap;     // user-virt Contiguous 4GB space including LMM space
  Ull  ddr_phys;     // kern-phys
  Ull  ddr_vadr;     // not used
  Ull  ddr_mmap;     // user-virt Contiguous 2GB space in DDR-high-2GB space
  int  driver_use_1;
  int  driver_use_2;
} emax_info;

#define REG_BASE2_SIZE   0x0000a000
#define EXI_S_ADDR_STAT  0x00000000
#define EXI_S_ADDR_CMD   0x00000010
#define EXI_S_ADDR_ADTR  0x00000020
#define EXI_S_ADDR_CONF  0x00002000
#define EXI_S_ADDR_BREG  0x00004000
#define EXI_S_ADDR_ADDR  0x00006000
#define EXI_S_ADDR_LDDMR 0x00008000
#define EXI_S_ADDR_LDDMW 0x00008000

d8 1
d13 4
a16 4
  Ull   reg_breg;  /* lmm_mmap+EXI_S_ADDR_BREG */
  Ull   reg_addr;  /* lmm_mmap+EXI_S_ADDR_ADDR */
  Ull   reg_lddmr; /* lmm_mmap+EXI_S_ADDR_LDDMQ/TRANS-R */
  Ull   reg_lddmw; /* lmm_mmap+EXI_S_ADDR_LDDMQ-W */
d58 27
d139 132
a270 3
#if defined(EMAX6) && defined(ARMSIML)
#define REG_BASE2_PHYS	 0x000000004fc00000LL
/*  ... for ARMSIML only */
d272 1
a319 18
#if 0
emax6_drain_dirty_lmm(struct emax6 *emax6)
{
#ifdef ARMSIML
  emax_drain_dirty_lmm(emax6); /* start syscall EMAX6 */
#endif
#ifdef ARMZYNQ
  volatile Ull emax_status;

  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_OFFS) = emax_info.hpp_phys - emax_info.hpp_mmap;
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_MODE) = 2LL;
  do {
    emax_status = *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_STAT);
  } while (emax_status != STATUS_IDLE);
#endif
}
#endif

a421 1
#if 1
a425 1
#endif
@


1.57
log
@*** empty log message ***
@
text
@d26 2
a27 2
#define EXI_S_ADDR_ADDR  0x00004000
#define EXI_S_ADDR_BREG  0x00006000
d36 1
a37 1
  Ull   reg_breg;  /* lmm_mmap+EXI_S_ADDR_BREG */
d51 1
d186 1
d202 1
@


1.56
log
@*** empty log message ***
@
text
@d8 3
d13 6
a18 12
  Ull  reg_mmap;     // user-virt Contiguous 256K register space
  Ull  hpp_phys;     // kern-phys
  Ull  hpp_vadr;     // not used
  Ull  hpp_mmap;     // user-virt Contiguous 2GB space in high-2GB space
  Ull  acp_phys;     // kern-phys
  Ull  acp_vadr;     // not used
  Ull  acp_mmap;     // user-virt Contiguous 4MB space in low-2GB space
	             // 0x1fffff-0x000000: for conf[ 8KB] * 256sets
	             // 0x2fffff-0x200000: for lmmi[ 4KB] * 1set
        	     // 0x3fffff-0x300000: for regv[16KB] * 1set
  int driver_use_1;
  int driver_use_2;
d21 58
a78 7
volatile Ull  acp_conf;                   /* acp_mmap+0x000000+8KB*i (L1miss*1回のためACPでOK) */
volatile Ull  acp_lmmi;                   /* acp_mmap+0x200000        L1=32KB */
volatile Ull  acp_regv;                   /* acp_mmap+0x304000        L1=32KB */
volatile struct {
  int v;   /* 0:acp_conf is empty, 1:copied from text to acp_conf */
  Ull top; /* conf_address in text-segment */
} acp_conf_tab[ACP_CONF_MAX];
d89 5
a93 6
struct emax_ioctlbuf {
  Ull phys_addr;
  Ull virt_addr;
} emax_ioctlbuf;

#define REG_BASE_PHYS	 0x0000000080000000LL
d95 3
a97 3
#define REG_BASE_SIZE	 0x0000000000040000LL
/*  ... 256KB */
#define HPP_BASE_PHYS	 0x0000000800000000LL
d99 1
a99 1
#define HPP_BASE_SIZE	 0x0000000080000000LL
a100 10
#define ACP_BASE_SIZE	 0x0000000000400000LL
/*  ... 4MB   */

#define EXI_S_ADDR_RESET 0x0000000000030000LL
#define EXI_S_ADDR_CONF  0x0000000000030010LL
#define EXI_S_ADDR_LMMI  0x0000000000030018LL
#define EXI_S_ADDR_REGV  0x0000000000030020LL
#define EXI_S_ADDR_OFFS  0x0000000000030028LL
#define EXI_S_ADDR_MODE  0x0000000000030030LL
#define EXI_S_ADDR_STAT  0x0000000000030040LL
d119 2
a120 4
  emax_info.reg_phys = REG_BASE_PHYS;
  emax_info.reg_mmap = (Ull)mmap(0,REG_BASE_SIZE,PROT_READ|PROT_WRITE,MAP_SHARED,emax_fd,REG_BASE_PHYS);
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_MODE)  = 0LL; // ★★★ CLEAR COMMAND
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_RESET) = 1LL; // ★★★ RESET EMAX6
d123 3
a125 2
  emax_info.hpp_phys = HPP_BASE_PHYS;
  emax_info.hpp_mmap = (Ull)mmap(0,HPP_BASE_SIZE,PROT_READ|PROT_WRITE,MAP_SHARED,emax_fd,HPP_BASE_PHYS);
d128 2
a129 5
  emax_ioctlbuf.phys_addr = 0x0; // phys
  emax_ioctlbuf.virt_addr = 0x0; // virt
  ioctl(emax_fd, EMAX_GET_ACPMEM, &emax_ioctlbuf);//in driver:virt=(Ull*)kmalloc(ACP_MEM_SIZE(<=4MB),GFP_KERNEL);
  emax_info.acp_phys = emax_ioctlbuf.phys_addr;   //in driver:phys=(Ull)virt_to_phys(buf);
  emax_info.acp_mmap = (Ull)mmap(0,ACP_BASE_SIZE,PROT_READ|PROT_WRITE,MAP_SHARED,emax_fd,emax_ioctlbuf.phys_addr);
d135 1
a135 1
#define ACP_BASE_PHYS	 0x000000004fc00000LL
d144 1
a144 1
emax6_start_with_keep_cache(Ull conf, Ull lmmi, Ull regv)
d146 1
d148 1
a148 1
  emax_start_with_keep_cache(conf, lmmi, regv); /* start syscall EMAX6 */
d165 1
a165 1
emax6_start_with_drain_cache(Ull conf, Ull lmmi, Ull regv)
d167 1
d169 1
a169 1
  emax_start_with_drain_cache(conf, lmmi, regv); /* start syscall EMAX6 */
d185 1
a185 1
emax6_drain_dirty_lmm()
d188 1
a188 1
  emax_drain_dirty_lmm(); /* start syscall EMAX6 */
@


1.55
log
@*** empty log message ***
@
text
@d167 1
a167 1
/******************************** EMAX6 NCLIB (no conv-c2e)*********************/
@


1.54
log
@*** empty log message ***
@
text
@d101 1
a101 1
#if defined(EMAX) && defined(ARMSIML)
d116 1
a116 1
#ifdef EMAX6ASIC
a127 4
#ifdef EMAX6SIML
  /* ZYNQnative+EMAXsiml : -DEMAX6 -DEMAX) emax6_start->inline emax6siml (N.A.) */
  /* emax_siml is required here */
#endif
d136 1
a136 1
#ifdef EMAX6ASIC
a147 4
#ifdef EMAX6SIML
  /* ZYNQnative+EMAXsiml : -DEMAX6 -DEMAX) emax6_start->inline emax6siml (N.A.) */
  /* emax_siml is required here */
#endif
d155 1
a155 1
#ifdef EMAX6ASIC
a163 4
#ifdef EMAX6SIML
  /* ZYNQnative+EMAXsiml : -DEMAX6 -DEMAX) emax6_start->inline emax6siml (N.A.) */
  /* emax_siml is required here */
#endif
@


1.53
log
@*** empty log message ***
@
text
@d2 1
a2 1
/* EMAX5 library                        */
d38 1
a38 1
#define EMAX_DEVNAME "/dev/emax5_zynq_drv"
d71 1
a71 1
emax5_open()
d85 1
a85 1
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_RESET) = 1LL; // ★★★ RESET EMAX5
d107 1
a107 1
/******************************** EMAX5-START **********************************/
d111 1
a111 1
emax5_start_with_keep_cache(Ull conf, Ull lmmi, Ull regv)
d114 1
a114 1
  emax_start_with_keep_cache(conf, lmmi, regv); /* start syscall EMAX5 */
d116 1
a116 1
#ifdef EMAX5ASIC
d128 2
a129 2
#ifdef EMAX5SIML
  /* ZYNQnative+EMAXsiml : -DEMAX5 -DEMAX) emax5_start->inline emax5siml (N.A.) */
d135 1
a135 1
emax5_start_with_drain_cache(Ull conf, Ull lmmi, Ull regv)
d138 1
a138 1
  emax_start_with_drain_cache(conf, lmmi, regv); /* start syscall EMAX5 */
d140 1
a140 1
#ifdef EMAX5ASIC
d152 2
a153 2
#ifdef EMAX5SIML
  /* ZYNQnative+EMAXsiml : -DEMAX5 -DEMAX) emax5_start->inline emax5siml (N.A.) */
d158 1
a158 1
emax5_drain_dirty_lmm()
d161 1
a161 1
  emax_drain_dirty_lmm(); /* start syscall EMAX5 */
d163 1
a163 1
#ifdef EMAX5ASIC
d172 2
a173 2
#ifdef EMAX5SIML
  /* ZYNQnative+EMAXsiml : -DEMAX5 -DEMAX) emax5_start->inline emax5siml (N.A.) */
d179 1
a179 1
/******************************** EMAX5 NCLIB (no conv-c2d)*********************/
d203 1
a203 1
    printf("emax5lib: cex: undefined op_cx=%d\n", op_cx);
d222 1
a222 1
    printf("emax5lib: ex4: undefined op_ex1=%d\n", op_ex1);
d235 1
a235 1
    printf("emax5lib: ex4: illegal op_ex2=%d\n", op_ex2);
d243 1
a243 1
    printf("emax5lib: ex4: illegal op_ex3=%d\n", op_ex3);
d279 1
a279 1
  case OP_WHILE: /* emax5ncのlibとしては使用せず,bsim/emax5.cがsimlに使用 */
d599 1
a599 1
    printf("emax5lib: exe: undefined op_ex1=%d\n", op_ex1);
d642 1
a642 1
    printf("emax5lib: exe: undefined op_ex2=%d\n", op_ex2);
d688 1
a688 1
    printf("emax5lib: exe: undefined op_ex3=%d\n", op_ex3);
d744 1
a744 1
    printf("emax5lib: eag: undefined msk=%d\n", msk);
d872 1
a872 1
    printf("emax5lib: mmp: undefined op_mm=%d\n", op_mm);
@


1.52
log
@*** empty log message ***
@
text
@d110 2
a111 1
emax5_start(Ull conf, Ull lmmi, Ull regv)
d114 25
a138 1
  emax_start(conf, lmmi, regv); /* start syscall EMAX5 */
@


1.51
log
@*** empty log message ***
@
text
@d101 4
@


1.50
log
@*** empty log message ***
@
text
@d793 4
a796 4
      *(d+0) = *((Ull*)(adr&~7LL)+0);
      *(d+1) = *((Ull*)(adr&~7LL)+1);
      *(d+2) = *((Ull*)(adr&~7LL)+2);
      *(d+3) = *((Ull*)(adr&~7LL)+3);
d823 4
a826 4
      *(d+0) = *((Ull*)(adr&~7LL)+0);
      *(d+1) = *((Ull*)(adr&~7LL)+1);
      *(d+2) = *((Ull*)(adr&~7LL)+2);
      *(d+3) = *((Ull*)(adr&~7LL)+3);
d830 4
a833 4
    *((Ull*)(adr&~7LL)+0) = *(d+0);
    *((Ull*)(adr&~7LL)+1) = *(d+1);
    *((Ull*)(adr&~7LL)+2) = *(d+2);
    *((Ull*)(adr&~7LL)+3) = *(d+3);
@


1.49
log
@*** empty log message ***
@
text
@d728 1
a728 1
  mmp(op_mm, ex, d, adr, top);
d737 1
a737 1
  mmp(op_mm, ex, d, adr, top);
d741 1
a741 1
mmp(Uint op_mm, Ull ex, Ull *d, Ull adr, Ull top)
d790 30
a819 4
    *(d+0) = *((Ull*)(adr&~7LL)+0);
    *(d+1) = *((Ull*)(adr&~7LL)+1);
    *(d+2) = *((Ull*)(adr&~7LL)+2);
    *(d+3) = *((Ull*)(adr&~7LL)+3);
@


1.48
log
@*** empty log message ***
@
text
@d728 1
a728 1
  mmp(op_mm, ex, d, adr);
d737 1
a737 1
  mmp(op_mm, ex, d, adr);
d741 1
a741 1
mmp(Uint op_mm, Ull ex, Ull *d, Ull adr)
d812 1
a812 1
      Ull (*trans)() = adr;
@


1.47
log
@*** empty log message ***
@
text
@d723 1
a723 1
mop(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint blk, Uint len, Uchar force, Ull ptop)
d732 1
a732 1
mo4(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint blk, Uint len, Uchar force, Ull ptop)
@


1.46
log
@*** empty log message ***
@
text
@d7 1
a7 1
struct emax_info {
d24 4
a27 4
Ull  acp_conf;                   /* acp_mmap+0x000000+8KB*i (L1miss*1回のためACPでOK) */
Ull  acp_lmmi;                   /* acp_mmap+0x200000        L1=32KB */
Ull  acp_regv;                   /* acp_mmap+0x304000        L1=32KB */
struct {
d84 2
a85 1
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_RESET) = 0x1LL; // ★★★ RESET EMAX5
d112 1
a112 1
  Ull emax_status;
d117 1
a117 1
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_OFFS) = emax_info.hpp_phys - emax_info.hpp_vadr;
d135 1
a135 1
  Ull emax_status;
d137 1
a137 1
  *(Ull*)(emax_info.reg_mmap+EXI_S_ADDR_OFFS) = emax_info.hpp_phys - emax_info.hpp_vadr;
@


1.45
log
@*** empty log message ***
@
text
@a772 3
  case OP_LDBF: /* 64bit buffered LMM is used as a buffer */
    *d = *(Ull*)(adr&~7LL);
    break;
a785 4
  case OP_STBF: /* 64bit buffered LMM is used as a buffer */
    if (c1) *((Uint*)(adr&~7LL)+1) = *d>>32;
    if (c0) *((Uint*)(adr&~7LL)  ) = *d;
    break;
a793 7
  case OP_LDBFQ: /* 64bit*4 buffered LMM is used as a buffer */
/*case OP_IM_DRAIN: /* 64bit*4 drain */
    *(d+0) = *((Ull*)(adr&~7LL)+0);
    *(d+1) = *((Ull*)(adr&~7LL)+1);
    *(d+2) = *((Ull*)(adr&~7LL)+2);
    *(d+3) = *((Ull*)(adr&~7LL)+3);
    break;
a807 7
  case OP_STBFQ: /* 64bit*4 buffered LMM is used as a buffer */
/*case OP_IM_PREF: /* 64bit*4 prefetch */
    *((Ull*)(adr&~7LL)+0) = *(d+0);
    *((Ull*)(adr&~7LL)+1) = *(d+1);
    *((Ull*)(adr&~7LL)+2) = *(d+2);
    *((Ull*)(adr&~7LL)+3) = *(d+3);
    break;
@


1.44
log
@*** empty log message ***
@
text
@d37 1
d46 10
a55 5
#define REG_BASE_PHYS	 0x0000000080000000LL ... fixed
#define REG_BASE_SIZE	 0x0000000000040000LL ... 256KB
#define HPP_BASE_PHYS	 0x0000000800000000LL ... fixed
#define HPP_BASE_SIZE	 0x0000000080000000LL ... 2GB
#define ACP_BASE_SIZE	 0x0000000000400000LL ... 4MB
d65 6
d84 1
a84 1
  (Ull*)(emax_info.reg_mmap+EXI_S_ADDR_RESET) = 0x1LL); // ★★★ RESET EMAX5
d113 5
a117 5
  (Ull*)(emax_info.reg_mmap+EXI_S_ADDR_CONF) = emax_info.acp_phys+(conf-emax_info.acp_mmap);
  (Ull*)(emax_info.reg_mmap+EXI_S_ADDR_LMMI) = emax_info.acp_phys+(lmmi-emax_info.acp_mmap);
  (Ull*)(emax_info.reg_mmap+EXI_S_ADDR_REGV) = emax_info.acp_phys+(regv-emax_info.acp_mmap);
  (Ull*)(emax_info.reg_mmap+EXI_S_ADDR_OFFS) = emax_info.hpp_phys - emax_info.hpp_virt);
  (Ull*)(emax_info.reg_mmap+EXI_S_ADDR_MODE) = 1LL);
d136 2
a137 2
  (Ull*)(emax_info.reg_mmap+EXI_S_ADDR_OFFS) = emax_info.hpp_phys - emax_info.hpp_virt);
  (Ull*)(emax_info.reg_mmap+EXI_S_ADDR_MODE) = 2LL);
@


1.43
log
@*** empty log message ***
@
text
@d7 25
d37 2
a38 48
/* Sample Usage of MALLOC, CACHE_FLUSH, GETPHYSADDR                    */
/*  volatile int *a = (volatile int*) umem_malloc(sizeof(int) * size); */
/*  umem_cache_clean((char*)a, sizeof(int) * size);                    */
/*  Uint src = umem_get_phys((void*)a);                                */

/* Sample Usage of FIFO (mem_copy func) */
/*  udev_write_8b(src);                 */
/*  udev_write_8b(dst);                 */
/*  udev_write_8b(size * sizeof(int));  */
/*  udev_read_8b(&recv);                */

#define UIO_MEMSPACE "/dev/uio0"
#define UMEMMAP_BASE 0x20000000
#define UMEMMAP_SIZE 0x20000000

#define UIO_DEVSPACE "/dev/uio1"
#define UMEMPAGESIZE 0x00001000
#define UDEVMAP_SIZE 0x00001000

volatile void* umembase_logical = NULL;
volatile Ull*  udevbase_logical = NULL;

void* umem_open()
{
  int fd;

  if ((fd = open(UIO_MEMSPACE, O_RDWR)) < 1) {
    printf("umem_open(): Invalid UIO device: '%s'\n", UIO_MEMSPACE);
    exit(1);
  }
  umembase_logical = (volatile void*)mmap(NULL, UMEMMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
  return (umembase_logical);
}

void umem_cache_clean(char* addr, Uint bytes)
{
  __clear_cache(addr, addr + bytes);
}

void umem_close()
{
  if(umembase_logical == NULL){
    printf("umem_close(): UMEM is not opened.\n");
    return;
  }
  munmap((void*) umembase_logical, UMEMMAP_SIZE);
  umembase_logical = NULL;
}
d40 44
a83 3
Ull* udev_open()
{
  int fd;
d85 1
a85 22
  if ((fd = open(UIO_DEVSPACE, O_RDWR)) < 1) {
    printf("udev_open: Invalid UIO device: '%s'\n", UIO_DEVSPACE);
    exit(1);
  }
  udevbase_logical = (volatile Ull*)mmap(NULL, UDEVMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
  return (udevbase_logical);
}

void udev_write_8b(Ull addr, Ull data)
{
  *(udevbase_logical+addr/8) = (volatile Ull) data;
}

void udev_read_8b(Ull addr, Ull* data)
{
  volatile Ull r = *(udevbase_logical+addr/8);
  *data = r;
}

void udev_close()
{
  munmap((void*) udevbase_logical, UDEVMAP_SIZE);
d93 1
a93 1
emax5_start(Ull *conf, Ull *lmmi, Ull *regv)
a95 8
#if 0
  for (i=0; i<sizeof(conf); i+=4)
    printf("%08.8x: %08.8x\n", umem_get_phys(conf_addr+i), *(Uint*)(conf_addr+i));
  for (i=0; i<sizeof(lmmi); i+=4)
    printf("%08.8x: %08.8x\n", umem_get_phys(lmmi_addr+i), *(Uint*)(lmmi_addr+i));
  for (i=0; i<sizeof(regv); i+=4)
    printf("%08.8x: %08.8x\n", umem_get_phys(regv_addr+i), *(Uint*)(regv_addr+i));
#endif
a98 1
  struct emax_ctrl {Ull* conf, Ull* lmmi, Ull* regv} p;
a99 4
#if 0
  /* flush cache */
  __clear_cache((void*)usrbase_logical, (void*)(usrbase_logical+UMEMMAP_SIZE));
#endif
d101 8
a108 12
  p.conf = conf;
  p.lmmi = lmmi;
  p.regv = regv;
  ioctl(udev_fd, EMAX_START, (void*)&p);
  /* udev_write_8b(16, get_phys(conf)); /* *conf */
  /* udev_write_8b(24, get_phys(lmmi)); /* *lmmi */
  /* udev_write_8b(32, get_phys(regv)); /* *regv */
  /* udev_write_8b(40, phys-virt);      /* *offs */
  /* udev_write_8b(48, 1LL); /* start real EMAX5 */
  /* do {                                  */
  /*   udev_read_8b(64, &emax_status);     */
  /* } while (emax_status != STATUS_IDLE); */
d123 3
a125 5
#if 0
  /* flush cache */
  __clear_cache((void*)umembase_logical, (void*)(umembase_logical+UMEMMAP_SIZE));
#endif
  udev_write_8b(32, 2LL); /* start real EMAX5 */
d127 1
a127 1
    udev_read_8b(64, &emax_status);
@


1.42
log
@*** empty log message ***
@
text
@d32 1
a32 3
volatile void* umembase_phys = NULL;
Uint umem_allocated = 0;
volatile Ull* udevbase_logical = NULL;
d34 1
a34 1
void umem_open()
d43 1
a43 25
  umembase_phys    = (volatile void*)UMEMMAP_BASE;
  umem_allocated = 0;
}

void* umem_malloc(Uint bytes)
{
  Uint numpages = ((bytes-1)/UMEMPAGESIZE)+1;
  Uint size = UMEMPAGESIZE*numpages;

  if(umembase_logical == NULL){
    printf("umem_malloc(): UMEM is not opened.\n");
    return NULL;
  }

  if(umem_allocated + size > UMEMMAP_SIZE)
    return NULL;

  void* ptr = (void*)(umembase_logical + umem_allocated);
  umem_allocated += size;
  return (ptr);
}

void* umem_get_phys(void* ptr)
{
  return ((void*)(UMEMMAP_BASE + ((Uint)ptr) - ((Uint)umembase_logical)));
d61 1
a61 1
void udev_open()
d70 1
d108 2
a109 1
Ull pe0_status;
d114 13
a126 7
  udev_write_8b(24,         (conf)); /* *conf */
  udev_write_8b(32, get_phys(lmmi)); /* *lmmi */
  udev_write_8b(40, get_phys(regv)); /* *regv */
  udev_write_8b(48, 1LL);  /* start real EMAX5 */
  do {
    udev_read_8b(64, &pe0_status);
  } while (pe0_status != STATUS_IDLE);
d140 1
a140 1
Ull pe0_status;
d147 2
a148 2
    udev_read_8b(64, &pe0_status);
  } while (pe0_status != STATUS_IDLE);
@


1.41
log
@*** empty log message ***
@
text
@d130 1
a130 1
  emax_start((lmmi<regv)?lmmi:regv, (lmmi>regv)?(lmmi+sizeof(lmmi)):(regv+sizeof(regv)), conf, lmmi, regv); /* start syscall EMAX5 */
d138 3
a140 5
  udev_write_8b( 8, (lmmi<regv)?lmmi:regv);                              /* *stack_min */
  udev_write_8b(16, (lmmi>regv)?(lmmi+sizeof(lmmi)):(regv+sizeof(regv)); /* *stack_max */
  udev_write_8b(24, conf); /* *conf */
  udev_write_8b(32, lmmi); /* *lmmi */
  udev_write_8b(40, regv); /* *regv */
@


1.40
log
@*** empty log message ***
@
text
@d130 1
a130 1
  emax_start(conf, lmmi, regv); /* start syscall EMAX5 */
d136 1
a136 1
  __clear_cache((void*)umembase_logical, (void*)(umembase_logical+UMEMMAP_SIZE));
d138 6
a143 4
  udev_write_8b( 8, conf); /* *conf */
  udev_write_8b(16, lmmi); /* *lmmi */
  udev_write_8b(24, regv); /* *regv */
  udev_write_8b(32, 1LL); /* start real EMAX5 */
@


1.39
log
@*** empty log message ***
@
text
@d248 1
a248 1
  float f3, f2, f1, f0;
d285 10
a294 10
    *((Uint*)&f1) = (r1>>32&0x00000000ffffffffLL);
    *((Uint*)&f2) = (r2>>32&0x00000000ffffffffLL);
    *((Uint*)&f3) = (r3>>32&0x00000000ffffffffLL);
    f0 = f1 + (f2 * f3);
    t2 = *((Uint*)&f0);
    *((Uint*)&f1) = (r1&0x00000000ffffffffLL);
    *((Uint*)&f2) = (r2&0x00000000ffffffffLL);
    *((Uint*)&f3) = (r3&0x00000000ffffffffLL);
    f0 = f1 + (f2 * f3);
    t0 = *((Uint*)&f0);
d299 8
a306 8
    *((Uint*)&f1) = (r1>>32&0x00000000ffffffffLL);
    *((Uint*)&f2) = (r2>>32&0x00000000ffffffffLL);
    f0 = f1 + f2;
    t2 = *((Uint*)&f0);
    *((Uint*)&f1) = (r1&0x00000000ffffffffLL);
    *((Uint*)&f2) = (r2&0x00000000ffffffffLL);
    f0 = f1 + f2;
    t0 = *((Uint*)&f0);
d311 8
a318 8
    *((Uint*)&f1) = (r1>>32&0x00000000ffffffffLL);
    *((Uint*)&f2) = (r2>>32&0x00000000ffffffffLL);
    f0 = f1 * f2;
    t2 = *((Uint*)&f0);
    *((Uint*)&f1) = (r1&0x00000000ffffffffLL);
    *((Uint*)&f2) = (r2&0x00000000ffffffffLL);
    f0 = f1 * f2;
    t0 = *((Uint*)&f0);
@


1.38
log
@*** empty log message ***
@
text
@d209 7
a215 7
  case OP_FMA:  /* 64bit 3in floating-point r1+r2*r3 */
  case OP_FAD:  /* 64bit 2in floating-point r1+r2 */
  case OP_FML:  /* 64bit 2in floating-point r1*r2 */
  case OP_ADD3: /* 64bit 3in fixed-point r1+(r2+r3) */
  case OP_SUB3: /* 64bit 3in fixed-point r1-(r2+r3) */
  case OP_ADD:  /* 64bit 2in fixed-point r1+r2 */
  case OP_SUB:  /* 64bit 2in fixed-point r1-r2 */
d248 1
d283 13
a295 2
  case OP_FMA: /* 64bit 3in floating-point r1+r2*r3 */
    *(double*)&ex1_outd = *(double*)&r1 + (*(double*)&r2 * *(double*)&r3);
d297 11
a307 2
  case OP_FAD: /* 64bit 3in floating-point r1+r2 */
    *(double*)&ex1_outd = *(double*)&r1 + *(double*)&r2;
d309 11
a319 2
  case OP_FML: /* 64bit 3in floating-point r1*r2 */
    *(double*)&ex1_outd = *(double*)&r1 * *(double*)&r2;
@


1.37
log
@*** empty log message ***
@
text
@d418 4
a421 4
  case OP_MSAD: /* 16bit*4 8bit*8 2in r1.h3+df(r2.b7,r3.b7)+df(r2.b6,r3.b6)->d.h3
                                      r1.h2+df(r2.b5,r3.b5)+df(r2.b4,r3.b4)->d.h2
                                      r1.h1+df(r2.b3,r3.b3)+df(r2.b2,r3.b2)->d.h1
                                      r1.h0+df(r2.b1,r3.b1)+df(r2.b0,r3.b0)->d.h0 */
d432 14
@


1.36
log
@*** empty log message ***
@
text
@d590 3
@


1.35
log
@*** empty log message ***
@
text
@d182 1
a182 1
cex(Uint op_cx, Ull c3, Ull c2, Ull c1, Ull c0, Ushort pattern, Ull *ex)
d205 1
a205 4
ex4(Uint op_ex1, Ull *r1, Uint exp1, Ull *r2, Uint exp2, Ull *r3, Uint exp3,
   Uint op_ex2, Ull *r4,
   Uint op_ex3, Ull *r5,
   Ull *d)
d245 1
a245 4
exe(Uint op_ex1, Ull r1, Uint exp1, Ull r2, Uint exp2, Ull r3, Uint exp3,
   Uint op_ex2, Ull r4,
   Uint op_ex3, Ull r5,
   Ull *d)
@


1.34
log
@*** empty log message ***
@
text
@d7 1
a7 1
#ifdef EMAX5
@


1.33
log
@*** empty log message ***
@
text
@d143 1
a143 1
    udev_read_8b(40, &pe0_status);
d165 1
a165 1
    udev_read_8b(40, &pe0_status);
@


1.32
log
@*** empty log message ***
@
text
@d152 22
@


1.31
log
@*** empty log message ***
@
text
@d225 1
a225 1
void __attribute__((always_inline))
d231 1
d236 1
d258 6
a263 8
  case OP_WHILE:
#if 0
    d = r1 + r2;
    n = d>>31;
    z = d==0;
    v = (r1>>31&&r2>>31&&!(d>>31)) || (!(r1>>31)&&!(r2>>31)&&d>>31);
    c = (r1>>31&&r2>>31) || (!(d>>31)&&(r1>>31||r2>>31));
    if (z) emax4[cid].unit1_stop |= (1LL<<i);
d624 2
@


1.30
log
@*** empty log message ***
@
text
@d119 1
a119 1
emax5_start(Ull *conf, Ull *regv, Ull *lmmi)
d125 2
a128 2
  for (i=0; i<sizeof(lmmi); i+=4)
    printf("%08.8x: %08.8x\n", umem_get_phys(lmmi_addr+i), *(Uint*)(lmmi_addr+i));
d130 1
a130 1
  emax_start(conf, regv, lmmi); /* start syscall EMAX5 */
d139 2
a140 2
  udev_write_8b(16, regv); /* *regv */
  udev_write_8b(24, lmmi); /* *lmmi */
@


1.29
log
@*** empty log message ***
@
text
@d751 2
a752 1
    *(Ull*)(adr&~7LL) = *d;
@


1.28
log
@*** empty log message ***
@
text
@d683 1
a683 1
mo4(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint blk, Uint len, Uchar force, Ull ptop)
d688 1
a688 1
  mm4(op_mm, ex, d, adr);
d692 1
a692 58
mm4(Uint op_mm, Ull ex, Ull *d, Ull adr)
{
  Ull c1, c0;

  c1 = ex>>1&1;
  c0 = ex   &1;

  switch (op_mm) {
  case OP_NOP:
    if (d) *d = 0x0000000000000000LL;
    break;
  case OP_LDBFQ: /* 64bit*4 buffered LMM is used as a buffer */
    *(d+0) = *((Ull*)(adr&~7LL)+0);
    *(d+1) = *((Ull*)(adr&~7LL)+1);
    *(d+2) = *((Ull*)(adr&~7LL)+2);
    *(d+3) = *((Ull*)(adr&~7LL)+3);
    break;
  case OP_LDRQ: /* 64bit*4 lmm LMM is preloaded, random-access */
    *(d+0) = *((Ull*)(adr&~7LL)+0);
    *(d+1) = *((Ull*)(adr&~7LL)+1);
    *(d+2) = *((Ull*)(adr&~7LL)+2);
    *(d+3) = *((Ull*)(adr&~7LL)+3);
    break;
  case OP_LDDMQ: /* 64bit*4 mem Direct access to MM */
    if (c0) {
      *(d+0) = *((Ull*)(adr&~7LL)+0);
      *(d+1) = *((Ull*)(adr&~7LL)+1);
      *(d+2) = *((Ull*)(adr&~7LL)+2);
      *(d+3) = *((Ull*)(adr&~7LL)+3);
    }
    break;
  case OP_STRQ: /* 64bit*4 lmm LMM is drained. random-access */
    *((Ull*)(adr&~7LL)+0) = *(d+0);
    *((Ull*)(adr&~7LL)+1) = *(d+1);
    *((Ull*)(adr&~7LL)+2) = *(d+2);
    *((Ull*)(adr&~7LL)+3) = *(d+3);
    break;
  case OP_STBFQ: /* 64bit*4 buffered LMM is used as a buffer */
    *((Ull*)(adr&~7LL)+0) = *(d+0);
    *((Ull*)(adr&~7LL)+1) = *(d+1);
    *((Ull*)(adr&~7LL)+2) = *(d+2);
    *((Ull*)(adr&~7LL)+3) = *(d+3);
    break;
  case OP_TR: /* 64bit*4 exec Send transaction */
    /* addrをtransaction()指定に使用 */
    if (c0) {
      Ull (*trans)() = adr;
      (trans)(*(d+0), *(d+1), *(d+2), *(d+3));
    }
    break;
  default:
    printf("emax5lib: mmp: undefined op_mm=%d\n", op_mm);
    break;
  }
}

void __attribute__((always_inline))
mop(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint blk, Uint len, Uchar force, Ull ptop)
a709 1
    if (d) *d = 0x0000000000000000LL;
d711 2
d753 43
d797 1
a797 1
    printf("emax5lib: mop: undefined op_mm=%d\n", op_mm);
@


1.27
log
@*** empty log message ***
@
text
@d627 1
a627 1
mo4(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint blk, Uint len, Uchar force, Ull ptop)
a628 6
  Ull adr;
  Ull c1, c0;

  c1 = ex>>1&1;
  c0 = ex   &1;

d675 1
a675 1
    printf("emax5lib: mo4: undefined msk=%d\n", msk);
d679 19
a697 1
  adr = base + offset;
d743 1
a743 1
    printf("emax5lib: mo4: undefined op_mm=%d\n", op_mm);
d752 8
a764 52
  switch (msk) {
  case  MSK_D0:
    break;
  case  MSK_W1:		
    offset = offset>>32;
    break;
  case  MSK_W0:
    offset = offset&0x00000000ffffffffLL;
    break;
  case  MSK_H3:
    offset = offset>>48&0x000000000000ffffLL;
    break;
  case  MSK_H2:
    offset = offset>>32&0x000000000000ffffLL;
    break;
  case  MSK_H1:
    offset = offset>>16&0x000000000000ffffLL;
    break;
  case  MSK_H0:
    offset = offset&0x000000000000ffffLL;
    break;
  case  MSK_B7:
    offset = offset>>56&0x00000000000000ffLL;
    break;
  case  MSK_B6:
    offset = offset>>48&0x00000000000000ffLL;
    break;
  case  MSK_B5:
    offset = offset>>40&0x00000000000000ffLL;
    break;
  case  MSK_B4:
    offset = offset>>32&0x00000000000000ffLL;
    break;
  case  MSK_B3:
    offset = offset>>24&0x00000000000000ffLL;
    break;
  case  MSK_B2:
    offset = offset>>16&0x00000000000000ffLL;
    break;
  case  MSK_B1:
    offset = offset>>8&0x00000000000000ffLL;
    break;
  case  MSK_B0:
    offset = offset&0x00000000000000ffLL;
    break;
  default:
    printf("emax5lib: mop: undefined msk=%d\n", msk);
    break;
  }

  adr = base + offset;

@


1.26
log
@*** empty log message ***
@
text
@a187 2
  Uint op_ex;

d190 7
a196 22
    op_ex = OP_NOP;
    break;
  case OP_FMAQ: /* 64bit 3in floating-point r1+r2*r3 */
    op_ex = OP_FMA;
    break;
  case OP_FADQ: /* 64bit 2in floating-point r1+r2 */
    op_ex = OP_FAD;
    break;
  case OP_FMLQ: /* 64bit 2in floating-point r1*r2 */
    op_ex = OP_FML;
    break;
  case OP_ADD3Q: /* 64bit 3in fixed-point r1+(r2+r3) */
    op_ex = OP_ADD3;
    break;
  case OP_SUB3Q: /* 64bit 3in fixed-point r1-(r2+r3) */
    op_ex = OP_SUB3;
    break;
  case OP_ADDQ: /* 64bit 2in fixed-point r1+r2 */
    op_ex = OP_ADD;
    break;
  case OP_SUBQ: /* 64bit 2in fixed-point r1-r2 */
    op_ex = OP_SUB;
d203 4
a206 4
  exe(op_ex, *(r1+0), exp1, *(r2+0), exp2, *(r3+0), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (d+0));
  exe(op_ex, *(r1+1), exp1, *(r2+1), exp2, *(r3+1), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (d+1));
  exe(op_ex, *(r1+2), exp1, *(r2+2), exp2, *(r3+2), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (d+2));
  exe(op_ex, *(r1+3), exp1, *(r2+3), exp2, *(r3+3), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (d+3));
@


1.25
log
@*** empty log message ***
@
text
@d188 1
a188 1
  Ull t3, t2, t1, t0;
d192 1
d195 1
a195 4
    exe(OP_FMA, *(double*)(r1+0), exp1, *(double*)(r2+0), exp2, *(double*)(r3+0), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+0));
    exe(OP_FMA, *(double*)(r1+1), exp1, *(double*)(r2+1), exp2, *(double*)(r3+1), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+1));
    exe(OP_FMA, *(double*)(r1+2), exp1, *(double*)(r2+2), exp2, *(double*)(r3+2), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+2));
    exe(OP_FMA, *(double*)(r1+3), exp1, *(double*)(r2+3), exp2, *(double*)(r3+3), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+3));
d198 1
a198 4
    exe(OP_FAD, *(double*)(r1+0), exp1, *(double*)(r2+0), exp2, *(double*)(r3+0), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+0));
    exe(OP_FAD, *(double*)(r1+1), exp1, *(double*)(r2+1), exp2, *(double*)(r3+1), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+1));
    exe(OP_FAD, *(double*)(r1+2), exp1, *(double*)(r2+2), exp2, *(double*)(r3+2), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+2));
    exe(OP_FAD, *(double*)(r1+3), exp1, *(double*)(r2+3), exp2, *(double*)(r3+3), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+3));
d201 1
a201 4
    exe(OP_FML, *(double*)(r1+0), exp1, *(double*)(r2+0), exp2, *(double*)(r3+0), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+0));
    exe(OP_FML, *(double*)(r1+1), exp1, *(double*)(r2+1), exp2, *(double*)(r3+1), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+1));
    exe(OP_FML, *(double*)(r1+2), exp1, *(double*)(r2+2), exp2, *(double*)(r3+2), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+2));
    exe(OP_FML, *(double*)(r1+3), exp1, *(double*)(r2+3), exp2, *(double*)(r3+3), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+3));
d204 1
a204 4
    exe(OP_ADD3, *(double*)(r1+0), exp1, *(double*)(r2+0), exp2, *(double*)(r3+0), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+0));
    exe(OP_ADD3, *(double*)(r1+1), exp1, *(double*)(r2+1), exp2, *(double*)(r3+1), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+1));
    exe(OP_ADD3, *(double*)(r1+2), exp1, *(double*)(r2+2), exp2, *(double*)(r3+2), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+2));
    exe(OP_ADD3, *(double*)(r1+3), exp1, *(double*)(r2+3), exp2, *(double*)(r3+3), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+3));
d207 1
a207 4
    exe(OP_SUB3, *(double*)(r1+0), exp1, *(double*)(r2+0), exp2, *(double*)(r3+0), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+0));
    exe(OP_SUB3, *(double*)(r1+1), exp1, *(double*)(r2+1), exp2, *(double*)(r3+1), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+1));
    exe(OP_SUB3, *(double*)(r1+2), exp1, *(double*)(r2+2), exp2, *(double*)(r3+2), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+2));
    exe(OP_SUB3, *(double*)(r1+3), exp1, *(double*)(r2+3), exp2, *(double*)(r3+3), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+3));
d210 1
a210 4
    exe(OP_ADD, *(double*)(r1+0), exp1, *(double*)(r2+0), exp2, *(double*)(r3+0), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+0));
    exe(OP_ADD, *(double*)(r1+1), exp1, *(double*)(r2+1), exp2, *(double*)(r3+1), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+1));
    exe(OP_ADD, *(double*)(r1+2), exp1, *(double*)(r2+2), exp2, *(double*)(r3+2), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+2));
    exe(OP_ADD, *(double*)(r1+3), exp1, *(double*)(r2+3), exp2, *(double*)(r3+3), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+3));
d213 1
a213 4
    exe(OP_SUB, *(double*)(r1+0), exp1, *(double*)(r2+0), exp2, *(double*)(r3+0), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+0));
    exe(OP_SUB, *(double*)(r1+1), exp1, *(double*)(r2+1), exp2, *(double*)(r3+1), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+1));
    exe(OP_SUB, *(double*)(r1+2), exp1, *(double*)(r2+2), exp2, *(double*)(r3+2), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+2));
    exe(OP_SUB, *(double*)(r1+3), exp1, *(double*)(r2+3), exp2, *(double*)(r3+3), exp3, OP_NOP, 0LL, OP_NOP, 0LL, (double*)(d+3));
d220 5
@


1.24
log
@*** empty log message ***
@
text
@d166 2
d194 4
a197 4
    *(double*)(d+0) = *(double*)(r1+0) + (*(double*)(r2+0) * *(double*)(r3+0));
    *(double*)(d+1) = *(double*)(r1+1) + (*(double*)(r2+1) * *(double*)(r3+1));
    *(double*)(d+2) = *(double*)(r1+2) + (*(double*)(r2+2) * *(double*)(r3+2));
    *(double*)(d+3) = *(double*)(r1+3) + (*(double*)(r2+3) * *(double*)(r3+3));
d200 4
a203 4
    *(double*)(d+0) = *(double*)(r1+0) + *(double*)(r2+0);
    *(double*)(d+1) = *(double*)(r1+1) + *(double*)(r2+1);
    *(double*)(d+2) = *(double*)(r1+2) + *(double*)(r2+2);
    *(double*)(d+3) = *(double*)(r1+3) + *(double*)(r2+3);
d206 4
a209 4
    *(double*)(d+0) = *(double*)(r1+0) * *(double*)(r2+0);
    *(double*)(d+1) = *(double*)(r1+1) * *(double*)(r2+1);
    *(double*)(d+2) = *(double*)(r1+2) * *(double*)(r2+2);
    *(double*)(d+3) = *(double*)(r1+3) * *(double*)(r2+3);
d212 4
a215 20
    t2 = (*(r1+0)>>32&0x00000000ffffffffLL)+((*(r2+0)>>32&0x00000000ffffffffLL)+(*(r3+0)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+0)    &0x00000000ffffffffLL)+((*(r2+0)    &0x00000000ffffffffLL)+(*(r3+0)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+0) = (t2<<32)|(t0);
    t2 = (*(r1+1)>>32&0x00000000ffffffffLL)+((*(r2+1)>>32&0x00000000ffffffffLL)+(*(r3+1)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+1)    &0x00000000ffffffffLL)+((*(r2+1)    &0x00000000ffffffffLL)+(*(r3+1)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+1) = (t2<<32)|(t0);
    t2 = (*(r1+2)>>32&0x00000000ffffffffLL)+((*(r2+2)>>32&0x00000000ffffffffLL)+(*(r3+2)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+2)    &0x00000000ffffffffLL)+((*(r2+2)    &0x00000000ffffffffLL)+(*(r3+2)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+2) = (t2<<32)|(t0);
    t2 = (*(r1+3)>>32&0x00000000ffffffffLL)+((*(r2+3)>>32&0x00000000ffffffffLL)+(*(r3+3)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+3)    &0x00000000ffffffffLL)+((*(r2+3)    &0x00000000ffffffffLL)+(*(r3+3)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+3) = (t2<<32)|(t0);
d218 4
a221 20
    t2 = (*(r1+0)>>32&0x00000000ffffffffLL)-((*(r2+0)>>32&0x00000000ffffffffLL)+(*(r3+0)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+0)    &0x00000000ffffffffLL)-((*(r2+0)    &0x00000000ffffffffLL)+(*(r3+0)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+0) = (t2<<32)|(t0);
    t2 = (*(r1+1)>>32&0x00000000ffffffffLL)-((*(r2+1)>>32&0x00000000ffffffffLL)+(*(r3+1)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+1)    &0x00000000ffffffffLL)-((*(r2+1)    &0x00000000ffffffffLL)+(*(r3+1)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+1) = (t2<<32)|(t0);
    t2 = (*(r1+2)>>32&0x00000000ffffffffLL)-((*(r2+2)>>32&0x00000000ffffffffLL)+(*(r3+2)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+2)    &0x00000000ffffffffLL)-((*(r2+2)    &0x00000000ffffffffLL)+(*(r3+2)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+2) = (t2<<32)|(t0);
    t2 = (*(r1+3)>>32&0x00000000ffffffffLL)-((*(r2+3)>>32&0x00000000ffffffffLL)+(*(r3+3)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+3)    &0x00000000ffffffffLL)-((*(r2+3)    &0x00000000ffffffffLL)+(*(r3+3)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+3) = (t2<<32)|(t0);
d224 4
a227 20
    t2 = (*(r1+0)>>32&0x00000000ffffffffLL)+(*(r2+0)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+0)    &0x00000000ffffffffLL)+(*(r2+0)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+0) = (t2<<32)|(t0);
    t2 = (*(r1+1)>>32&0x00000000ffffffffLL)+(*(r2+1)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+1)    &0x00000000ffffffffLL)+(*(r2+1)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+1) = (t2<<32)|(t0);
    t2 = (*(r1+2)>>32&0x00000000ffffffffLL)+(*(r2+2)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+2)    &0x00000000ffffffffLL)+(*(r2+2)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+2) = (t2<<32)|(t0);
    t2 = (*(r1+3)>>32&0x00000000ffffffffLL)+(*(r2+3)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+3)    &0x00000000ffffffffLL)+(*(r2+3)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+3) = (t2<<32)|(t0);
d230 4
a233 20
    t2 = (*(r1+0)>>32&0x00000000ffffffffLL)-(*(r2+0)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+0)    &0x00000000ffffffffLL)-(*(r2+0)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+0) = (t2<<32)|(t0);
    t2 = (*(r1+1)>>32&0x00000000ffffffffLL)-(*(r2+1)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+1)    &0x00000000ffffffffLL)-(*(r2+1)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+1) = (t2<<32)|(t0);
    t2 = (*(r1+2)>>32&0x00000000ffffffffLL)-(*(r2+2)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+2)    &0x00000000ffffffffLL)-(*(r2+2)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+2) = (t2<<32)|(t0);
    t2 = (*(r1+3)>>32&0x00000000ffffffffLL)-(*(r2+3)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+3)    &0x00000000ffffffffLL)-(*(r2+3)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+3) = (t2<<32)|(t0);
@


1.23
log
@*** empty log message ***
@
text
@d721 1
a721 1
mo4(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint blk, Uint dist, Uint len, Uchar force, Ull ptop)
d831 1
a831 1
mop(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint blk, Uint dist, Uint len, Uchar force, Ull ptop)
@


1.22
log
@*** empty log message ***
@
text
@d721 1
a721 1
mo4(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint dist, Uint len, Uchar force, Ull ptop)
d831 1
a831 1
mop(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint dist, Uint len, Uchar force, Ull ptop)
@


1.21
log
@*** empty log message ***
@
text
@d133 1
d138 4
a141 1
  udev_write_4b(4, 1); /* start real EMAX5 */
d143 1
a143 1
    udev_read_4b(8, &pe0_status);
@


1.20
log
@*** empty log message ***
@
text
@d18 4
a21 4
/*  udev_write_4b(src);                 */
/*  udev_write_4b(dst);                 */
/*  udev_write_4b(size * sizeof(int));  */
/*  udev_read_4b(&recv);                */
d34 1
a34 1
volatile int* udevbase_logical = NULL;
d95 1
a95 1
  udevbase_logical = (volatile int*)mmap(NULL, UDEVMAP_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
d98 1
a98 1
void udev_write_4b(Uint addr, Uint data)
d100 1
a100 1
  *(udevbase_logical+addr/4) = (volatile Uint) data;
d103 1
a103 1
void udev_read_4b(Uint addr, Uint* data)
d105 1
a105 1
  volatile Uint r = *(udevbase_logical+addr/4);
@


1.19
log
@*** empty log message ***
@
text
@d717 1
a717 1
mo4(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint dist, Uint len, Uchar force, Ull pref_top, Uint pref_dist, Uint pref_len)
d827 1
a827 1
mop(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint dist, Uint len, Uchar force, Ull pref_top, Uint pref_dist, Uint pref_len)
@


1.18
log
@*** empty log message ***
@
text
@d717 1
a717 1
mo4(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint dist, Uint len, Uchar force, Ull pref_top, Uint pref_dist, Uint pref_len, Uint pref_force)
d827 1
a827 1
mop(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint dist, Uint len, Uchar force, Ull pref_top, Uint pref_dist, Uint pref_len, Uint pref_force)
@


1.17
log
@*** empty log message ***
@
text
@d7 1
a7 1
#ifdef EMAX5ASIC
d121 11
a140 8
#else
#if 0
  for (i=0; i<sizeof(conf); i+=4)
    printf("%08.8x: %08.8x\n", umem_get_phys(conf_addr+i), *(Uint*)(conf_addr+i));
  for (i=0; i<sizeof(regv); i+=4)
    printf("%08.8x: %08.8x\n", umem_get_phys(regv_addr+i), *(Uint*)(regv_addr+i));
  for (i=0; i<sizeof(lmmi); i+=4)
    printf("%08.8x: %08.8x\n", umem_get_phys(lmmi_addr+i), *(Uint*)(lmmi_addr+i));
d142 3
a144 1
  emax_start(conf, regv, lmmi); /* start syscall EMAX5 */
d717 1
a717 1
mo4(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint dist, Uint len, Uchar force, Ull pref_top, Uint pref_dist, Uint pref_len)
d827 1
a827 1
mop(Uint op_mm, Ull ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint dist, Uint len, Uchar force, Ull pref_top, Uint pref_dist, Uint pref_len)
@


1.16
log
@*** empty log message ***
@
text
@d7 112
d143 4
@


1.15
log
@*** empty log message ***
@
text
@d9 20
@


1.14
log
@*** empty log message ***
@
text
@d7 4
@


1.13
log
@*** empty log message ***
@
text
@d642 6
d656 6
@


1.12
log
@*** empty log message ***
@
text
@d11 1
a11 1
cex(Uint op_cx, Uchar c3, Uchar c2, Uchar c1, Uchar c0, Ushort pattern, Uchar *ex)
d35 1
a35 1
   Ull *d, Uchar *c)
d174 1
a174 1
   Ull *d, Uchar *c)
d177 1
a177 1
  Uchar c1, c0;
a178 1
  Uchar ex1_outc;
a179 1
  Uchar ex2_outc;
a199 1
    ex1_outc = 0;
a212 1
    ex1_outc = 0;
a215 1
    ex1_outc = 0;
a218 1
    ex1_outc = 0;
a225 1
    ex1_outc = 0;
a232 1
    ex1_outc = 0;
a239 1
    ex1_outc = 0;
a246 1
    ex1_outc = 0;
d251 1
a251 2
    ex1_outd = 0LL;
    ex1_outc = (c1<<1)|c0;
d256 1
a256 2
    ex1_outd = 0LL;
    ex1_outc = (c1<<1)|c0;
d261 1
a261 2
    ex1_outd = 0LL;
    ex1_outc = (c1<<1)|c0;
d266 1
a266 2
    ex1_outd = 0LL;
    ex1_outc = (c1<<1)|c0;
d271 1
a271 2
    ex1_outd = 0LL;
    ex1_outc = (c1<<1)|c0;
d276 1
a276 2
    ex1_outd = 0LL;
    ex1_outc = (c1<<1)|c0;
d278 5
a282 5
  case OP_CMOV: /* 32bit*2 2in 2bit conditional move */
    c1 = *c>>1&1;
    c0 = *c   &1;
    t2 = c1 ? (r1&0xffffffff00000000LL) : (r2&0xffffffff00000000LL);
    t0 = c0 ? (r1&0x00000000ffffffffLL) : (r2&0x00000000ffffffffLL);
a283 1
    /*ex1_outc = 0;*/
a286 1
    ex1_outc = 0;
a297 1
    ex1_outc = 0;
a308 1
    ex1_outc = 0;
a319 1
    ex1_outc = 0;
a330 1
    ex1_outc = 0;
a341 1
    ex1_outc = 0;
a345 1
    ex1_outc = 0;
a359 1
    ex1_outc = 0;
a371 1
    ex1_outc = 0;
a379 1
    ex1_outc = 0;
a389 1
    ex1_outc = 0;
a395 1
    ex1_outc = 0;
a421 1
    ex1_outc = 0;
a439 1
    ex1_outc = 0;
a457 1
    ex1_outc = 0;
a467 1
    ex1_outc = 0;
a477 1
    ex1_outc = 0;
a486 1
    ex2_outc = ex1_outc;
a489 1
    ex2_outc = ex1_outc;
a492 1
    ex2_outc = ex1_outc;
a495 1
    ex2_outc = ex1_outc;
a506 1
    ex2_outc = ex1_outc;
a517 1
    ex2_outc = ex1_outc;
a526 1
    if (c) *c = ex2_outc;
a531 1
    if (c) *c = ex2_outc;
a536 1
    if (c) *c = ex2_outc;
a541 1
    if (c) *c = ex2_outc;
a546 1
    if (c) *c = ex2_outc;
a551 1
    if (c) *c = ex2_outc;
a556 1
    if (c) *c = ex2_outc;
a563 1
    if (c) *c = ex2_outc;
d572 1
a572 1
mo4(Uint op_mm, Uchar ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint dist, Uint len, Uchar force, Ull pref_top, Uint pref_dist, Uint pref_len)
d575 1
a575 1
  Uchar c1, c0;
d670 1
a670 1
mop(Uint op_mm, Uchar ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull top, Uint dist, Uint len, Uchar force, Ull pref_top, Uint pref_dist, Uint pref_len)
d673 1
a673 1
  Uchar c1, c0;
@


1.11
log
@*** empty log message ***
@
text
@d302 4
@


1.10
log
@*** empty log message ***
@
text
@d616 1
a616 1
mo4(Uint op_mm, Uchar ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull area_top, Uint dist, Uint len, Uchar force)
d714 1
a714 1
mop(Uint op_mm, Uchar ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull area_top, Uint dist, Uint len, Uchar force)
@


1.9
log
@*** empty log message ***
@
text
@d703 1
a703 1
      Ull (*trans)() = addr;
@


1.8
log
@*** empty log message ***
@
text
@d26 1
a26 1
    printf("emax5lib: cx: undefined op_cx=%d\n", op_cx);
d510 1
a510 1
    printf("emax5lib: ex: undefined op_ex1=%d\n", op_ex1);
d556 1
a556 1
    printf("emax5lib: ex: undefined op_ex2=%d\n", op_ex2);
d610 99
a708 1
    printf("emax5lib: ex: undefined op_ex3=%d\n", op_ex3);
d768 1
a768 1
    printf("emax5lib: mm: undefined msk=%d\n", msk);
a801 14
  case OP_LDBFQ: /* 64bit*4 buffered LMM is used as a buffer */
    *(d+0) = *((Ull*)(adr&~7LL)+0);
    *(d+1) = *((Ull*)(adr&~7LL)+1);
    *(d+2) = *((Ull*)(adr&~7LL)+2);
    *(d+3) = *((Ull*)(adr&~7LL)+3);
    break;
  case OP_LDDMQ: /* 64bit*4 mem Direct access to MM */
    if (c0) {
      *(d+0) = *((Ull*)(adr&~7LL)+0);
      *(d+1) = *((Ull*)(adr&~7LL)+1);
      *(d+2) = *((Ull*)(adr&~7LL)+2);
      *(d+3) = *((Ull*)(adr&~7LL)+3);
    }
    break;
a817 11
  case OP_STBFQ: /* 64bit*4 buffered LMM is used as a buffer */
    *((Ull*)(adr&~7LL)+0) = *(d+0);
    *((Ull*)(adr&~7LL)+1) = *(d+1);
    *((Ull*)(adr&~7LL)+2) = *(d+2);
    *((Ull*)(adr&~7LL)+3) = *(d+3);
    break;
  case OP_TR: /* 64bit*4 exec Send transaction */
    /* N/A */
    if (c0) {
    }
    break;
d819 1
a819 1
    printf("emax5lib: mm: undefined op_mm=%d\n", op_mm);
@


1.7
log
@*** empty log message ***
@
text
@d11 1
a11 1
mop(Uint op_mm, Uchar ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull area_top, Uint dist, Uint len, Uchar force)
d13 1
a13 2
  Ull adr;
  Uchar c1, c0;
d15 1
a15 56
  c1 = ex>>1&1;
  c0 = ex   &1;

  switch (msk) {
  case  MSK_D0:
    break;
  case  MSK_W1:		
    offset = offset>>32;
    break;
  case  MSK_W0:
    offset = offset&0x00000000ffffffffLL;
    break;
  case  MSK_H3:
    offset = offset>>48&0x000000000000ffffLL;
    break;
  case  MSK_H2:
    offset = offset>>32&0x000000000000ffffLL;
    break;
  case  MSK_H1:
    offset = offset>>16&0x000000000000ffffLL;
    break;
  case  MSK_H0:
    offset = offset&0x000000000000ffffLL;
    break;
  case  MSK_B7:
    offset = offset>>56&0x00000000000000ffLL;
    break;
  case  MSK_B6:
    offset = offset>>48&0x00000000000000ffLL;
    break;
  case  MSK_B5:
    offset = offset>>40&0x00000000000000ffLL;
    break;
  case  MSK_B4:
    offset = offset>>32&0x00000000000000ffLL;
    break;
  case  MSK_B3:
    offset = offset>>24&0x00000000000000ffLL;
    break;
  case  MSK_B2:
    offset = offset>>16&0x00000000000000ffLL;
    break;
  case  MSK_B1:
    offset = offset>>8&0x00000000000000ffLL;
    break;
  case  MSK_B0:
    offset = offset&0x00000000000000ffLL;
    break;
  default:
    printf("emax5lib: mm: undefined msk=%d\n", msk);
    break;
  }

  adr = base + offset;

  switch (op_mm) {
a16 1
    if (d) *d = 0x0000000000000000LL;
d18 6
a23 64
  case OP_LDR: /* 64bit lmm LMM is preloaded, random-access */
    *d = *(Ull*)(adr&~7LL);
    break;
  case OP_LDWR: /* s32bit lmm LMM is preloaded, random-access */
    *d = (Sll)*(int*)(adr&~3LL);
    break;
  case OP_LDUWR: /* u32bit lmm LMM is preloaded, random-access */
    *d = (Ull)*(Uint*)(adr&~3LL);
    break;
  case OP_LDHR: /* s16bit lmm LMM is preloaded, random-access */
    *d = (Sll)*(short*)(adr&~1LL);
    break;
  case OP_LDUHR: /* u16bit lmm LMM is preloaded, random-access */
    *d = (Ull)*(Ushort*)(adr&~1LL);
    break;
  case OP_LDBR: /* s8bit lmm LMM is preloaded, random-access */
    *d = (Sll)*(char*)adr;
    break;
  case OP_LDUBR: /* u8bit lmm LMM is preloaded, random-access */
    *d = (Ull)*(Uchar*)adr;
    break;
  case OP_LDBF: /* 64bit buffered LMM is used as a buffer */
    *d = *(Ull*)(adr&~7LL);
    break;
  case OP_LDBFQ: /* 64bit*4 buffered LMM is used as a buffer */
    *(d+0) = *((Ull*)(adr&~7LL)+0);
    *(d+1) = *((Ull*)(adr&~7LL)+1);
    *(d+2) = *((Ull*)(adr&~7LL)+2);
    *(d+3) = *((Ull*)(adr&~7LL)+3);
    break;
  case OP_LDDMQ: /* 64bit*4 mem Direct access to MM */
    if (c0) {
      *(d+0) = *((Ull*)(adr&~7LL)+0);
      *(d+1) = *((Ull*)(adr&~7LL)+1);
      *(d+2) = *((Ull*)(adr&~7LL)+2);
      *(d+3) = *((Ull*)(adr&~7LL)+3);
    }
    break;
  case OP_STR: /* 64bit lmm LMM is drained. random-access */
    if (c1) *((Uint*)(adr&~7LL)+1) = *d>>32;
    if (c0) *((Uint*)(adr&~7LL)  ) = *d;
    break;
  case OP_STWR: /* 32bit lmm LMM is drained. random-access */
    if (c0) *(Uint*)(adr&~3LL) = *d;
    break;
  case OP_STHR: /* 16bit lmm LMM is drained. random-access */
    if (c0) *(Ushort*)(adr&~1LL) = *d;
    break;
  case OP_STBR: /* 8bit lmm LMM is drained. random-access */
    if (c0) *(Uchar*)adr = *d;
    break;
  case OP_STBF: /* 64bit buffered LMM is used as a buffer */
    *(Ull*)(adr&~7LL) = *d;
    break;
  case OP_STBFQ: /* 64bit*4 buffered LMM is used as a buffer */
    *((Ull*)(adr&~7LL)+0) = *(d+0);
    *((Ull*)(adr&~7LL)+1) = *(d+1);
    *((Ull*)(adr&~7LL)+2) = *(d+2);
    *((Ull*)(adr&~7LL)+3) = *(d+3);
    break;
  case OP_TR: /* 64bit*4 exec Send transaction */
    /* N/A */
    if (c0) {
    }
d26 1
a26 1
    printf("emax5lib: mm: undefined op_mm=%d\n", op_mm);
d28 1
a28 1
  }
d33 2
a34 2
   Uint op_ex2, Ull *r4, Ull *r5,
   Uint op_ex3, Ull *r6,
d172 2
a173 2
   Uint op_ex2, Ull r4, Ull r5,
   Uint op_ex3, Ull r6,
a175 1
  int ex1_active;
d201 1
a201 2
    ex1_active = 0;
    ex1_outd = 0LL;
a204 1
    /* nop */
a214 1
    ex1_active = 1;
a218 1
    ex1_active = 1;
a222 1
    ex1_active = 1;
a226 1
    ex1_active = 1;
a234 1
    ex1_active = 1;
a242 1
    ex1_active = 1;
a250 1
    ex1_active = 1;
a258 1
    ex1_active = 1;
a264 1
    ex1_active = 1;
a270 1
    ex1_active = 1;
a276 1
    ex1_active = 1;
a282 1
    ex1_active = 1;
a288 1
    ex1_active = 1;
a294 1
    ex1_active = 1;
a302 1
    ex1_active = 1;
a314 1
    ex1_active = 1;
a326 1
    ex1_active = 1;
a338 1
    ex1_active = 1;
a350 1
    ex1_active = 1;
a362 1
    ex1_active = 1;
a370 1
    ex1_active = 1;
a383 1
    ex1_active = 1;
a396 1
    ex1_active = 1;
a404 1
    ex1_active = 1;
a416 1
    ex1_active = 1;
a422 1
    ex1_active = 1;
a449 1
    ex1_active = 1;
a468 1
    ex1_active = 1;
a487 1
    ex1_active = 1;
a498 1
    ex1_active = 1;
d520 1
a520 2
    if (ex1_active) ex2_outd = ex1_outd & r5;
    else            ex2_outd = r4       & r5;
d524 1
a524 2
    if (ex1_active) ex2_outd = ex1_outd | r5;
    else            ex2_outd = r4       | r5;
d528 1
a528 2
    if (ex1_active) ex2_outd = ex1_outd ^ r5;
    else            ex2_outd = r4       ^ r5;
d532 4
a535 12
    if (ex1_active) {
      t3 = ex1_outd>>48&0x000000000000ffffLL;
      t2 = ex1_outd>>32&0x000000000000ffffLL;
      t1 = ex1_outd>>16&0x000000000000ffffLL;
      t0 = ex1_outd    &0x000000000000ffffLL;
    }
    else {
      t3 = r4>>48&0x000000000000ffffLL;
      t2 = r4>>32&0x000000000000ffffLL;
      t1 = r4>>16&0x000000000000ffffLL;
      t0 = r4    &0x000000000000ffffLL;
    }
d544 4
a547 12
    if (ex1_active) {
      t3 = ex1_outd>>48&0x000000000000ffffLL;
      t2 = ex1_outd>>32&0x000000000000ffffLL;
      t1 = ex1_outd>>16&0x000000000000ffffLL;
      t0 = ex1_outd    &0x000000000000ffffLL;
    }
    else {
      t3 = r4>>48&0x000000000000ffffLL;
      t2 = r4>>32&0x000000000000ffffLL;
      t1 = r4>>16&0x000000000000ffffLL;
      t0 = r4    &0x000000000000ffffLL;
    }
d566 2
a567 2
    t1 = (Ull)(ex2_outd    &0xffffffff00000000LL)<<r6;
    t0 = (Ull)(ex2_outd<<r6&0x00000000ffffffffLL);
d572 2
a573 2
    t1 = (Ull)(ex2_outd>>r6&0xffffffff00000000LL);
    t0 = (Ull)(ex2_outd    &0x00000000ffffffffLL)>>r6;
d578 2
a579 2
    t1 = (Sll)(ex2_outd    )>>r6&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<32)>>r6&0xffffffff00000000LL;
d584 2
a585 2
    t1 = (Sll)(ex2_outd<< 8)>>(r6+8)&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<40)>>(r6+8)&0xffffffff00000000LL;
d590 2
a591 2
    t1 = (Sll)(ex2_outd<<16)>>(r6+16)&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<48)>>(r6+16)&0xffffffff00000000LL;
d596 2
a597 2
    t1 = (Sll)(ex2_outd<<24)>>(r6+24)&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<56)>>(r6+24)&0xffffffff00000000LL;
d602 4
a605 4
    t3 = (Ull)(ex2_outd    )>>r6&0xffff000000000000LL;
    t2 = (Ull)(ex2_outd<<16)>>r6&0xffff000000000000LL;
    t1 = (Ull)(ex2_outd<<32)>>r6&0xffff000000000000LL;
    t0 = (Ull)(ex2_outd<<48)>>r6&0xffff000000000000LL;
d616 1
a616 1
cex(Uint op_cx, Uchar c3, Uchar c2, Uchar c1, Uchar c0, Ushort pattern, Uchar *ex)
d618 57
a674 1
  Uint index1, index0;
d676 1
a676 1
  switch (op_cx) {
d678 4
d683 61
a743 6
  case OP_CEXE:
    index1 = ((c3>>1&1)<<3)|((c2>>1&1)<<2)|((c1>>1&1)<<1)|(c0>>1&1);
    index0 = ((c3   &1)<<3)|((c2   &1)<<2)|((c1   &1)<<1)|(c0   &1);
    *ex = 0;
    if (pattern>>index1&1) *ex |= 2;
    if (pattern>>index0&1) *ex |= 1;
d746 1
a746 1
    printf("emax5lib: cx: undefined op_cx=%d\n", op_cx);
d748 1
a748 1
  }  
@


1.6
log
@*** empty log message ***
@
text
@d11 140
a150 1
cex(Uint op_cx, Uchar c3, Uchar c2, Uchar c1, Uchar c0, Ushort pattern, Uchar *ex)
d152 115
a266 1
  Uint index1, index0;
d268 1
a268 1
  switch (op_cx) {
d271 7
a277 6
  case OP_CEXE:
    index1 = ((c3>>1&1)<<3)|((c2>>1&1)<<2)|((c1>>1&1)<<1)|(c0>>1&1);
    index0 = ((c3   &1)<<3)|((c2   &1)<<2)|((c1   &1)<<1)|(c0   &1);
    *ex = 0;
    if (pattern>>index1&1) *ex |= 2;
    if (pattern>>index0&1) *ex |= 1;
d280 1
a280 1
    printf("emax5lib: cx: undefined op_cx=%d\n", op_cx);
d282 1
a282 1
  }  
d432 1
a432 1
    ex1_outc = 0;
d658 1
a658 243
    printf("emax5lib: ex: undefined op_ex1=%d\n", op_ex1);
    break;
  }

  switch (op_ex2) {
  case OP_NOP:
    ex2_outd = ex1_outd;
    ex2_outc = ex1_outc;
    break;
  case OP_AND: /* 64bit 2in logical and s1&s2 */
    if (ex1_active) ex2_outd = ex1_outd & r5;
    else            ex2_outd = r4       & r5;
    ex2_outc = ex1_outc;
    break;
  case OP_OR: /* 64bit 2in logical or s1|s2 */
    if (ex1_active) ex2_outd = ex1_outd | r5;
    else            ex2_outd = r4       | r5;
    ex2_outc = ex1_outc;
    break;
  case OP_XOR: /* 64bit 2in logical xor s1^s2 */
    if (ex1_active) ex2_outd = ex1_outd ^ r5;
    else            ex2_outd = r4       ^ r5;
    ex2_outc = ex1_outc;
    break;
  case OP_SUMHH: /* 16bit*4 1in & s1.h3+s1.h2->d.h3, s1.h1+s1.h0->d.h1 */
    if (ex1_active) {
      t3 = ex1_outd>>48&0x000000000000ffffLL;
      t2 = ex1_outd>>32&0x000000000000ffffLL;
      t1 = ex1_outd>>16&0x000000000000ffffLL;
      t0 = ex1_outd    &0x000000000000ffffLL;
    }
    else {
      t3 = r4>>48&0x000000000000ffffLL;
      t2 = r4>>32&0x000000000000ffffLL;
      t1 = r4>>16&0x000000000000ffffLL;
      t0 = r4    &0x000000000000ffffLL;
    }
    t3 += t2;
    if (t3 > 0x000000000000ffffLL) t3 = 0x000000000000ffffLL;
    t1 += t0;
    if (t1 > 0x000000000000ffffLL) t1 = 0x000000000000ffffLL;
    ex2_outd = (t3<<48)|(t1<<16);
    ex2_outc = ex1_outc;
    break;
  case OP_SUMHL: /* 16bit*4 1in & s1.h3+s1.h2->d.h2, s1.h1+s1.h0->d.h0 */
    if (ex1_active) {
      t3 = ex1_outd>>48&0x000000000000ffffLL;
      t2 = ex1_outd>>32&0x000000000000ffffLL;
      t1 = ex1_outd>>16&0x000000000000ffffLL;
      t0 = ex1_outd    &0x000000000000ffffLL;
    }
    else {
      t3 = r4>>48&0x000000000000ffffLL;
      t2 = r4>>32&0x000000000000ffffLL;
      t1 = r4>>16&0x000000000000ffffLL;
      t0 = r4    &0x000000000000ffffLL;
    }
    t2 += t3;
    if (t2 > 0x000000000000ffffLL) t2 = 0x000000000000ffffLL;
    t0 += t1;
    if (t0 > 0x000000000000ffffLL) t0 = 0x000000000000ffffLL;
    ex2_outd = (t2<<32)|(t0);
    ex2_outc = ex1_outc;
    break;
  default:
    printf("emax5lib: ex: undefined op_ex2=%d\n", op_ex2);
    break;
  }

  switch (op_ex3) {
  case OP_NOP:
    if (d) *d = ex2_outd;
    if (c) *c = ex2_outc;
    break;
  case OP_SLL: /* 32bit*2 2in 32bit logical shift to left */
    t1 = (Ull)(ex2_outd    &0xffffffff00000000LL)<<r6;
    t0 = (Ull)(ex2_outd<<r6&0x00000000ffffffffLL);
    if (d) *d = t1 | t0;
    if (c) *c = ex2_outc;
    break;
  case OP_SRL: /* 32bit*2 2in 32bit logical shift to right */
    t1 = (Ull)(ex2_outd>>r6&0xffffffff00000000LL);
    t0 = (Ull)(ex2_outd    &0x00000000ffffffffLL)>>r6;
    if (d) *d = t1 | t0;
    if (c) *c = ex2_outc;
    break;
  case OP_SRAA: /* 32bit*2 2in 32bit arith shift to right (bit63,31 is ext.) */
    t1 = (Sll)(ex2_outd    )>>r6&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<32)>>r6&0xffffffff00000000LL;
    if (d) *d = t1 | (t0>>32);
    if (c) *c = ex2_outc;
    break;
  case OP_SRAB: /* 32bit*2 2in 32bit arith shift to right (bit55,23 is ext.) */
    t1 = (Sll)(ex2_outd<< 8)>>(r6+8)&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<40)>>(r6+8)&0xffffffff00000000LL;
    if (d) *d = t1 | (t0>>32);
    if (c) *c = ex2_outc;
    break;
  case OP_SRAC: /* 32bit*2 2in 32bit arith shift to right (bit47,15 is ext.) */
    t1 = (Sll)(ex2_outd<<16)>>(r6+16)&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<48)>>(r6+16)&0xffffffff00000000LL;
    if (d) *d = t1 | (t0>>32);
    if (c) *c = ex2_outc;
    break;
  case OP_SRAD: /* 32bit*2 2in 32bit arith shift to right (bit39,7 is ext.) */
    t1 = (Sll)(ex2_outd<<24)>>(r6+24)&0xffffffff00000000LL;
    t0 = (Sll)(ex2_outd<<56)>>(r6+24)&0xffffffff00000000LL;
    if (d) *d = t1 | (t0>>32);
    if (c) *c = ex2_outc;
    break;
  case OP_SRLM: /* 16bit*4 2in 16bit arith shift to right */
    t3 = (Ull)(ex2_outd    )>>r6&0xffff000000000000LL;
    t2 = (Ull)(ex2_outd<<16)>>r6&0xffff000000000000LL;
    t1 = (Ull)(ex2_outd<<32)>>r6&0xffff000000000000LL;
    t0 = (Ull)(ex2_outd<<48)>>r6&0xffff000000000000LL;
    if (d) *d = t3 | (t2>>16) | (t1>>32) | (t0>>48);
    if (c) *c = ex2_outc;
    break;
  default:
    printf("emax5lib: ex: undefined op_ex3=%d\n", op_ex3);
    break;
  }
}

void __attribute__((always_inline))
ex4(Uint op_ex1, Ull *r1, Uint exp1, Ull *r2, Uint exp2, Ull *r3, Uint exp3,
   Uint op_ex2, Ull *r4, Ull *r5,
   Uint op_ex3, Ull *r6,
   Ull *d, Uchar *c)
{
  Ull t3, t2, t1, t0;

  switch (op_ex1) {
  case OP_NOP:
    break;
  case OP_FMAQ: /* 64bit 3in floating-point r1+r2*r3 */
    *(double*)(d+0) = *(double*)(r1+0) + (*(double*)(r2+0) * *(double*)(r3+0));
    *(double*)(d+1) = *(double*)(r1+1) + (*(double*)(r2+1) * *(double*)(r3+1));
    *(double*)(d+2) = *(double*)(r1+2) + (*(double*)(r2+2) * *(double*)(r3+2));
    *(double*)(d+3) = *(double*)(r1+3) + (*(double*)(r2+3) * *(double*)(r3+3));
    break;
  case OP_FADQ: /* 64bit 2in floating-point r1+r2 */
    *(double*)(d+0) = *(double*)(r1+0) + *(double*)(r2+0);
    *(double*)(d+1) = *(double*)(r1+1) + *(double*)(r2+1);
    *(double*)(d+2) = *(double*)(r1+2) + *(double*)(r2+2);
    *(double*)(d+3) = *(double*)(r1+3) + *(double*)(r2+3);
    break;
  case OP_FMLQ: /* 64bit 2in floating-point r1*r2 */
    *(double*)(d+0) = *(double*)(r1+0) * *(double*)(r2+0);
    *(double*)(d+1) = *(double*)(r1+1) * *(double*)(r2+1);
    *(double*)(d+2) = *(double*)(r1+2) * *(double*)(r2+2);
    *(double*)(d+3) = *(double*)(r1+3) * *(double*)(r2+3);
    break;
  case OP_ADD3Q: /* 64bit 3in fixed-point r1+(r2+r3) */
    t2 = (*(r1+0)>>32&0x00000000ffffffffLL)+((*(r2+0)>>32&0x00000000ffffffffLL)+(*(r3+0)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+0)    &0x00000000ffffffffLL)+((*(r2+0)    &0x00000000ffffffffLL)+(*(r3+0)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+0) = (t2<<32)|(t0);
    t2 = (*(r1+1)>>32&0x00000000ffffffffLL)+((*(r2+1)>>32&0x00000000ffffffffLL)+(*(r3+1)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+1)    &0x00000000ffffffffLL)+((*(r2+1)    &0x00000000ffffffffLL)+(*(r3+1)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+1) = (t2<<32)|(t0);
    t2 = (*(r1+2)>>32&0x00000000ffffffffLL)+((*(r2+2)>>32&0x00000000ffffffffLL)+(*(r3+2)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+2)    &0x00000000ffffffffLL)+((*(r2+2)    &0x00000000ffffffffLL)+(*(r3+2)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+2) = (t2<<32)|(t0);
    t2 = (*(r1+3)>>32&0x00000000ffffffffLL)+((*(r2+3)>>32&0x00000000ffffffffLL)+(*(r3+3)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+3)    &0x00000000ffffffffLL)+((*(r2+3)    &0x00000000ffffffffLL)+(*(r3+3)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+3) = (t2<<32)|(t0);
    break;
  case OP_SUB3Q: /* 64bit 3in fixed-point r1-(r2+r3) */
    t2 = (*(r1+0)>>32&0x00000000ffffffffLL)-((*(r2+0)>>32&0x00000000ffffffffLL)+(*(r3+0)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+0)    &0x00000000ffffffffLL)-((*(r2+0)    &0x00000000ffffffffLL)+(*(r3+0)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+0) = (t2<<32)|(t0);
    t2 = (*(r1+1)>>32&0x00000000ffffffffLL)-((*(r2+1)>>32&0x00000000ffffffffLL)+(*(r3+1)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+1)    &0x00000000ffffffffLL)-((*(r2+1)    &0x00000000ffffffffLL)+(*(r3+1)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+1) = (t2<<32)|(t0);
    t2 = (*(r1+2)>>32&0x00000000ffffffffLL)-((*(r2+2)>>32&0x00000000ffffffffLL)+(*(r3+2)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+2)    &0x00000000ffffffffLL)-((*(r2+2)    &0x00000000ffffffffLL)+(*(r3+2)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+2) = (t2<<32)|(t0);
    t2 = (*(r1+3)>>32&0x00000000ffffffffLL)-((*(r2+3)>>32&0x00000000ffffffffLL)+(*(r3+3)>>32&0x00000000ffffffffLL));
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+3)    &0x00000000ffffffffLL)-((*(r2+3)    &0x00000000ffffffffLL)+(*(r3+3)    &0x00000000ffffffffLL));
    t0 &= 0x00000000ffffffffLL;
    *(d+3) = (t2<<32)|(t0);
    break;
  case OP_ADDQ: /* 64bit 2in fixed-point r1+r2 */
    t2 = (*(r1+0)>>32&0x00000000ffffffffLL)+(*(r2+0)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+0)    &0x00000000ffffffffLL)+(*(r2+0)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+0) = (t2<<32)|(t0);
    t2 = (*(r1+1)>>32&0x00000000ffffffffLL)+(*(r2+1)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+1)    &0x00000000ffffffffLL)+(*(r2+1)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+1) = (t2<<32)|(t0);
    t2 = (*(r1+2)>>32&0x00000000ffffffffLL)+(*(r2+2)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+2)    &0x00000000ffffffffLL)+(*(r2+2)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+2) = (t2<<32)|(t0);
    t2 = (*(r1+3)>>32&0x00000000ffffffffLL)+(*(r2+3)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+3)    &0x00000000ffffffffLL)+(*(r2+3)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+3) = (t2<<32)|(t0);
    break;
  case OP_SUBQ: /* 64bit 2in fixed-point r1-r2 */
    t2 = (*(r1+0)>>32&0x00000000ffffffffLL)-(*(r2+0)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+0)    &0x00000000ffffffffLL)-(*(r2+0)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+0) = (t2<<32)|(t0);
    t2 = (*(r1+1)>>32&0x00000000ffffffffLL)-(*(r2+1)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+1)    &0x00000000ffffffffLL)-(*(r2+1)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+1) = (t2<<32)|(t0);
    t2 = (*(r1+2)>>32&0x00000000ffffffffLL)-(*(r2+2)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+2)    &0x00000000ffffffffLL)-(*(r2+2)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+2) = (t2<<32)|(t0);
    t2 = (*(r1+3)>>32&0x00000000ffffffffLL)-(*(r2+3)>>32&0x00000000ffffffffLL);
    t2 &= 0x00000000ffffffffLL;
    t0 = (*(r1+3)    &0x00000000ffffffffLL)-(*(r2+3)    &0x00000000ffffffffLL);
    t0 &= 0x00000000ffffffffLL;
    *(d+3) = (t2<<32)|(t0);
    break;
  default:
    printf("emax5lib: ex4: undefined op_ex1=%d\n", op_ex1);
d664 57
d723 1
a723 1
    printf("emax5lib: ex4: illegal op_ex2=%d\n", op_ex2);
d729 2
d732 5
a736 2
  default:
    printf("emax5lib: ex4: illegal op_ex3=%d\n", op_ex3);
d738 5
a742 14
  }
}

void __attribute__((always_inline))
mop(Uint op_mm, Uchar ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull area_top, Uint dist, Uint len, Uchar force)
{
  Ull adr;
  Uchar c1, c0;

  c1 = ex>>1&1;
  c0 = ex   &1;

  switch (msk) {
  case  MSK_D0:
d744 5
a748 2
  case  MSK_W1:		
    offset = offset>>32;
d750 5
a754 2
  case  MSK_W0:
    offset = offset&0x00000000ffffffffLL;
d756 5
a760 2
  case  MSK_H3:
    offset = offset>>48&0x000000000000ffffLL;
d762 5
a766 2
  case  MSK_H2:
    offset = offset>>32&0x000000000000ffffLL;
d768 7
a774 29
  case  MSK_H1:
    offset = offset>>16&0x000000000000ffffLL;
    break;
  case  MSK_H0:
    offset = offset&0x000000000000ffffLL;
    break;
  case  MSK_B7:
    offset = offset>>56&0x00000000000000ffLL;
    break;
  case  MSK_B6:
    offset = offset>>48&0x00000000000000ffLL;
    break;
  case  MSK_B5:
    offset = offset>>40&0x00000000000000ffLL;
    break;
  case  MSK_B4:
    offset = offset>>32&0x00000000000000ffLL;
    break;
  case  MSK_B3:
    offset = offset>>24&0x00000000000000ffLL;
    break;
  case  MSK_B2:
    offset = offset>>16&0x00000000000000ffLL;
    break;
  case  MSK_B1:
    offset = offset>>8&0x00000000000000ffLL;
    break;
  case  MSK_B0:
    offset = offset&0x00000000000000ffLL;
d777 1
a777 1
    printf("emax5lib: mm: undefined msk=%d\n", msk);
d780 1
d782 4
a785 1
  adr = base + offset;
d787 1
a787 1
  switch (op_mm) {
a788 1
    if (d) *d = 0x0000000000000000LL;
d790 6
a795 64
  case OP_LDR: /* 64bit lmm LMM is preloaded, random-access */
    *d = *(Ull*)(adr&~7LL);
    break;
  case OP_LDWR: /* s32bit lmm LMM is preloaded, random-access */
    *d = (Sll)*(int*)(adr&~3LL);
    break;
  case OP_LDUWR: /* u32bit lmm LMM is preloaded, random-access */
    *d = (Ull)*(Uint*)(adr&~3LL);
    break;
  case OP_LDHR: /* s16bit lmm LMM is preloaded, random-access */
    *d = (Sll)*(short*)(adr&~1LL);
    break;
  case OP_LDUHR: /* u16bit lmm LMM is preloaded, random-access */
    *d = (Ull)*(Ushort*)(adr&~1LL);
    break;
  case OP_LDBR: /* s8bit lmm LMM is preloaded, random-access */
    *d = (Sll)*(char*)adr;
    break;
  case OP_LDUBR: /* u8bit lmm LMM is preloaded, random-access */
    *d = (Ull)*(Uchar*)adr;
    break;
  case OP_LDBF: /* 64bit buffered LMM is used as a buffer */
    *d = *(Ull*)(adr&~7LL);
    break;
  case OP_LDBFQ: /* 64bit*4 buffered LMM is used as a buffer */
    *(d+0) = *((Ull*)(adr&~7LL)+0);
    *(d+1) = *((Ull*)(adr&~7LL)+1);
    *(d+2) = *((Ull*)(adr&~7LL)+2);
    *(d+3) = *((Ull*)(adr&~7LL)+3);
    break;
  case OP_LDDMQ: /* 64bit*4 mem Direct access to MM */
    if (c0) {
      *(d+0) = *((Ull*)(adr&~7LL)+0);
      *(d+1) = *((Ull*)(adr&~7LL)+1);
      *(d+2) = *((Ull*)(adr&~7LL)+2);
      *(d+3) = *((Ull*)(adr&~7LL)+3);
    }
    break;
  case OP_STR: /* 64bit lmm LMM is drained. random-access */
    if (c1) *((Uint*)(adr&~7LL)+1) = *d>>32;
    if (c0) *((Uint*)(adr&~7LL)  ) = *d;
    break;
  case OP_STWR: /* 32bit lmm LMM is drained. random-access */
    if (c0) *(Uint*)(adr&~3LL) = *d;
    break;
  case OP_STHR: /* 16bit lmm LMM is drained. random-access */
    if (c0) *(Ushort*)(adr&~1LL) = *d;
    break;
  case OP_STBR: /* 8bit lmm LMM is drained. random-access */
    if (c0) *(Uchar*)adr = *d;
    break;
  case OP_STBF: /* 64bit buffered LMM is used as a buffer */
    *(Ull*)(adr&~7LL) = *d;
    break;
  case OP_STBFQ: /* 64bit*4 buffered LMM is used as a buffer */
    *((Ull*)(adr&~7LL)+0) = *(d+0);
    *((Ull*)(adr&~7LL)+1) = *(d+1);
    *((Ull*)(adr&~7LL)+2) = *(d+2);
    *((Ull*)(adr&~7LL)+3) = *(d+3);
    break;
  case OP_TR: /* 64bit*4 exec Send transaction */
    /* N/A */
    if (c0) {
    }
d798 1
a798 1
    printf("emax5lib: mm: undefined op_mm=%d\n", op_mm);
d800 1
a800 1
  }
@


1.5
log
@*** empty log message ***
@
text
@a1 2
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2d/RCS/emax5lib.c,v 1.4 2015/10/19 23:42:30 nakashim Exp nakashim $";

d11 1
a11 1
cx(Uint op_cx, Uchar c3, Uchar c2, Uchar c1, Uchar c0, Ushort pattern, Uchar *ex)
d32 1
a32 1
ex(Uint op_ex1, Ull r1, Uint exp1, Ull r2, Uint exp2, Ull r3, Uint exp3,
d668 1
a668 1
mm(Uint op_mm, Uchar ex, Ull *d, Ull base, Ull offset, Uchar msk, Ull area_top, Uint dist, Uint len, Uchar force)
@


1.4
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2d/RCS/emax5lib.c,v 1.3 2015/08/16 03:34:55 nakashim Exp nakashim $";
d297 2
a298 2
             | (((r2>>48&0x000000000000ff00LL) ? 255 : (r1>>48&0x00000000000000ffLL))<<40)
             | (((r2>>32&0x000000000000ff00LL) ? 255 : (r1>>32&0x00000000000000ffLL))<<32)
d516 5
a520 5
  case OP_SRAM: /* 16bit*4 2in 16bit arith shift to right */
    t3 = (Sll)(ex2_outd    )>>r6&0xffff000000000000LL;
    t2 = (Sll)(ex2_outd<<16)>>r6&0xffff000000000000LL;
    t1 = (Sll)(ex2_outd<<32)>>r6&0xffff000000000000LL;
    t0 = (Sll)(ex2_outd<<48)>>r6&0xffff000000000000LL;
@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2d/RCS/emax5lib.c,v 1.2 2015/08/09 12:58:39 nakashim Exp nakashim $";
d50 1
a50 1
  case EXP_B5410: r1 = (r1<<8&0x00ff000000000000LL) | (r1    &0x000000ff000000ffLL); break;
d55 1
a55 1
  case EXP_B5410: r2 = (r2<<8&0x00ff000000000000LL) | (r2    &0x000000ff000000ffLL); break;
d60 1
a60 1
  case EXP_B5410: r3 = (r3<<8&0x00ff000000000000LL) | (r3    &0x000000ff000000ffLL); break;
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2d/RCS/emax5lib.c,v 1.1 2015/08/09 12:19:25 nakashim Exp nakashim $";
d15 1
a15 1
  Uint index;
d21 5
a25 5
    index = (c3<<3)|(c2<<2)|(c1<<1)|(c0);
    if (pattern>>index&1)
      *ex = 1;
    else 
      *ex = 0;
d41 1
d66 1
a66 1
    ex1_outd = 0;
d95 90
a184 2
  case OP_MAUH3: /* 16bit*4 3in r1.pos+r2.pos+r3.pos */
    t3 = ( r1>>48&0x000000000000ffffLL)+(r2>>48&0x000000000000ffffLL)+(r3>>48&0x000000000000ffffLL);
d186 1
a186 1
    t2 = ( r1>>32&0x000000000000ffffLL)+(r2>>32&0x000000000000ffffLL)+(r3>>32&0x000000000000ffffLL);
d188 1
a188 1
    t1 = ( r1>>16&0x000000000000ffffLL)+(r2>>16&0x000000000000ffffLL)+(r3>>16&0x000000000000ffffLL);
d190 1
a190 1
    t0 = ( r1    &0x000000000000ffffLL)+(r2    &0x000000000000ffffLL)+(r3    &0x000000000000ffffLL);
a191 1
    ex1_active = 1;
d196 2
a197 1
    t3 = ( r1>>48&0x000000000000ffffLL)+(r2>>48&0x000000000000ffffLL);
d199 1
a199 1
    t2 = ( r1>>32&0x000000000000ffffLL)+(r2>>32&0x000000000000ffffLL);
d201 1
a201 1
    t1 = ( r1>>16&0x000000000000ffffLL)+(r2>>16&0x000000000000ffffLL);
d203 1
a203 1
    t0 = ( r1    &0x000000000000ffffLL)+(r2    &0x000000000000ffffLL);
a204 1
    ex1_active = 1;
d208 3
a210 2
  case OP_MSUH3: /* 16bit*4 3in r1.pos-r2.pos-r3.pos */
    t3 = ( r1>>48&0x000000000000ffffLL)-(r2>>48&0x000000000000ffffLL)-(r3>>48&0x000000000000ffffLL);
d212 1
a212 1
    t2 = ( r1>>32&0x000000000000ffffLL)-(r2>>32&0x000000000000ffffLL)-(r3>>32&0x000000000000ffffLL);
d214 1
a214 1
    t1 = ( r1>>16&0x000000000000ffffLL)-(r2>>16&0x000000000000ffffLL)-(r3>>16&0x000000000000ffffLL);
d216 1
a216 1
    t0 = ( r1    &0x000000000000ffffLL)-(r2    &0x000000000000ffffLL)-(r3    &0x000000000000ffffLL);
a217 1
    ex1_active = 1;
d222 1
a230 1
    ex1_active = 1;
d235 1
a243 1
    ex1_active = 1;
d247 1
a247 1
  case OP_MMRG: /* 8bit*8 3in r1.b4|r2.b4|r3.b4|0->w1, r1.b0|r2.b0|r3.b0|0->w0 */
d249 2
a250 1
    ex1_outd = ((r1&0x000000ff00000000LL)<<24) | ((r2&0x000000ff00000000LL)<<16) | ((r3&0x000000ff00000000LL)<<8) | ((r1&0x00000000000000ffLL)<<24) | ((r2&0x00000000000000ffLL)<<16) | ((r3&0x00000000000000ffLL)<<8);
d253 5
a257 4
  case OP_MSAD: /* 8bit*8 3in r1.h3+df(r2.b7,r3.b7)+df(r2.b6,r3.b6)->d.h3
                              r1.h2+df(r2.b5,r3.b5)+df(r2.b4,r3.b4)->d.h2
                              r1.h1+df(r2.b3,r3.b3)+df(r2.b2,r3.b2)->d.h1
                              r1.h0+df(r2.b1,r3.b1)+df(r2.b0,r3.b0)->d.h0 */
a265 1
    ex1_active = 1;
d271 1
a279 1
    ex1_active = 1;
d285 1
a289 1
    ex1_active = 1;
d305 2
a306 4
  case OP_MCAS: /* 32bit*2 2in (r1.w1<r2.w1)?0:0xff->d.b1
                               (r1.w0<r2.w0)?0:0xff->d.b0 */
    t1 = ((r1&0xffffffff00000000LL)<(r2&0xffffffff00000000LL))?0:0x000000000000ff00LL;
    t0 = ((r1&0x00000000ffffffffLL)<(r2&0x00000000ffffffffLL))?0:0x00000000000000ffLL;
d308 3
a310 1
    ex1_outd = t1 | t0;
d314 1
a330 1
    ex1_active = 1;
d342 1
a350 1
    ex1_active = 1;
d362 1
a370 1
    ex1_active = 1;
a404 55
  case OP_ADD3: /* 64bit 3in integer add s1+(s2+s3) */
    ex1_active = 1;
    ex1_outd = r1 + r2 + r3;
    ex1_outc = 0;
    break;
  case OP_SUB3: /* 64bit 3in integer subtract s1-(s2+s3) */
    ex1_active = 1;
    ex1_outd = r1 - r2 - r3;
    ex1_outc = 0;
    break;
  case OP_ADD: /* 64bit 2in integer add s1+s2 */
    ex1_active = 1;
    ex1_outd = r1 + r2;
    ex1_outc = 0;
    break;
  case OP_SUB: /* 64bit 2in integer subtract s1-s2 */
    ex1_active = 1;
    ex1_outd = r1 - r2;
    ex1_outc = 0;
    break;
  case OP_CMP_EQ: /* 64bit 2in compare and set 1bit-CC */
    ex1_active = 1;
    ex1_outd = 0;
    ex1_outc = r1 == r2;
    break;
  case OP_CMP_NE: /* 64bit 2in compare and set 1bit-CC */
    ex1_active = 1;
    ex1_outd = 0;
    ex1_outc = r1 != r2;
    break;
  case OP_CMP_LT: /* 64bit 2in compare and set 1bit-CC */
    ex1_active = 1;
    ex1_outd = 0;
    ex1_outc = r1 < r2;
    break;
  case OP_CMP_LE: /* 64bit 2in compare and set 1bit-CC */
    ex1_active = 1;
    ex1_outd = 0;
    ex1_outc = r1 <= r2;
    break;
  case OP_CMP_GT: /* 64bit 2in compare and set 1bit-CC */
    ex1_active = 1;
    ex1_outd = 0;
    ex1_outc = r1 > r2;
    break;
  case OP_CMP_GE: /* 64bit 2in compare and set 1bit-CC */
    ex1_active = 1;
    ex1_outd = 0;
    ex1_outc = r1 >= r2;
    break;
  case OP_CMOV: /* 1,64bit 2in conditional move */
    ex1_active = 1;
    ex1_outd = *c ? r1 : r2;
    ex1_outc = 0;
    break;
a469 24
  case OP_SUMWH: /* 32bit*2 1in & s1.w1+s1.w0->d.w1 */
    if (ex1_active) {
      t2 = ex1_outd>>32&0x00000000ffffffffLL;
      t0 = ex1_outd    &0x00000000ffffffffLL;
    }
    else {
      t2 = r4>>32&0x00000000ffffffffLL;
      t0 = r4    &0x00000000ffffffffLL;
    }
    ex2_outd = (t2+t0)<<32&0xffffffff00000000LL;
    ex2_outc = ex1_outc;
    break;
  case OP_SUMWL: /* 32bit*2 1in & s1.w1+s1.w0->d.w0 */
    if (ex1_active) {
      t2 = ex1_outd>>32&0x00000000ffffffffLL;
      t0 = ex1_outd    &0x00000000ffffffffLL;
    }
    else {
      t2 = r4>>32&0x00000000ffffffffLL;
      t0 = r4    &0x00000000ffffffffLL;
    }
    ex2_outd = (t2+t0)&0x00000000ffffffffLL;
    ex2_outc = ex1_outc;
    break;
d480 4
a483 6
  case OP_SLL: /* 64bit 2in 64bit logical shift to left */
    if (d) *d = ex2_outd<<r6;
    if (c) *c = ex2_outc;
    break;
  case OP_SRL: /* 64bit 2in 64bit logical shift to right */
    if (d) *d = ex2_outd>>r6;
d486 4
a489 6
  case OP_SRAM: /* 16bit*4 2in 16bit arith shift to right */
    t3 = (Sll)(ex2_outd    )>>r6&0xffff000000000000LL;
    t2 = (Sll)(ex2_outd<<16)>>r6&0xffff000000000000LL;
    t1 = (Sll)(ex2_outd<<32)>>r6&0xffff000000000000LL;
    t0 = (Sll)(ex2_outd<<48)>>r6&0xffff000000000000LL;
    if (d) *d = t3 | (t2>>16) | (t1>>32) | (t0>>48);
d516 8
d536 1
a536 3
  int ex1_active = 1;
  Ull ex1_out;
  Ull ex2_out;
a539 1
    ex1_active = 0;
d541 1
a541 1
  case OP_FMA_4: /* 64bit 3in floating-point r1+r2*r3 */
d547 1
a547 1
  case OP_FAD_4: /* 64bit 2in floating-point r1+r2 */
d553 1
a553 1
  case OP_FML_4: /* 64bit 2in floating-point r1*r2 */
d559 87
a645 23
  case OP_ADD3_4: /* 64bit 3in fixed-point r1+(r2+r3) */
    *(d+0) = *(r1+0) + *(r2+0) + *(r3+0);
    *(d+1) = *(r1+1) + *(r2+1) + *(r3+1);
    *(d+2) = *(r1+2) + *(r2+2) + *(r3+2);
    *(d+3) = *(r1+3) + *(r2+3) + *(r3+3);
    break;
  case OP_SUB3_4: /* 64bit 3in fixed-point r1-(r2+r3) */
    *(d+0) = *(r1+0) - *(r2+0) - *(r3+0);
    *(d+1) = *(r1+1) - *(r2+1) - *(r3+1);
    *(d+2) = *(r1+2) - *(r2+2) - *(r3+2);
    *(d+3) = *(r1+3) - *(r2+3) - *(r3+3);
    break;
  case OP_ADD_4: /* 64bit 2in fixed-point r1+r2 */
    *(d+0) = *(r1+0) + *(r2+0);
    *(d+1) = *(r1+1) + *(r2+1);
    *(d+2) = *(r1+2) + *(r2+2);
    *(d+3) = *(r1+3) + *(r2+3);
    break;
  case OP_SUB_4: /* 64bit 2in fixed-point r1-r2 */
    *(d+0) = *(r1+0) - *(r2+0);
    *(d+1) = *(r1+1) - *(r2+1);
    *(d+2) = *(r1+2) - *(r2+2);
    *(d+3) = *(r1+3) - *(r2+3);
d673 1
d675 2
a676 1
  if (!ex) return;
a733 3
  case OP_LDB: /* 64bit buffered LMM is used as a buffer */
    *d = *(Ull*)(adr&~7LL);
    break;
d755 16
a770 2
  case OP_STB: /* 64bit buffered LMM is used as a buffer */
    *(Ull*)(adr&~7LL) = *d;
d773 2
a774 1
    *(Ull*)(adr&~7LL) = *d;
d777 1
a777 1
    *(Uint*)(adr&~3LL) = *d;
d780 1
a780 1
    *(Ushort*)(adr&~1LL) = *d;
d783 1
a783 1
    *(Uchar*)adr = *d;
d785 2
a786 11
  case OP_LDB_4: /* 64bit*4 buffered LMM is used as a buffer */
    *(d+0) = *((Ull*)(adr&~7LL)+0);
    *(d+1) = *((Ull*)(adr&~7LL)+1);
    *(d+2) = *((Ull*)(adr&~7LL)+2);
    *(d+3) = *((Ull*)(adr&~7LL)+3);
    break;
  case OP_LDM_4: /* 64bit*4 mem Direct access to MM */
    *(d+0) = *((Ull*)(adr&~7LL)+0);
    *(d+1) = *((Ull*)(adr&~7LL)+1);
    *(d+2) = *((Ull*)(adr&~7LL)+2);
    *(d+3) = *((Ull*)(adr&~7LL)+3);
d788 1
a788 1
  case OP_STB_4: /* 64bit*4 buffered LMM is used as a buffer */
d796 2
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm32/sample/4dimage/RCS/gdepth.c,v 1.1 2015/06/11 22:51:02 nakashim Exp nakashim $";
d34 1
a34 1
ex(Uint op_ex1, Uchar init, Ull r1, Uint exp1, Ull r2, Uint exp2, Ull r3, Uint exp3,
a83 8
  case OP_FMAA: /* 64bit*4 3in floating-point r1+=r2*r3 */
    ex1_active = 1;
    if (init)
      *(double*)&ex1_outd = *(double*)&r1 + (*(double*)&r2 * *(double*)&r3);
    else
      *(double*)&ex1_outd = *(double*)d   + (*(double*)&r2 * *(double*)&r3);
    ex1_outc = 0;
    break;
a88 8
  case OP_FADA: /* 64bit 3in floating-point r1+=r2 */
    ex1_active = 1;
    if (init)
      *(double*)&ex1_outd = *(double*)&r1 + *(double*)&r2;
    else
      *(double*)&ex1_outd = *(double*)d   + *(double*)&r2;
    ex1_outc = 0;
    break;
a320 8
  case OP_ADDA3: /* 64bit 3in integer add s1+=(s2+s3) */
    ex1_active = 1;
    if (init)
      ex1_outd = r1 + r2 + r3;
    else
      ex1_outd = *d + r2 + r3;
    ex1_outc = 0;
    break;
a325 8
  case OP_SUBA3: /* 64bit 3in integer subtract s1-=(s2+s3) */
    ex1_active = 1;
    if (init)
      ex1_outd = r1 - r2 - r3;
    else
      ex1_outd = *d - r2 - r3;
    ex1_outc = 0;
    break;
a330 8
  case OP_ADDA: /* 64bit 2in integer add s1+=s2 */
    ex1_active = 1;
    if (init)
      ex1_outd = r1 + r2;
    else
      ex1_outd = *d + r2;
    ex1_outc = 0;
    break;
a335 8
  case OP_SUBA: /* 64bit 2in integer subtract s1-=s2 */
    ex1_active = 1;
    if (init)
      ex1_outd = r1 - r2;
    else
      ex1_outd = *d - r2;
    ex1_outc = 0;
    break;
d517 1
a517 1
ex4(Uint op_ex1, Uchar init, Ull *r1, Uint exp1, Ull *r2, Uint exp2, Ull *r3, Uint exp3,
a535 14
  case OP_FMAA_4: /* 64bit 3in floating-point r1+=r2*r3 */
    if (init) {
      *(double*)(d+0) = *(double*)(r1+0) + (*(double*)(r2+0) * *(double*)(r3+0));
      *(double*)(d+1) = *(double*)(r1+1) + (*(double*)(r2+1) * *(double*)(r3+1));
      *(double*)(d+2) = *(double*)(r1+2) + (*(double*)(r2+2) * *(double*)(r3+2));
      *(double*)(d+3) = *(double*)(r1+3) + (*(double*)(r2+3) * *(double*)(r3+3));
    }
    else {
      *(double*)(d+0) = *(double*)(d+0)  + (*(double*)(r2+0) * *(double*)(r3+0));
      *(double*)(d+1) = *(double*)(d+1)  + (*(double*)(r2+1) * *(double*)(r3+1));
      *(double*)(d+2) = *(double*)(d+2)  + (*(double*)(r2+2) * *(double*)(r3+2));
      *(double*)(d+3) = *(double*)(d+3)  + (*(double*)(r2+3) * *(double*)(r3+3));
    }
    break;
a541 14
  case OP_FADA_4: /* 64bit 2in floating-point r1+=r2 */
    if (init) {
      *(double*)(d+0) = *(double*)(r1+0) + *(double*)(r2+0);
      *(double*)(d+1) = *(double*)(r1+1) + *(double*)(r2+1);
      *(double*)(d+2) = *(double*)(r1+2) + *(double*)(r2+2);
      *(double*)(d+3) = *(double*)(r1+3) + *(double*)(r2+3);
    }
    else {
      *(double*)(d+0) = *(double*)(d+0)  + *(double*)(r2+0);
      *(double*)(d+1) = *(double*)(d+1)  + *(double*)(r2+1);
      *(double*)(d+2) = *(double*)(d+2)  + *(double*)(r2+2);
      *(double*)(d+3) = *(double*)(d+3)  + *(double*)(r2+3);
    }
    break;
a553 14
  case OP_ADDA3_4: /* 64bit 3in fixed-point r1+=r2+r3 */
    if (init) {
      *(d+0) = *(r1+0) + *(r2+0) + *(r3+0);
      *(d+1) = *(r1+1) + *(r2+1) + *(r3+1);
      *(d+2) = *(r1+2) + *(r2+2) + *(r3+2);
      *(d+3) = *(r1+3) + *(r2+3) + *(r3+3);
    }
    else {
      *(d+0) = *(d+0)  + *(r2+0) + *(r3+0);
      *(d+1) = *(d+1)  + *(r2+1) + *(r3+1);
      *(d+2) = *(d+2)  + *(r2+2) + *(r3+2);
      *(d+3) = *(d+3)  + *(r2+3) + *(r3+3);
    }
    break;
a559 14
  case OP_SUBA3_4: /* 64bit 3in fixed-point r1-=(r2+r3) */
    if (init) {
      *(d+0) = *(r1+0) - *(r2+0) - *(r3+0);
      *(d+1) = *(r1+1) - *(r2+1) - *(r3+1);
      *(d+2) = *(r1+2) - *(r2+2) - *(r3+2);
      *(d+3) = *(r1+3) - *(r2+3) - *(r3+3);
    }
    else {
      *(d+0) = *(d+0)  - *(r2+0) - *(r3+0);
      *(d+1) = *(d+1)  - *(r2+1) - *(r3+0);
      *(d+2) = *(d+2)  - *(r2+2) - *(r3+0);
      *(d+3) = *(d+3)  - *(r2+3) - *(r3+0);
    }
    break;
a565 14
  case OP_ADDA_4: /* 64bit 2in fixed-point r1+=r2 */
    if (init) {
      *(d+0) = *(r1+0) + *(r2+0);
      *(d+1) = *(r1+1) + *(r2+1);
      *(d+2) = *(r1+2) + *(r2+2);
      *(d+3) = *(r1+3) + *(r2+3);
    }
    else {
      *(d+0) = *(d+0)  + *(r2+0);
      *(d+1) = *(d+1)  + *(r2+1);
      *(d+2) = *(d+2)  + *(r2+2);
      *(d+3) = *(d+3)  + *(r2+3);
    }
    break;
a571 14
  case OP_SUBA_4: /* 64bit 2in fixed-point r1-=r2 */
    if (init) {
      *(d+0) = *(r1+0) - *(r2+0);
      *(d+1) = *(r1+1) - *(r2+1);
      *(d+2) = *(r1+2) - *(r2+2);
      *(d+3) = *(r1+3) - *(r2+3);
    }
    else {
      *(d+0) = *(d+0)  - *(r2+0);
      *(d+1) = *(d+1)  - *(r2+1);
      *(d+2) = *(d+2)  - *(r2+2);
      *(d+3) = *(d+3)  - *(r2+3);
    }
    break;
@
