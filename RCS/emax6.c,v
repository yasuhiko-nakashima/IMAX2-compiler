head	1.151;
access;
symbols;
locks
	nakashim:1.151; strict;
comment	@ * @;


1.151
date	2022.11.14.09.26.38;	author nakashim;	state Exp;
branches;
next	1.150;

1.150
date	2022.10.29.13.09.55;	author nakashim;	state Exp;
branches;
next	1.149;

1.149
date	2022.10.29.10.50.42;	author nakashim;	state Exp;
branches;
next	1.148;

1.148
date	2022.10.29.09.30.20;	author nakashim;	state Exp;
branches;
next	1.147;

1.147
date	2022.10.29.05.08.58;	author nakashim;	state Exp;
branches;
next	1.146;

1.146
date	2022.10.28.22.19.47;	author nakashim;	state Exp;
branches;
next	1.145;

1.145
date	2022.10.28.12.57.14;	author nakashim;	state Exp;
branches;
next	1.144;

1.144
date	2022.10.28.09.11.09;	author nakashim;	state Exp;
branches;
next	1.143;

1.143
date	2022.10.28.08.41.47;	author nakashim;	state Exp;
branches;
next	1.142;

1.142
date	2022.10.28.04.45.01;	author nakashim;	state Exp;
branches;
next	1.141;

1.141
date	2022.10.27.09.55.53;	author nakashim;	state Exp;
branches;
next	1.140;

1.140
date	2022.10.27.02.49.46;	author nakashim;	state Exp;
branches;
next	1.139;

1.139
date	2022.10.27.00.43.27;	author nakashim;	state Exp;
branches;
next	1.138;

1.138
date	2022.10.26.10.46.02;	author nakashim;	state Exp;
branches;
next	1.137;

1.137
date	2022.10.26.09.40.59;	author nakashim;	state Exp;
branches;
next	1.136;

1.136
date	2022.10.25.23.18.57;	author nakashim;	state Exp;
branches;
next	1.135;

1.135
date	2022.10.17.05.09.21;	author nakashim;	state Exp;
branches;
next	1.134;

1.134
date	2022.10.16.21.28.36;	author nakashim;	state Exp;
branches;
next	1.133;

1.133
date	2022.10.16.14.10.45;	author nakashim;	state Exp;
branches;
next	1.132;

1.132
date	2022.10.11.08.05.12;	author nakashim;	state Exp;
branches;
next	1.131;

1.131
date	2022.10.07.10.30.22;	author nakashim;	state Exp;
branches;
next	1.130;

1.130
date	2022.09.08.09.28.14;	author nakashim;	state Exp;
branches;
next	1.129;

1.129
date	2022.03.13.23.50.35;	author nakashim;	state Exp;
branches;
next	1.128;

1.128
date	2022.03.04.04.05.31;	author nakashim;	state Exp;
branches;
next	1.127;

1.127
date	2022.03.04.02.49.45;	author nakashim;	state Exp;
branches;
next	1.126;

1.126
date	2022.03.03.14.57.51;	author nakashim;	state Exp;
branches;
next	1.125;

1.125
date	2022.02.24.07.38.11;	author nakashim;	state Exp;
branches;
next	1.124;

1.124
date	2022.02.19.00.49.30;	author nakashim;	state Exp;
branches;
next	1.123;

1.123
date	2022.02.17.03.43.18;	author nakashim;	state Exp;
branches;
next	1.122;

1.122
date	2022.01.25.23.55.20;	author nakashim;	state Exp;
branches;
next	1.121;

1.121
date	2022.01.04.10.50.49;	author nakashim;	state Exp;
branches;
next	1.120;

1.120
date	2022.01.04.10.47.19;	author nakashim;	state Exp;
branches;
next	1.119;

1.119
date	2022.01.04.10.42.52;	author nakashim;	state Exp;
branches;
next	1.118;

1.118
date	2022.01.04.10.36.31;	author nakashim;	state Exp;
branches;
next	1.117;

1.117
date	2022.01.04.09.27.54;	author nakashim;	state Exp;
branches;
next	1.116;

1.116
date	2022.01.04.08.36.13;	author nakashim;	state Exp;
branches;
next	1.115;

1.115
date	2022.01.04.07.02.45;	author nakashim;	state Exp;
branches;
next	1.114;

1.114
date	2022.01.03.12.08.31;	author nakashim;	state Exp;
branches;
next	1.113;

1.113
date	2022.01.03.10.35.46;	author nakashim;	state Exp;
branches;
next	1.112;

1.112
date	2022.01.03.08.41.06;	author nakashim;	state Exp;
branches;
next	1.111;

1.111
date	2021.12.25.23.56.03;	author nakashim;	state Exp;
branches;
next	1.110;

1.110
date	2021.12.25.10.59.45;	author nakashim;	state Exp;
branches;
next	1.109;

1.109
date	2021.12.25.07.01.53;	author nakashim;	state Exp;
branches;
next	1.108;

1.108
date	2021.12.25.06.01.16;	author nakashim;	state Exp;
branches;
next	1.107;

1.107
date	2021.12.25.02.44.11;	author nakashim;	state Exp;
branches;
next	1.106;

1.106
date	2021.12.24.13.51.42;	author nakashim;	state Exp;
branches;
next	1.105;

1.105
date	2021.12.23.10.41.24;	author nakashim;	state Exp;
branches;
next	1.104;

1.104
date	2021.12.23.09.46.04;	author nakashim;	state Exp;
branches;
next	1.103;

1.103
date	2021.12.23.06.26.39;	author nakashim;	state Exp;
branches;
next	1.102;

1.102
date	2021.12.22.23.39.03;	author nakashim;	state Exp;
branches;
next	1.101;

1.101
date	2021.12.22.12.30.38;	author nakashim;	state Exp;
branches;
next	1.100;

1.100
date	2021.12.22.11.33.56;	author nakashim;	state Exp;
branches;
next	1.99;

1.99
date	2021.12.22.04.35.38;	author nakashim;	state Exp;
branches;
next	1.98;

1.98
date	2021.12.22.02.41.12;	author nakashim;	state Exp;
branches;
next	1.97;

1.97
date	2021.12.21.03.59.49;	author nakashim;	state Exp;
branches;
next	1.96;

1.96
date	2021.12.16.14.28.32;	author nakashim;	state Exp;
branches;
next	1.95;

1.95
date	2021.12.16.10.44.50;	author nakashim;	state Exp;
branches;
next	1.94;

1.94
date	2021.12.16.09.22.27;	author nakashim;	state Exp;
branches;
next	1.93;

1.93
date	2021.12.16.05.39.51;	author nakashim;	state Exp;
branches;
next	1.92;

1.92
date	2021.12.16.00.09.52;	author nakashim;	state Exp;
branches;
next	1.91;

1.91
date	2021.12.15.23.31.09;	author nakashim;	state Exp;
branches;
next	1.90;

1.90
date	2021.12.08.00.58.43;	author nakashim;	state Exp;
branches;
next	1.89;

1.89
date	2021.09.21.07.42.15;	author nakashim;	state Exp;
branches;
next	1.88;

1.88
date	2021.08.11.10.54.45;	author nakashim;	state Exp;
branches;
next	1.87;

1.87
date	2021.08.11.04.45.48;	author nakashim;	state Exp;
branches;
next	1.86;

1.86
date	2021.06.18.03.04.05;	author nakashim;	state Exp;
branches;
next	1.85;

1.85
date	2021.06.10.13.44.07;	author nakashim;	state Exp;
branches;
next	1.84;

1.84
date	2021.06.08.12.05.28;	author nakashim;	state Exp;
branches;
next	1.83;

1.83
date	2021.06.08.09.18.14;	author nakashim;	state Exp;
branches;
next	1.82;

1.82
date	2021.06.08.07.36.27;	author nakashim;	state Exp;
branches;
next	1.81;

1.81
date	2021.06.06.06.24.28;	author nakashim;	state Exp;
branches;
next	1.80;

1.80
date	2021.03.12.04.19.27;	author nakashim;	state Exp;
branches;
next	1.79;

1.79
date	2021.02.28.05.58.02;	author nakashim;	state Exp;
branches;
next	1.78;

1.78
date	2020.12.13.23.26.44;	author nakashim;	state Exp;
branches;
next	1.77;

1.77
date	2020.11.25.00.52.40;	author nakashim;	state Exp;
branches;
next	1.76;

1.76
date	2020.11.25.00.18.08;	author nakashim;	state Exp;
branches;
next	1.75;

1.75
date	2020.11.16.13.15.28;	author nakashim;	state Exp;
branches;
next	1.74;

1.74
date	2020.08.30.12.10.39;	author nakashim;	state Exp;
branches;
next	1.73;

1.73
date	2020.07.15.23.18.48;	author nakashim;	state Exp;
branches;
next	1.72;

1.72
date	2020.07.05.09.40.38;	author nakashim;	state Exp;
branches;
next	1.71;

1.71
date	2020.07.03.03.41.58;	author nakashim;	state Exp;
branches;
next	1.70;

1.70
date	2020.06.05.04.06.27;	author nakashim;	state Exp;
branches;
next	1.69;

1.69
date	2020.06.01.03.10.33;	author nakashim;	state Exp;
branches;
next	1.68;

1.68
date	2020.05.26.11.33.26;	author nakashim;	state Exp;
branches;
next	1.67;

1.67
date	2020.05.05.13.55.38;	author nakashim;	state Exp;
branches;
next	1.66;

1.66
date	2019.03.17.23.31.28;	author nakashim;	state Exp;
branches;
next	1.65;

1.65
date	2019.03.17.13.17.46;	author nakashim;	state Exp;
branches;
next	1.64;

1.64
date	2019.02.23.13.38.29;	author nakashim;	state Exp;
branches;
next	1.63;

1.63
date	2019.02.21.00.40.36;	author nakashim;	state Exp;
branches;
next	1.62;

1.62
date	2019.02.17.12.45.35;	author nakashim;	state Exp;
branches;
next	1.61;

1.61
date	2018.12.19.02.00.31;	author nakashim;	state Exp;
branches;
next	1.60;

1.60
date	2018.12.19.01.59.41;	author nakashim;	state Exp;
branches;
next	1.59;

1.59
date	2018.12.18.22.59.17;	author nakashim;	state Exp;
branches;
next	1.58;

1.58
date	2018.12.09.03.31.28;	author nakashim;	state Exp;
branches;
next	1.57;

1.57
date	2018.12.08.12.05.43;	author nakashim;	state Exp;
branches;
next	1.56;

1.56
date	2018.12.08.00.37.52;	author nakashim;	state Exp;
branches;
next	1.55;

1.55
date	2018.12.07.02.51.33;	author nakashim;	state Exp;
branches;
next	1.54;

1.54
date	2018.11.30.04.30.18;	author nakashim;	state Exp;
branches;
next	1.53;

1.53
date	2018.11.30.01.09.23;	author nakashim;	state Exp;
branches;
next	1.52;

1.52
date	2018.11.26.10.18.38;	author nakashim;	state Exp;
branches;
next	1.51;

1.51
date	2018.11.25.08.45.13;	author nakashim;	state Exp;
branches;
next	1.50;

1.50
date	2018.11.25.02.28.37;	author nakashim;	state Exp;
branches;
next	1.49;

1.49
date	2018.11.15.00.49.07;	author nakashim;	state Exp;
branches;
next	1.48;

1.48
date	2018.11.14.01.43.29;	author nakashim;	state Exp;
branches;
next	1.47;

1.47
date	2018.10.18.12.42.55;	author nakashim;	state Exp;
branches;
next	1.46;

1.46
date	2018.10.16.13.26.30;	author nakashim;	state Exp;
branches;
next	1.45;

1.45
date	2018.09.10.23.56.03;	author nakashim;	state Exp;
branches;
next	1.44;

1.44
date	2018.09.10.11.45.48;	author nakashim;	state Exp;
branches;
next	1.43;

1.43
date	2018.09.10.08.48.53;	author nakashim;	state Exp;
branches;
next	1.42;

1.42
date	2018.09.10.04.29.31;	author nakashim;	state Exp;
branches;
next	1.41;

1.41
date	2018.09.09.10.26.36;	author nakashim;	state Exp;
branches;
next	1.40;

1.40
date	2018.09.09.04.26.53;	author nakashim;	state Exp;
branches;
next	1.39;

1.39
date	2018.09.09.02.27.06;	author nakashim;	state Exp;
branches;
next	1.38;

1.38
date	2018.09.08.16.32.07;	author nakashim;	state Exp;
branches;
next	1.37;

1.37
date	2018.09.07.02.03.55;	author nakashim;	state Exp;
branches;
next	1.36;

1.36
date	2018.09.05.22.59.50;	author nakashim;	state Exp;
branches;
next	1.35;

1.35
date	2018.09.04.02.01.47;	author nakashim;	state Exp;
branches;
next	1.34;

1.34
date	2018.02.21.04.19.35;	author nakashim;	state Exp;
branches;
next	1.33;

1.33
date	2018.02.21.03.17.05;	author nakashim;	state Exp;
branches;
next	1.32;

1.32
date	2018.02.20.03.46.55;	author nakashim;	state Exp;
branches;
next	1.31;

1.31
date	2018.02.20.01.12.36;	author nakashim;	state Exp;
branches;
next	1.30;

1.30
date	2018.02.17.16.15.10;	author nakashim;	state Exp;
branches;
next	1.29;

1.29
date	2018.02.16.06.37.02;	author nakashim;	state Exp;
branches;
next	1.28;

1.28
date	2018.02.14.10.01.46;	author nakashim;	state Exp;
branches;
next	1.27;

1.27
date	2018.02.09.09.39.15;	author nakashim;	state Exp;
branches;
next	1.26;

1.26
date	2017.12.24.14.12.32;	author nakashim;	state Exp;
branches;
next	1.25;

1.25
date	2017.09.13.04.55.35;	author nakashim;	state Exp;
branches;
next	1.24;

1.24
date	2017.09.12.09.15.58;	author nakashim;	state Exp;
branches;
next	1.23;

1.23
date	2017.08.19.04.38.04;	author nakashim;	state Exp;
branches;
next	1.22;

1.22
date	2017.08.19.02.53.20;	author nakashim;	state Exp;
branches;
next	1.21;

1.21
date	2017.08.18.12.27.17;	author nakashim;	state Exp;
branches;
next	1.20;

1.20
date	2017.08.17.01.31.09;	author nakashim;	state Exp;
branches;
next	1.19;

1.19
date	2017.08.16.15.32.38;	author nakashim;	state Exp;
branches;
next	1.18;

1.18
date	2017.08.16.06.33.55;	author nakashim;	state Exp;
branches;
next	1.17;

1.17
date	2017.08.14.13.19.05;	author nakashim;	state Exp;
branches;
next	1.16;

1.16
date	2017.08.13.13.36.12;	author nakashim;	state Exp;
branches;
next	1.15;

1.15
date	2017.08.12.08.51.58;	author nakashim;	state Exp;
branches;
next	1.14;

1.14
date	2017.08.09.13.52.33;	author nakashim;	state Exp;
branches;
next	1.13;

1.13
date	2017.07.25.07.18.47;	author nakashim;	state Exp;
branches;
next	1.12;

1.12
date	2017.07.19.00.04.08;	author nakashim;	state Exp;
branches;
next	1.11;

1.11
date	2017.07.18.09.21.35;	author nakashim;	state Exp;
branches;
next	1.10;

1.10
date	2017.06.14.23.32.32;	author nakashim;	state Exp;
branches;
next	1.9;

1.9
date	2017.06.10.08.10.36;	author nakashim;	state Exp;
branches;
next	1.8;

1.8
date	2017.06.04.14.32.23;	author nakashim;	state Exp;
branches;
next	1.7;

1.7
date	2017.06.04.09.12.29;	author nakashim;	state Exp;
branches;
next	1.6;

1.6
date	2017.06.03.05.05.23;	author nakashim;	state Exp;
branches;
next	1.5;

1.5
date	2017.06.03.01.22.04;	author nakashim;	state Exp;
branches;
next	1.4;

1.4
date	2017.06.03.00.11.09;	author nakashim;	state Exp;
branches;
next	1.3;

1.3
date	2017.06.02.08.37.37;	author nakashim;	state Exp;
branches;
next	1.2;

1.2
date	2017.06.02.02.14.11;	author nakashim;	state Exp;
branches;
next	1.1;

1.1
date	2017.06.02.02.00.52;	author nakashim;	state Exp;
branches;
next	;


desc
@@


1.151
log
@*** empty log message ***
@
text
@
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.150 2022/10/29 13:09:55 nakashim Exp nakashim $";

/* EMAX6 Compiler                      */
/*         Copyright (C) 2012 by NAIST */
/*         Primary writer: Y.Nakashima */
/*                nakashim@@is.naist.jp */

/* emax6.c 2012/9/22 */

#include <stdio.h>
#include "conv-c2c.h"
#include "emax6.h"

emit_emax6a(int mode) /* 0:array, 1:drain */
{
  int c, i, j, k, flag;
  int last_row = -1; /* last location */
  int last_col = -1; /* last location */
  int last_mop = -1; /* 0:mop0, 1:mop1 */
  int folding;
  struct cex *dcex;
  struct exu *dexu;
  struct mex *dmex;
  struct mop *dmop0, *dmop1;

  if (mode == 1) { /* emit drain */
    fprintf(ofile, "#ifndef EMAXSC\n");
    goto mode_drain_dirty_lmm;
  }

  /**********************************************************************************************************/
  /* ●insn[]に格納されるオペランド種類（★は絶対位置指定因子）                                             */
  /*              T_IMMEDIATE  T_VARIABLE              T_EXRNO     T_ALRNO                  T_BDRNO         */
  /* ------------------------------------------------------------------------------------------------------ */
  /* while_src1 :              VARIABLE,                                                                    */
  /* while_src2 : IMMEDIATE,                                                                                */
  /* while_dst  :              VARIABLE,                                                                    */
  /* ------------------------------------------------------------------------------------------------------ */
  /* cex_src    : IMMEDIATE,   VARIABLE,                                                                    */
  /* cex_dst    :                                       &EXRNO                                              */
  /* ------------------------------------------------------------------------------------------------------ */
  /* ex4_src    :                          VARIABLE([]),           ALRNO[r]([]),            BDRNO[r][c]([]) */
  /*                                     前段alu出力はBDRNO[r][*][2]を経由 前段ld出力はBDRNO[r][c][*]を経由 */
  /* ex4_dstd   :                          VARIABLE([]),         ★ALRNO[r]([]),       次段伝搬時にはBR経由 */
  /*                                       自段のalu出力           自段のalu出力       コンパイラが自動配置 */
  /* ------------------------------------------------------------------------------------------------------ */
  /* exe_src1   : IMMEDIATE,   VARIABLE,   VARIABLE[s],            ALRNO[r][s],             BDRNO[r][c][s]  */
  /* exe_src2   : IMMEDIATE,   VARIABLE,   VARIABLE[s],            ALRNO[r][s],             BDRNO[r][c][s]  */
  /* exe_src3   : IMMEDIATE,   VARIABLE,   VARIABLE[s],            ALRNO[r][s],             BDRNO[r][c][s]  */
  /* exe_src4   : IMMEDIATE,   VARIABLE,   VARIABLE[s],            ALRNO[r][s],             BDRNO[r][c][s]  */
  /* exe_src5   : IMMEDIATE,   VARIABLE,   VARIABLE[s],            ALRNO[r][s],             BDRNO[r][c][s]  */
  /* exe_dstd   :             &VARIABLE,  &VARIABLE[s],         ★&ALRNO[r][s],                             */
  /* ------------------------------------------------------------------------------------------------------ */
  /* mop_ex     : IMMEDIATE,                           ▲EXRNO                                              */
  /* mo4_srcdst :                          VARIABLE([]),           ALRNO[r]([]),          ★BDRNO[r][c]([]) */
  /*                                            store4,                 store4,                       load4 */
  /* mop_srcdst :             &VARIABLE,  &VARIABLE[s],           &ALRNO[r][s],          ★&BDRNO[r][c][01] */
  /*                             store1,        store1, store1,         store1,                       load1 */
  /*               store-dataのvariable/gprnoは,必ず同一段のALU出力.前段のBRをstoreする場合は,必ずALUを通す */
  /* mop_base   :              VARIABLE,    VARIABLE[s],                                    BDRNO[r][c][s]  */
  /* mop.offset : IMMEDIATE,   VARIABLE,    VARIABLE[s],                                    BDRNO[r][c][s]  */
  /* mop.stream :              VARIABLE,                                                                    */
  /**********************************************************************************************************/
  /* ●insn[]->decode[r][c] 配置ルール                                                                      */
  /*   ★絶対配置（当面配置ヒントに使用．将来的には削除）                                                   */
  /* - ex4(),exe():            dstにALRNO[]かBDRNO[][]が指定されている場合,指定位置に配置                   */
  /* - mo4(load),mop(load):    dstにBDRNO[][]が指定されている場合,指定位置に配置                            */
  /*   ▲隣接配置                                                                                           */
  /* - cex():                  srcにcxが指定されている場合,cx生成段の次段に配置                             */
  /* - mo4(exx):               srcにexxが指定されている場合,exx生成段と同段に配置                           */
  /**********************************************************************************************************/
  /*******************************************************************************************************************************************************/
  /* ●lmmi指示ルール (copy from conv-c2c/emac5.c)                                                                  lmmi-loc  v  top  blk  len  rw  f  p */
  /* LD with force-read=0 and ptop==NULL generates current(lmr) and reuse LMM. same as lmr in EMAX4                     curr  1  top  blk  len   0  0  0 */
  /* LD with force-read=1 and ptop==NULL generates current(lmf) and !reuse LMM. same as lmf in EMAX4                    curr  1  top  blk  len   0  1  0 */
  /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist!=0                               curr  1  top  blk  len   0  0  0 */
  /*                                                                                                                  c+dist  1 ptop  blk  len   0  0  1 */
  /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   0  0  1 */
  /*                                                                                                               p=1の場合,pref-addrは常にlmmi.top+ofs */
  /* LDDMQ set f=1 and p=1 in lmmc automatically                                                                        curr  1  top  -    -     0  1  1 */
  /*******************************************************************************************************************************************************/
  /* ST with force-read=0 and ptop==NULL generates current(lmw) and reuse+wback LMM. same as lmw in EMAX4               curr  1  top  blk  len   1  0  0 */
  /* ST with force-read=1 and ptop==NULL generates current(lmx) and !reuse+wback LMM. same as lmx in EMAX4              curr  1  top  blk  len   1  1  0 */
  /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist!=0                               curr  1  top  blk  len   1  0  0 */
  /*                                                                                                                  c-dist  1 ptop  blk  len   1  0  1 */
  /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   1  0  1 */
  /*                                                                                                              p=1の場合,drain-addrは常にlmmi.top+ofs */
  /* TR    set f=1 and p=1 in lmmc automatically                                                                        curr  1  top  -    -     1  1  1 */
  /*******************************************************************************************************************************************************/
  /**********************************************************************************************************/
  /* Step 1 ... decode[][]登録と伝搬レジスタ                                                                */
  /* 1-1.  各insn[]のsrc毎に依存関係検査対象を抽出し,insn[].header.rdepと比較・rdepを下方へ更新             */
  /*                              ●get_valid_row(hash) ... id[hash].typeにより区別                         */
  /*                                src毎に先行id[].row,col(初期値は-1)と順次比較                           */
  /* 1.2a  絶対位置指定★row,colがない場合(row=-1)                                                          */
  /*                              ●last_rowに,last_rowとrdepの大きい方を採用                               */
  /*                                last_row,last_colを増加しつつ配置                                       */
  /* 1.2b  絶対位置指定★row,colがある場合(row>=0)                                                          */
  /*                              ●指定row < rdepとlast_rowの大きい方ならerror                             */
  /*                                last_rowを指定rowに更新                                                 */
  /* 1-3.  先行写像との競合検査                                                                             */
  /*                              ●exe()とmop()の入力レジスタ競合,伝搬reg不足,reg間nw競合は,検査対象外     */
  /* 1-4.  insn[]->decode[][]コピーおよびALU機能割り当て可否検査                                            */
  /* 1-5.  busmap+伝搬レジスタ設定●emaxと異なり,更新変数は,同一行別カラムでの参照を禁止(逐次実行との互換)  */
  /*                           ---srcに関するbusmap---                                                      */
  /*                              ●WHILE stype=VAR                                                         */
  /*                                   -id.row=-1ならARMが直接前段BRの空きに設定                            */
  /*                                   -id.row>=0ならerror                                                  */
  /*                              ●CEX stype=VAR                                                           */
  /*                                   -id.row=-1ならARMが直接前段BRの空きに設定                            */
  /*                                   -id.row>=0 & row=自段(id.itype=CEX)なら ×                           */
  /*                                   -          & row=自段(id.itype=EXE)なら ×                           */
  /*                                   -          & row=自段(id.itype=MOP)なら ×                           */
  /*                                   -          & row=前段(id.itype=CEX)なら ×                           */
  /*                                   -          & row=前段(id.itype=EXE)なら,AR探索->BR割付               */
  /*                                   -          & row=前段(id.itype=MOP)なら,BR探索                       */
  /*                                   -          & row=前々(id.itype=CEX)なら ×                           */
  /*                                   -          & row=前々(id.itype=EXE)なら,AR探索->BR割付->BR伝搬       */
  /*                                   -          & row=前々(id.itype=MOP)なら,BR探索        ->BR伝搬       */
  /*                              ●EX4 stype=VAR,AR,BR                                                     */
  /*                              ●EXE stype=VAR,AR,BR,EX                                                  */
  /*                                   -id.row=-1ならARMが直接前段BRの空きに設定                            */
  /*                                   -id.row>=0 & row=自段(id.itype=CEX)なら,EX ★                        */
  /*                                   -          & row=自段(id.itype=EXE)なら ×                           */
  /*                                   -          & row=自段(id.itype=MOP)なら ×                           */
  /*                                   -          & row=前段(id.itype=CEX)なら ×                           */
  /*                                   -          & row=前段(id.itype=EXE)なら,AR探索->BR割付               */
  /*                                   -          & row=前段(id.itype=MOP)なら,BR探索                       */
  /*                                   -          & row=前々(id.itype=CEX)なら ×                           */
  /*                                   -          & row=前々(id.itype=EXE)なら,AR探索->BR割付->BR伝搬       */
  /*                                   -          & row=前々(id.itype=MOP)なら,BR探索        ->BR伝搬       */
  /*                              ●MO4 stype=VAR,AR,BR,EX                                                  */
  /*                              ●MOP stype=VAR,AR,BR,EX                                                  */
  /*                                   -id.row=-1ならARMが直接前段BRの空きに設定                            */
  /*                                   -id.row>=0 & row=自段(id.itype=CEX)なら,EX ★                        */
  /*                                   -          & row=自段(id.itype=EXE)なら,AR ★                        */
  /*                                   -          & row=自段(id.itype=MOP)なら ×                           */
  /*                                   -          & row=前段(id.itype=CEX)なら ×                           */
  /*                                   -          & row=前段(id.itype=EXE)なら,AR探索->BR割付               */
  /*                                   -          & row=前段(id.itype=MOP)なら,BR探索                       */
  /*                                   -          & row=前々(id.itype=CEX)なら ×                           */
  /*                                   -          & row=前々(id.itype=EXE)なら,AR探索->BR割付->BR伝搬       */
  /*                                   -          & row=前々(id.itype=MOP)なら,BR探索        ->BR伝搬       */
  /* 1-6.  位置を確定.dst変数の位置情報をid[].row,colに記録                                                 */
  /*                           ---dstに関するbusmap---                                                      */
  /*                              ●WHILEの位置暗黙指定は[0,0]．       busmapはEXDR(AR)止め                 */
  /*                              ●CEX  の位置明示指定は無．          busmapはCEXD止め (UNIT内で消費)      */
  /*                              ●EXE  の位置明示指定はout-AR．      busmapはEXDR(AR)止め                 */
  /*                 MTYPE_*LOAD  ●LD   の位置明示指定はout-BR．      busmapはBR止め                       */
  /*                 MTYPE_*STORE ●ST/TRの位置明示指定は同row内in-AR．busmapはTR止め                       */
  /**********************************************************************************************************/
  for (i=0; i<last_insn; i++) {
    char type  =  insn[i].iheader.type;
    char row   =  insn[i].iheader.row; /* 暫定 */
    char col   =  insn[i].iheader.col; /* 暫定 */
    char *rdep = &insn[i].iheader.rdep;
    if (row >= EMAX_DEPTH || col >= EMAX_WIDTH) {
      printf("in %s: specified [%d][%d] exceed limits (EMAX_ROW=%d EMAX_COL=%d)\n", id[current_prefix].name, row, col, EMAX_DEPTH, EMAX_WIDTH);
      exit(1);
    }
#if 1
    printf("%s:insn%03.3d:type=%d [%3.2d,%3.2d] ->", id[current_prefix].name, i, type, row, col);
#endif
    switch (type) {
    case ITYPE_WHILE: /* WHILE */
      /****************************************/
      /* WHILE is mapped only on decode[0][0] */
      /* and has only loc-free variable       */
      /* 1-1                                  */
      /****************************************/
      switch (insn[i].iexe.op1) {
      case OP_WHILE:
        /* 先行opはないので,iheader.rdepは0のまま更新不要 */
        break;
      default:
        printf("in %s: while() found illegal op=%d\n", id[current_prefix].name, insn[i].iexe.op1);
        exit(1);
      }
      if (row < 0) { /* none of WHILE/ALR/BDR is specified */
        /* 1-2a */
        /* never reached */
      }
      else { /* WHILE/ALR/BDR is specified */
        /* 1-2b */
        if (row > 0 || col > 0) { /* 0,0 is specified in conv-c2c.y */
          printf("in %s: [%d][%d] while() found\n", id[current_prefix].name, row, col);
          exit(1);
        }
        if (last_row < row) { /* 指定rowまで間が空くのはCとしてOK *//* whileは常にここを通過 */
          last_row = row;
          last_col = 0;
        }
        else { /* last_row >= row *//* 戻る方向はCとして意味が変わるので当面error *//* whileが先頭にない場合に該当 */
          printf("in %s: while() found violation of sequence (last_row=%d >= row=%d)\n", id[current_prefix].name, last_row, row);
          exit(1);
        }
      }
      /* 1-3 */
      if (last_row >= EMAX_DEPTH || last_col >= EMAX_WIDTH) { /* copy前に検査 */
        printf("in %s: [%d][%d] while() exceeds EMAX_DEPTH/EMAX_WIDTH\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      if (dec[last_row][last_col].dexu.op1 || dec[last_row][last_col].dexu.op2 || dec[last_row][last_col].dexu.op3) { /* 先行写像との競合検査 */
        printf("in %s: [%d][%d] while() conflicts\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      /* 1-4 */
      dexu = &dec[last_row][last_col].dexu;
      dexu->op1    = insn[i].iexe.op1;
      dexu->op2    = insn[i].iexe.op2;
      dexu->op3    = insn[i].iexe.op3;
      dexu->updt   = insn[i].iexe.updt;
      dexu->init   = insn[i].iexe.init;
      dexu->fold   = 0; /* normal */
      dexu->ex1v   = insn[i].iexe.src1v; /* default */
      dexu->ex1h   = insn[i].iexe.src1h; /* default */
      dexu->ex1s   = insn[i].iexe.src1s; /* default */
      dexu->ex1e   = insn[i].iexe.src1e; /* default */
      dexu->ex2v   = insn[i].iexe.src2v; /* default */
      dexu->ex2h   = insn[i].iexe.src2h; /* default */
      dexu->ex2s   = insn[i].iexe.src2s; /* default */
      dexu->ex2e   = insn[i].iexe.src2e; /* default */
      dexu->ex3v   = T_NONE;
      dexu->ex3h   = -1;
      dexu->ex3s   = -1;
      dexu->ex3e   = 0;
      dexu->e2iv   = T_NONE;
      dexu->e2ih   = -1;
      dexu->e2is   = 0;
      dexu->e3iv   = T_NONE;
      dexu->e3ih   = -1;
      dexu->e3is   = 0;
      dexu->exdv   = insn[i].iexe.exedv; /* default */
      dexu->exdh   = insn[i].iexe.exedh; /* default */
      dexu->exds   = insn[i].iexe.exeds; /* default */
      /* 1-5 *//* EMAX4と異なり逐次実行互換のため,prop_skpは不要 */
      /*     *//* id[].row,colが-1の場合,srcはARMがセット.前段の場合br不要.それ以外はbr伝搬. */
      set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dexu->ex1v, dexu->ex1h, dexu->ex1s);
      set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dexu->ex2v, dexu->ex2h, dexu->ex2s);
      /* 1-6 *//* 格納先busmapはEXDR止まり */
      bus[last_row][last_col].exdrv = dexu->exdv;
      bus[last_row][last_col].exdrh = dexu->exdh;
      bus[last_row][last_col].exdrs = dexu->exds;
      id[insn[i].iexe.exedh].itype = ITYPE_WHILE;
      id[insn[i].iexe.exedh].row   = last_row;
      id[insn[i].iexe.exedh].col   = last_col;
      insn[i].iheader.fixed = 1;
      break;
    case ITYPE_FOR: /* FOR */
      /*****************************************/
      /* FOR is mapped only on decode[0][LOOP#]*/
      /* and has only loc-free variable        */
      /* 1-1                                   */
      /*****************************************/
      switch (insn[i].iexe.op1) {
      case OP_FOR:
        /* 先行opはないので,iheader.rdepは0のまま更新不要 */
        break;
      default:
        printf("in %s: for() found illegal op=%d\n", id[current_prefix].name, insn[i].iexe.op1);
        exit(1);
      }
      if (row < 0) { /* none of WHILE/ALR/BDR is specified */
        /* 1-2a */
        /* never reached */
      }
      else { /* WHILE/ALR/BDR is specified */
        /* 1-2b */
        if (row > 0 || col > 1) { /* 0,<2 is specified in conv-c2c.y */
          printf("in %s: [%d][%d] for() found\n", id[current_prefix].name, row, col);
          exit(1);
        }
        if (last_row <= row) { /* for()はcol指定が1,0の逆順 *//* forは常にここを通過 */
          last_row = row;
          last_col = col;
        }
        else { /* last_row >= row *//* 戻る方向はCとして意味が変わるので当面error *//* whileが先頭にない場合に該当 */
          printf("in %s: for() found violation of sequence (last_row=%d >= row=%d)\n", id[current_prefix].name, last_row, row);
          exit(1);
        }
      }
      /* 1-3 */
      if (last_row >= EMAX_DEPTH || last_col >= EMAX_WIDTH) { /* copy前に検査 */
        printf("in %s: [%d][%d] for() exceeds EMAX_DEPTH/EMAX_WIDTH\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      if (dec[last_row][last_col].dexu.op1 || dec[last_row][last_col].dexu.op2 || dec[last_row][last_col].dexu.op3) { /* 先行写像との競合検査 */
        printf("in %s: [%d][%d] for() conflicts\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      /* 1-4 */
      dexu = &dec[last_row][last_col].dexu;
      dexu->op1    = insn[i].iexe.op1;
      dexu->op2    = insn[i].iexe.op2;
      dexu->op3    = insn[i].iexe.op3;
      dexu->updt   = insn[i].iexe.updt;
      dexu->init   = insn[i].iexe.init;
      dexu->fold   = 0; /* normal */
      dexu->ex1v   = insn[i].iexe.src1v; /* default */
      dexu->ex1h   = insn[i].iexe.src1h; /* default */
      dexu->ex1s   = insn[i].iexe.src1s; /* default */
      dexu->ex1e   = insn[i].iexe.src1e; /* default */
      dexu->ex2v   = insn[i].iexe.src2v; /* default */
      dexu->ex2h   = insn[i].iexe.src2h; /* default */
      dexu->ex2s   = insn[i].iexe.src2s; /* default */
      dexu->ex2e   = insn[i].iexe.src2e; /* default */
      dexu->ex3v   = T_NONE;
      dexu->ex3h   = -1;
      dexu->ex3s   = -1;
      dexu->ex3e   = 0;
      dexu->e2iv   = T_NONE;
      dexu->e2ih   = -1;
      dexu->e2is   = 0;
      dexu->e3iv   = T_NONE;
      dexu->e3ih   = -1;
      dexu->e3is   = 0;
      dexu->exdv   = insn[i].iexe.exedv; /* default */
      dexu->exdh   = insn[i].iexe.exedh; /* default */
      dexu->exds   = insn[i].iexe.exeds; /* default */
      /* 1-5 *//* EMAX4と異なり逐次実行互換のため,prop_skpは不要 */
      /*     *//* id[].row,colが-1の場合,srcはARMがセット.前段の場合br不要.それ以外はbr伝搬. */
      set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dexu->ex1v, dexu->ex1h, dexu->ex1s);
      set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dexu->ex2v, dexu->ex2h, dexu->ex2s);
      /* 1-6 *//* 格納先busmapはEXDR止まり */
      bus[last_row][last_col].exdrv = dexu->exdv;
      bus[last_row][last_col].exdrh = dexu->exdh;
      bus[last_row][last_col].exdrs = dexu->exds;
      id[insn[i].iexe.exedh].itype = ITYPE_FOR;
      id[insn[i].iexe.exedh].row   = last_row;
      id[insn[i].iexe.exedh].col   = last_col;
      insn[i].iheader.fixed = 1;
      break;
    case ITYPE_CEX: /* CEX */
      /*********************************************/
      /* CEX is mapped on the row next to exe_dstc */
      /* and has no absolute location              */
      /* 1-1                                       */
      /*********************************************/
      switch (insn[i].icex.op) {
      case OP_CEXE:
        get_valid_row(ITYPE_CEX, 0, insn[i].icex.bit0v, insn[i].icex.bit0h, rdep);
        get_valid_row(ITYPE_CEX, 0, insn[i].icex.bit1v, insn[i].icex.bit1h, rdep);
        get_valid_row(ITYPE_CEX, 0, insn[i].icex.bit2v, insn[i].icex.bit2h, rdep);
        get_valid_row(ITYPE_CEX, 0, insn[i].icex.bit3v, insn[i].icex.bit3h, rdep);
        break;
      default:
        printf("in %s: cexe found illegal op=%d\n", id[current_prefix].name, insn[i].icex.op);
        exit(1);
      }

      folding = 0; /* reset */

      if (row < 0) { /* none of WHILE/ALR/BDR is specified */
        /* 1-2a *//* 同一rowに複数CEXEが配置されることがある */
        if (last_row < *rdep) { /* 間を空けて配置可能 */
          last_row = *rdep;
          last_col = 0;
        }
        else { /* last_row >= *rdep *//* 最終位置>=依存関係制約位置 */
          if (dec[last_row][last_col].dcex.op) /* 同一row後続CEXEが該当.先行写像との競合検査 */
            last_col++; /* overflowはあとで検査.CEXEがWIDTH以上あればerror */
          if (dec[last_row][last_col].dmop0.op) /* 同一row先行STOREが該当.先行写像との競合検査 */
            last_col++; /* overflowはあとで検査.CEXEがWIDTH以上あればerror */
        }
	if (dec[last_row][last_col].dexu.fold) { /* exeがfoldなら同一unit.storeも無条件でfold */
	  printf("load-exe-store folding assumed ");
	  folding = 1; /* load-exe-store folding */
	}
      }
      else { /* WHILE/ALR/BDR is specified */
        /* 1-2b */
        /* never reached */
      }
      /* 1-3 */
      if (last_row >= EMAX_DEPTH || last_col >= EMAX_WIDTH) { /* copy前に検査 */
        printf("in %s: [%d][%d] cexe exceeds EMAX_DEPTH/EMAX_WIDTH\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      if (dec[last_row][last_col].dcex.op) { /* 先行写像との競合検査 */
        printf("in %s: [%d][%d] cexe conflicts\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      /* 1-4 */
      dcex = &dec[last_row][last_col].dcex;
      *dcex = insn[i].icex;
      /* 1-5 *//* EMAX4と異なり逐次実行互換のため,prop_skpは不要 */
      /*     *//* id[].row,colが-1の場合,srcはARMがセット.前段の場合br不要.それ以外はbr伝搬. */
      set_reg_path(last_row, last_col, folding, type, RTYPE_DATA, 0, dcex->bit0v, dcex->bit0h, -1);
      set_reg_path(last_row, last_col, folding, type, RTYPE_DATA, 0, dcex->bit1v, dcex->bit1h, -1);
      set_reg_path(last_row, last_col, folding, type, RTYPE_DATA, 0, dcex->bit2v, dcex->bit2h, -1);
      set_reg_path(last_row, last_col, folding, type, RTYPE_DATA, 0, dcex->bit3v, dcex->bit3h, -1);
      /* 1-6 *//* 格納先busmapはCEXD止まり */
      bus[last_row][last_col].cexdv = dcex->cexdv;
      bus[last_row][last_col].cexdh = dcex->cexdh;
      id[insn[i].icex.cexdh].itype = ITYPE_CEX;
      id[insn[i].icex.cexdh].row   = last_row;
      id[insn[i].icex.cexdh].col   = last_col;
      insn[i].iheader.fixed = 1;
      break;
    case ITYPE_EX4: /* EX4 */
      /**********************************************/
      /* EX4 has variable([]) or bdr[][]([]) as src */
      /* 1-1                                        */
      /**********************************************/
      switch (insn[i].iexe.op1) {
      case OP_FAD: /* 2 */
      case OP_FML: /* 2 */
      case OP_ADD: /* 2 */
      case OP_SUB: /* 2 */
        get_valid_row(ITYPE_EX4, 0, insn[i].iexe.src1v, insn[i].iexe.src1h, rdep);
        get_valid_row(ITYPE_EX4, 0, insn[i].iexe.src2v, insn[i].iexe.src2h, rdep);
        insn[i].iexe.src3v = T_NONE; /* delete */
        break;
      case OP_SFMA: /* 3 */
      case OP_FMA:  /* 3 */
      case OP_FMS:  /* 3 */
      case OP_ADD3: /* 3 */
      case OP_SUB3: /* 3 */
        get_valid_row(ITYPE_EX4, 0, insn[i].iexe.src1v, insn[i].iexe.src1h, rdep);
        get_valid_row(ITYPE_EX4, 0, insn[i].iexe.src2v, insn[i].iexe.src2h, rdep);
        get_valid_row(ITYPE_EX4, 0, insn[i].iexe.src3v, insn[i].iexe.src3h, rdep);
        break;
      default:
        printf("in %s: ex4 found illegal op1=%d\n", id[current_prefix].name, insn[i].iexe.op1);
        exit(1);
      }
      switch (insn[i].iexe.op2) {
      case OP_NOP:
        insn[i].iexe.src4v = T_IMMEDIATE; /* OP_SFMA */
        break;
      default:
        printf("in %s: exe found illegal op2=%d\n", id[current_prefix].name, insn[i].iexe.op2);
	exit(1);
      }
      switch (insn[i].iexe.op3) {
      case OP_NOP:
        insn[i].iexe.src5v = T_IMMEDIATE; /* OP_SFMA */
        break;
      default:
	printf("in %s: exe found illegal op3=%d\n", id[current_prefix].name, insn[i].iexe.op3);
	exit(1);
      }

      folding = 0; /* reset */

      if (row < 0) { /* none of WHILE/ALR/BDR is specified */
        /* 1-2a */
        if (last_row < *rdep) { /* 間を空けて配置可能 */
	  if (last_row == *rdep-1 && insn[i].iexe.src1h == insn[i].iexe.exedh) { /* load-sfma-store foldingの場合,例えばrow=7,src=6,7 fold=1にセットしてトライ */
	    for (j=0; j<EMAX_WIDTH; j++) {
	      if (insn[i].iexe.src1h == dec[last_row][j].dmop1.mopdh) {
		last_col = j;
		break;
	      }
	    }
	    if (j<EMAX_WIDTH) {
	      printf("load-sfma-store folding w/ ALU loop assumed ");
	      folding = 1;
	    }
	    else {
	      last_row = *rdep;
	      last_col = 0;
	    }
	  }
          else {
	    last_row = *rdep;
	    last_col = 0; /* 位置指定可能ex4.dstはALRのみ.var経由の同一row内後続st4()を配置可能 */
	  }
        }
        else { /* last_row >= *rdep *//* 最終位置>=依存関係制約位置 */
          if (dec[last_row][0].dexu.op1 || dec[last_row][0].dexu.op2 || dec[last_row][0].dexu.op3) { /* 先行写像との競合検査 */
            last_row++; /* overflowはあとで検査.CEXEがWIDTH以上あればerror */
            last_col = 0; /* 位置指定可能ex4.dstはALRのみ.var経由の同一row内後続st4()を配置可能 */
          }
        }
      }
      else { /* WHILE/ALR/BDR is specified */
        /* 1-2b */
        if (row < *rdep) { /* 指定rowには配置困難 */
          printf("in %s: ex4 cannot locate destination ALRNO (row=%d)\n", id[current_prefix].name, row);
          exit(1);
        }
        else if (row < last_row) {
          printf("in %s: ex4 found violation of sequence (row=%d < last_row=%d)\n", id[current_prefix].name, row, last_row);
          exit(1);
        }
        else {
          last_row = row;
          last_col = 0; /* 位置指定可能ex4.dstはALRのみ.ALR経由の同一row内後続st4()を配置可能 */
        }
      }
      /* 1-3 */
      if (last_row >= EMAX_DEPTH || last_col >= EMAX_WIDTH) { /* copy前に検査 */
        printf("in %s: [%d][%d] ex4 exceeds EMAX_DEPTH/EMAX_WIDTH\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      /* ex4[row] is expanded into all columns in decode[row][] */
      for (j=0; j<EMAX_WIDTH; j++) {
        if (dec[last_row][j].dexu.op1 || dec[last_row][j].dexu.op2 || dec[last_row][j].dexu.op3) { /* 先行写像との競合検査 */
          printf("in %s: [%d][%d] ex4 conflicts\n", id[current_prefix].name, last_row, j);
          exit(1);
        }
      }
      /* 1-4 */
      for (j=0; j<EMAX_WIDTH; j++) {
        dexu = &dec[last_row][j].dexu;
        dexu->op1    = insn[i].iexe.op1;
        dexu->op2    = insn[i].iexe.op2;
        dexu->op3    = insn[i].iexe.op3;
        dexu->updt   = insn[i].iexe.updt;
	dexu->init   = insn[i].iexe.init;
	dexu->fold   = folding;
        dexu->ex1v   = insn[i].iexe.src1v; /* default */
        dexu->ex1h   = insn[i].iexe.src1h; /* default */
        dexu->ex1s   = insn[i].iexe.op1==OP_SFMA?-1:j;
        dexu->ex1e   = insn[i].iexe.src1e; /* default */
        dexu->ex2v   = insn[i].iexe.src2v; /* default */
        dexu->ex2h   = insn[i].iexe.src2h; /* default */
        dexu->ex2s   = j;
        dexu->ex2e   = insn[i].iexe.src2e; /* default */
        dexu->ex3v   = insn[i].iexe.src3v; /* default */
        dexu->ex3h   = insn[i].iexe.src3h; /* default */
        dexu->ex3s   = j;
        dexu->ex3e   = insn[i].iexe.src3e; /* default */
        dexu->e2iv   = insn[i].iexe.src4v; /* default */
        dexu->e2ih   = insn[i].iexe.src4h; /* default */
        dexu->e2is   = 0;                  /* e2imm */
        dexu->e3iv   = insn[i].iexe.src5v; /* default */
        dexu->e3ih   = insn[i].iexe.src5h; /* default */
        dexu->e3is   = 0;                  /* e3imm */
        dexu->exdv   = insn[i].iexe.exedv; /* default */
        dexu->exdh   = insn[i].iexe.exedh; /* default */
        dexu->exds   = insn[i].iexe.op1==OP_SFMA?-1:j;
      }
      /* 1-5 *//* EMAX4と異なり逐次実行互換のため,prop_skpは不要 */
      /*     *//* id[].row,colが-1の場合,srcはARMがセット.前段の場合br不要.それ以外はbr伝搬. */
      for (j=0; j<EMAX_WIDTH; j++) {
        dexu = &dec[last_row][j].dexu;
        set_reg_path(last_row, last_col, folding, type, RTYPE_DATA, 0, dexu->ex1v, dexu->ex1h, dexu->ex1s); /* ex1s=3,2,1,0 */
        set_reg_path(last_row, last_col, folding, type, RTYPE_DATA, 0, dexu->ex2v, dexu->ex2h, dexu->ex2s); /* ex2s=3,2,1,0 */
        set_reg_path(last_row, last_col, folding, type, RTYPE_DATA, 0, dexu->ex3v, dexu->ex3h, dexu->ex3s); /* ex3s=3,2,1,0 */
      }
      /* 1-6 *//* 格納先busmapはEXDR止まり */
      for (j=0; j<EMAX_WIDTH; j++) {
        dexu = &dec[last_row][j].dexu;
        bus[last_row][j].exdrv = dexu->exdv;
        bus[last_row][j].exdrh = dexu->exdh;
        bus[last_row][j].exdrs = dexu->exds; /* exds=3,2,1,0 */
      }
      id[insn[i].iexe.exedh].itype = ITYPE_EX4;
      id[insn[i].iexe.exedh].row   = last_row;
      id[insn[i].iexe.exedh].col   = -1; /* ★★★ exe->AR[]の場合,全columnで共通なので，問題なし */
      insn[i].iheader.fixed = 1;
      break;
    case ITYPE_EXE: /* EXE */
      /*****************************************/
      /* 1-1                                   */
      /* EXE has imm, var, var[], bdr[][][]    */
      /* ★load-exe-store foldingの場合        */
      /*          □BR                         */
      /*          │                --row#6--  */
      /*          exe                          */
      /*          □AR6                        *//*    mm+rmm.cの例                                    */
      /*          │                           *//* (1)mop(OP_LDWR,  &BR[7][0][1])                     */
      /*          □BR6                        *//* (2)exe(OP_FAD,   &AR[7][0], AR[6][0], BR[7][0][1]) */
      /*  (1)     │      (2)   (3) --row#7--  *//*    ★dst:rowのAR,src:rowのBRの場合,                */
      /*  eag ┌─│─┬┐exe   eag            *//*      srcへのパスは一旦rowのBRまで繋ぎ,             */
      /*  □LD│  □TR│  □AR7 □ST           *//*      そこから戻してs1,s2,s3に繋ぐ.                 */
      /*  │  │  │  │　│    │             *//*      s1,s2,s3が定数の場合も次rowにセットして戻す   */
      /*  □  │  │  │　└──□LMM(ST)      */
      /*  │  │  │  │                       *//* (3)mop(OP_STWR,  &AR[7][0])                        */
      /*  □BR┘  □BR┘                       *//*    ★このパターンは従来通り                        */
      /*****************************************/
      switch (insn[i].iexe.op1) {
      case OP_NOP:
        get_valid_row(ITYPE_EXE, 0, insn[i].iexe.src1v, insn[i].iexe.src1h, rdep);
        insn[i].iexe.src2v = T_NONE; /* delete */
        insn[i].iexe.src3v = T_NONE; /* delete */
        break;
      case OP_FAD:    /* 2 */
      case OP_FML:    /* 2 */
      case OP_ADD:    /* 2 */
      case OP_SUB:    /* 2 */
      case OP_CMP_EQ: /* 2 */
      case OP_CMP_NE: /* 2 */
      case OP_CMP_LT: /* 2 */
      case OP_CMP_LE: /* 2 */
      case OP_CMP_GT: /* 2 */
      case OP_CMP_GE: /* 2 */
//    case OP_CCAT:   /* 2 */
      case OP_MAUH:   /* 2 */
      case OP_MSUH:   /* 2 */
      case OP_MLUH:   /* 2 */
      case OP_MSAD:   /* 2 */
      case OP_MINL:   /* 2 */
      case OP_MH2BW:  /* 2 */
      case OP_MCAS:   /* 2 */
      case OP_MMAX:   /* 2 */
      case OP_MMIN:   /* 2 */
        get_valid_row(ITYPE_EXE, 0, insn[i].iexe.src1v, insn[i].iexe.src1h, rdep);
        get_valid_row(ITYPE_EXE, 0, insn[i].iexe.src2v, insn[i].iexe.src2h, rdep);
        insn[i].iexe.src3v = T_NONE; /* delete */
        break;
      case OP_CFMA:   /* 3 */
      case OP_FMA:    /* 3 */
      case OP_FMS:    /* 3 */
      case OP_ADD3:   /* 3 */
      case OP_SUB3:   /* 3 */
      case OP_CMOV:   /* 3 */
      case OP_MAUH3:  /* 3 */
      case OP_MSUH3:  /* 3 */
      case OP_MMRG:   /* 3 */
      case OP_MSSAD:  /* 3 */
      case OP_MINL3:  /* 3 */
      case OP_MMID3:  /* 3 */
      case OP_MMAX3:  /* 3 */
      case OP_MMIN3:  /* 3 */
      case OP_MAJ:    /* 3 */
      case OP_CH:     /* 3 */
        get_valid_row(ITYPE_EXE, 0, insn[i].iexe.src1v, insn[i].iexe.src1h, rdep);
        get_valid_row(ITYPE_EXE, 0, insn[i].iexe.src2v, insn[i].iexe.src2h, rdep);
        get_valid_row(ITYPE_EXE, 0, insn[i].iexe.src3v, insn[i].iexe.src3h, rdep);
        break;
      default:
        printf("in %s: exe found illegal op1=%d\n", id[current_prefix].name, insn[i].iexe.op1);
        exit(1);
      }
      switch (insn[i].iexe.op2) {
      case OP_NOP:
        insn[i].iexe.src4v = T_NONE; /* delete */
        break;
      case OP_AND:
      case OP_OR:
      case OP_XOR:
      case OP_SUMHH:
      case OP_SUMHL:
//    case OP_WSWAP:
      case OP_ROTS:
        get_valid_row(ITYPE_EXE, 0, insn[i].iexe.src4v, insn[i].iexe.src4h, rdep);
        break;
      default:
        printf("in %s: exe found illegal op2=%d\n", id[current_prefix].name, insn[i].iexe.op2);
        exit(1);
      }
      switch (insn[i].iexe.op3) {
      case OP_NOP:
        insn[i].iexe.src5v = T_NONE; /* delete */
        break;
      case OP_SLL:
      case OP_SRL:
      case OP_SRAA:
      case OP_SRAB:
//    case OP_SRAC:
//    case OP_SRAD:
      case OP_SRLM:
        get_valid_row(ITYPE_EXE, 0, insn[i].iexe.src5v, insn[i].iexe.src5h, rdep);
        break;
      default:
        printf("in %s: exe found illegal op3=%d\n", id[current_prefix].name, insn[i].iexe.op3);
        exit(1);
      }

      folding = 0; /* reset */

      if (row < 0) { /* none of WHILE/ALR/BDR is specified */
        /* 1-2a *//* 同一rowに複数EXEが配置されることがある */
        if (last_row < *rdep) { /* 間を空けて配置可能 */
	  if (last_row == *rdep-1 && insn[i].iexe.src1h == insn[i].iexe.exedh) { /* load-exe-store foldingの場合,例えばrow=7,src=6,7 fold=1にセットしてトライ */
	    for (j=0; j<EMAX_WIDTH; j++) {
	      if (insn[i].iexe.src1h == dec[last_row][j].dmop1.mopdh) {
		last_col = j;
		break;
	      }
	    }
	    if (j<EMAX_WIDTH) {
	      printf("load-exe-store folding w/ ALU loop assumed ");
	      folding = 1;
	    }
	    else {
	      last_row = *rdep;
	      last_col = 0;
	    }
	  }
          else {
	    last_row = *rdep;
	    last_col = 0;
	  }
        }
        else { /* last_row >= *rdep *//* 最終位置と依存関係制約位置が一致 */
          if (dec[last_row][last_col].dexu.op1 || dec[last_row][last_col].dexu.op2 || dec[last_row][last_col].dexu.op3) { /* 先行写像との競合検査 */
            last_col++; /* overflowはあとで検査.EXEがWIDTH以上あれば次段へ移動 */
            if (last_col >= EMAX_WIDTH) {
              last_row++;
              last_col = 0;
            }
          }
        }
      }
      else { /* WHILE/ALR/BDR is specified */
        /* 1-2b */
        if (row < *rdep) {
	  if (row == *rdep-1 && insn[i].iexe.src1h != insn[i].iexe.exedh) { /* load-exe-store foldingの場合,例えばrow=7,src=6,7 fold=1にセットしてトライ */
	    last_row = row;
	    last_col = col;
	    printf("load-exe-store folding w/o ALU loop assumed ");
	    folding = 1;
	  }
	  else { /* 指定rowには配置困難 */
	    printf("in %s: exe cannot locate destination ALRNO/BDRNO (row=%d)\n", id[current_prefix].name, row);
	    exit(1);
	  }
        }
        else if (row < last_row) { /* 位置を上に戻せない ⇒ sort-msege:戻せるように変更 20221026 */
          //printf("in %s: exe found violation of sequence (row=%d < last_row=%d)\n", id[current_prefix].name, row, last_row);
          //exit(1);
	  last_row = row;
	  last_col = col;
        }
        else {
          last_row = row;
          last_col = col;
        }
      }
      /* 1-3 */
      if (last_row >= EMAX_DEPTH || last_col >= EMAX_WIDTH) { /* copy前に検査 */
        printf("in %s: [%d][%d] exe exceeds EMAX_DEPTH/EMAX_WIDTH\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      if (dec[last_row][last_col].dexu.op1 || dec[last_row][last_col].dexu.op2 || dec[last_row][last_col].dexu.op3) {
        printf("in %s: [%d][%d] exe conflicts\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      /* 1-4 */
      /* check combination of sources */
      /*    src1 src2 src3        src4        src5       */
      /* A: ex1, ex2, ex3 -> EX1, e2i -> EX2, e3i -> EX3 */
      /* B: ex1, ex2      -> EX1, ex3 -> EX2, e3i -> EX3 */
      /* C: ex1, ex2      -> EX1, e2i -> EX2, ex3 -> EX3 */
      /* D: ex1           -> EX1, ex2 -> EX2, e3i -> EX3 */
      /* E: ex1           -> nop, ex2 -> EX2, ex3 -> EX3 */
      /* F: ex1           -> nop, e2i -> EX2, e3i -> EX3 */
      /* G: ex1           -> nop, e2i -> EX2, ex3 -> EX3 */
      dexu = &dec[last_row][last_col].dexu;
      dexu->op1    = insn[i].iexe.op1;
      dexu->op2    = insn[i].iexe.op2;
      dexu->op3    = insn[i].iexe.op3;
      dexu->updt   = insn[i].iexe.updt;
      dexu->init   = insn[i].iexe.init;
      dexu->fold   = folding;
      dexu->ex1v   = insn[i].iexe.src1v; /* default */
      dexu->ex1h   = insn[i].iexe.src1h; /* default */
      dexu->ex1s   = insn[i].iexe.src1s; /* default */
      dexu->ex1e   = insn[i].iexe.src1e; /* default */
      if (insn[i].iexe.src2v) { /* case A,B,C */
        dexu->ex2v   = insn[i].iexe.src2v; /* default */
        dexu->ex2h   = insn[i].iexe.src2h; /* default */
        dexu->ex2s   = insn[i].iexe.src2s; /* default */
        dexu->ex2e   = insn[i].iexe.src2e; /* default */
      }
      if (insn[i].iexe.src3v) { /* case A */
        dexu->ex3v   = insn[i].iexe.src3v; /* default */
        dexu->ex3h   = insn[i].iexe.src3h; /* default */
        dexu->ex3s   = insn[i].iexe.src3s; /* default */
        dexu->ex3e   = insn[i].iexe.src3e; /* default */
      }
      if (insn[i].iexe.src4v==T_IMMEDIATE) { /* case A,C,F,G */
        dexu->e2iv   = insn[i].iexe.src4v; /* default */
        dexu->e2ih   = insn[i].iexe.src4h; /* default */
        dexu->e2is   = 0;                  /* e2imm */
      }
      else if (insn[i].iexe.src4v) { /* case B,D,E */
        if (dexu->ex3v) {
          printf("in %s: insn[%d].iexe has too many T_VARs\n", id[current_prefix].name, i);
          exit(1);
        }
        else if (dexu->ex2v) { /* case B */
          dexu->ex3v   = insn[i].iexe.src4v; /* default */
          dexu->ex3h   = insn[i].iexe.src4h; /* default */
          dexu->ex3s   = insn[i].iexe.src4s; /* default */
          dexu->ex3e   = 0;
          dexu->e2is   = 2;                  /* ex3 */
        }
        else { /* case D,E */
          dexu->ex2v   = insn[i].iexe.src4v; /* default */
          dexu->ex2h   = insn[i].iexe.src4h; /* default */
          dexu->ex2s   = insn[i].iexe.src4s; /* default */
          dexu->ex2e   = 0;
          dexu->e2is   = 1;                  /* ex2 */
        }
      }
      if (insn[i].iexe.src5v==T_IMMEDIATE) { /* case A,B,D,F */
        dexu->e3iv   = insn[i].iexe.src5v; /* default */
        dexu->e3ih   = insn[i].iexe.src5h; /* default */
        dexu->e3is   = 0;                  /* e3imm */
      }
      else if (insn[i].iexe.src5v) { /* case C,E,G */
        if (dexu->ex3v) {
          printf("in %s: insn[%d].iexe has too many T_VARs\n", id[current_prefix].name, i);
          exit(1);
        }
        else { /* case C,E,G */
          dexu->ex3v   = insn[i].iexe.src5v; /* default */
          dexu->ex3h   = insn[i].iexe.src5h; /* default */
          dexu->ex3s   = insn[i].iexe.src5s; /* default */
          dexu->ex3e   = 0;
          dexu->e3is   = 1;                  /* ex3 */
        }
      }
      dexu->exdv   = insn[i].iexe.exedv; /* default */
      dexu->exdh   = insn[i].iexe.exedh; /* default */
      dexu->exds   = insn[i].iexe.exeds; /* default */
      /* 1-5 */
      set_reg_path(last_row, last_col, folding, type, RTYPE_DATA, 0, dexu->ex1v, dexu->ex1h, dexu->ex1s); /* discrete */
      set_reg_path(last_row, last_col, folding, type, RTYPE_DATA, 0, dexu->ex2v, dexu->ex2h, dexu->ex2s); /* discrete */
      set_reg_path(last_row, last_col, folding, type, RTYPE_DATA, 0, dexu->ex3v, dexu->ex3h, dexu->ex3s); /* discrete */
      /* 1-6 *//* 格納先busmapはEXDR止まり */
      bus[last_row][last_col].exdrv = dexu->exdv;
      bus[last_row][last_col].exdrh = dexu->exdh;
      bus[last_row][last_col].exdrs = dexu->exds; /* &VARの場合-1, &VAR[c]の場合c, &AR[r][c]の場合c */
      id[insn[i].iexe.exedh].itype = ITYPE_EXE;
      id[insn[i].iexe.exedh].row   = last_row;
      id[insn[i].iexe.exedh].col   = dexu->exds<0 /* ★★★ exe->&VARの場合,last_colをセット */
                                   ? last_col     /* ★★★ exe->VAR[c],AR[r][c]をバラで使う場合,colでは区別不可 */
                                   : -1;          /* ★★★ col位置は固定なので-1にしておく */
      insn[i].iheader.fixed = 1;
      break;
    case ITYPE_MEX: /* MEX */
      /*****************************************/
      /* old mex(OP_CMPA_LE, &b0[h],       INIT0?b:b0[h],                INIT0?0:8, BR[r][2][1], BR[r][2][0]);*/
      /* old mex(OP_CMPA_GE, &a0[h][CHIP], INIT0?a[h][CHIP]:a0[h][CHIP], INIT0?0:8, BR[r][2][1], BR[r][2][0]);*/
      /* new mex(OP_CMPA_LE, &b0[h][0], INIT0?b[0]:b0[h][0], INIT0?0LL:8LL, OP_CMPA_GE, &a0[h][0][CHIP], INIT0?a[h][CHIP]:a0[h][0][CHIP], INIT0?0LL:8LL, 0LL, BR[r][2][1], BR[r][2][0]);*/
      /* new mex(OP_CMPA_LE, &J[x],     INIT0?0LL:J[x],      INIT0?0LL:8LL, OP_CMPA_GE, &K[x],           INIT0?0LL:K[x],                  INIT0?0LL:8LL, BE8, BR[r][2][1], BR[r][2][0]);*/
      /*     mop(OP_LDR, 3,  &BR[r][2][1], b0[h],       bofs, MSK_W1, b,          2*LP*RMGRP,  0, 0, NULL, 2*LP*RMGRP); */
      /*     mop(OP_LDR, 3,  &BR[r][2][0], a0[h][CHIP], cofs, MSK_W1, a[h][CHIP], 2*LP,        0, 0, NULL, 2*LP); */
      switch (insn[i].imex.op0) {
      case OP_ALWAYS:
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.adr1v, insn[i].imex.adr1h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.adr2v, insn[i].imex.adr2h, rdep);
        break;
      case OP_CMPA_LE:
      case OP_CMPA_GE:
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.adr1v, insn[i].imex.adr1h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.adr2v, insn[i].imex.adr2h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.src1v, insn[i].imex.src1h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.src2v, insn[i].imex.src2h, rdep);
        break;
      }
      switch (insn[i].imex.op1) {
      case OP_ALWAYS:
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.adr3v, insn[i].imex.adr3h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.adr4v, insn[i].imex.adr4h, rdep);
        break;
      case OP_CMPA_LE:
      case OP_CMPA_GE:
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.adr3v, insn[i].imex.adr3h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.adr4v, insn[i].imex.adr4h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.src1v, insn[i].imex.src1h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.src2v, insn[i].imex.src2h, rdep);
        break;
      }

      folding = 1; /* set */

      if (row < 0) { /* OP_ALWAYSの場合,BR[][]指定無し */
        /* 1-2a */
	if (last_row < *rdep) { /* 間を空けて配置可能 */
	  last_row = *rdep;
	  last_col = 0;
	}
	else { /* last_row >= *rdep *//* 最終位置と依存関係制約位置が一致 */
	  last_col++; /* overflowはあとで検査.EXEがWIDTH以上あれば次段へ移動 */
	  if (last_col >= EMAX_WIDTH) {
	    last_row++;
	    last_col = 0;
	  }
	}
      }
      else { /* WHILE/ALR/BDR is specified */
        /* 1-2b */
        if (row < *rdep) {
	  printf("in %s: mex cannot locate destination BDRNO (row=%d)\n", id[current_prefix].name, row);
	  exit(1);
	}
	else if (row < last_row) {
          printf("in %s: mex found violation of sequence (row=%d < last_row=%d)\n", id[current_prefix].name, row, last_row);
          exit(1);
        }
        else {
          last_row = row;
          last_col = col;
        }
      }
      /* 1-3 */
      //printf("ITYPE_MEX: row=%d col=%d rdep=%d last_row=%d last_col=%d\n", row, col, *rdep, last_row, last_col);
      if (last_row >= EMAX_DEPTH || last_col >= EMAX_WIDTH) { /* copy前に検査 */
        printf("in %s: [%d][%d] mex exceeds EMAX_DEPTH/EMAX_WIDTH\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      /* 1-4 */
      dmex  = &dec[last_row][last_col].dmex;
      *dmex = insn[i].imex; /* new mex()は1つで2つ分指定 */
      /* 1-5 */
      /* BR[][][1],BR[][][0]からの戻りは常時接続なのでselector追加不要 */
      /* ea14woofs,ea04woofsからの戻りは常時接続なのでselector追加不要 */
      set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 0, dmex->adr1v, dmex->adr1h, dmex->adr1s);
      set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmex->adr3v, dmex->adr3h, dmex->adr3s);
      /* 1-6 */
      /* BR[][][1],BR[][][0]からの戻りは常時接続なのでbus設定不要 */
      /* ea14woofs,ea04woofsからの戻りは常時接続なのでbus設定不要 */
      bus[last_row][last_col].ea0woofsv = dmex->mexd0v;
      bus[last_row][last_col].ea0woofsh = dmex->mexd0h;
      bus[last_row][last_col].ea1woofsv = dmex->mexd1v;
      bus[last_row][last_col].ea1woofsh = dmex->mexd1h;
      id[insn[i].imex.mexd0h].itype = ITYPE_MEX;
      id[insn[i].imex.mexd0h].row   = last_row;
      id[insn[i].imex.mexd0h].col   = last_col;
      id[insn[i].imex.mexd1h].itype = ITYPE_MEX;
      id[insn[i].imex.mexd1h].row   = last_row;
      id[insn[i].imex.mexd1h].col   = last_col;
      insn[i].iheader.fixed = 1;
      break;
    case ITYPE_MO4: /* MO4 */
      /**************************************************/
      /* 1-1                                            */
      /* MO4 has var([]), alr[]([]), bdr[][]([]) as src */
      /*         store    store      load               */
      /**************************************************/
      switch (insn[i].imop.op) {
      case OP_STRQ:  /* random_store on mop0->TR (+implicit mop1->AXI) */
        current_lmmwb = 1; /* mark as dirty L1 shold be flushed+cleared before starting EMAX */
      case OP_TR:    /* transaction on mop0->TR (+implicit mop1->AXI) */
        get_valid_row(ITYPE_MO4, 1, insn[i].imop.mopdv, insn[i].imop.mopdh, rdep);
      case OP_LDRQ:  /* random_load on mop1->BR (+implicit AXI->mop0->TR) */
      case OP_LDDMQ: /* direct_load on mop0->AXI->TR->BR */
        get_valid_row(ITYPE_MO4, 1, insn[i].imop.exv,   insn[i].imop.exh,   rdep);
        get_valid_row(ITYPE_MO4, 0, insn[i].imop.basev, insn[i].imop.baseh, rdep);
        get_valid_row(ITYPE_MO4, 0, insn[i].imop.offsv, insn[i].imop.offsh, rdep);
        break;
      default:
        printf("in %s: insn[%d].imop.op=%d is undefined\n", id[current_prefix].name, i, insn[i].imop.op);
        exit(1);
      }

      folding = 0; /* reset */

      if (row < 0) { /* none of WHILE/ALR/BDR is specified */
        /* 1-2a */
        if (last_row < *rdep) { /* 間を空けて配置可能 */
          last_row = *rdep;
          last_col = 0; /* 位置指定可能ex4.dstはALRのみ.var経由の同一row内後続st4()を配置可能 */
        }
        else { /* last_row >= *rdep *//* 最終位置と依存関係制約位置が一致 */
          if (dec[last_row][last_col].dmop0.op || dec[last_row][last_col].dmop1.op) { /* 先行写像との競合検査 */
            last_col++; /* overflowはあとで検査.MOP4がWIDTH以上あれば次段へ移動 */
            if (last_col >= EMAX_WIDTH) {
              last_row++;
              last_col = 0;
            }
          }
        }
      }
      else { /* WHILE/ALR/BDR is specified */
        /* 1-2b */
        if (row < *rdep) { /* 指定rowには配置困難 */
          printf("in %s: mo4 cannot locate destination ALRNO/BDRNO (row=%d)\n", id[current_prefix].name, row);
          exit(1);
        }
        else if (row < last_row) {
          printf("in %s: mo4 found violation of sequence (row=%d < last_row=%d)\n", id[current_prefix].name, row, last_row);
          exit(1);
        }
        else {
          last_row = row;
          if (col >= 0) /* AR指定の場合,col=-1なので,colは無変更 */
            last_col = col;
        }
      }
      /* 1-3 */
      if (last_row >= EMAX_DEPTH || last_col >= EMAX_WIDTH) { /* copy前に検査 */
        printf("in %s: [%d][%d] mo4 exceeds EMAX_DEPTH/EMAX_WIDTH\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      if (dec[last_row][last_col].dmop0.op || dec[last_row][last_col].dmop1.op) {
        printf("in %s: [%d][%d] mo4 conflicts\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      /* 1-4 */
      dmop0 = &dec[last_row][last_col].dmop0;
      dmop1 = &dec[last_row][last_col].dmop1;
      if (insn[i].imop.mtype == MTYPE_RLOAD) /* mop1 */
        *dmop1 = insn[i].imop;
      else /* MTYPE_RSTORE, MTYPE_DLOAD, MTYPE_TRANS */
        *dmop0 = insn[i].imop;
      if (insn[i].imop.mtype == MTYPE_DLOAD) { /* MTYPE_DLOADの主記憶ADDR送信設定 */
        /*-------------★★★★★★★★-----------------*/
        /* dec[last_row][last_col].dmop0.op = OP_LDDMQ; /* may be redundant */
        /* setup EX1 for ddr-addr */
        dexu = &dec[last_row][last_col].dexu;
        if (dexu->op1 || dexu->op2 || dexu->op3) {
          printf("in %s: [%d][%d] LDDMQ address generation conflicts in EXU\n", id[current_prefix].name, last_row, last_col);
          exit(1);
        }
        dexu->op1    = OP_ADD;
        dexu->op2    = OP_NOP;
        dexu->op3    = OP_NOP;
        dexu->updt   = 0; /* 0:none, 1:self_update */
	dexu->init   = 0;
	dexu->fold   = 0; /* normal */
        dexu->ex1v   = dmop0->basev; /* id.type */
        dexu->ex1h   = dmop0->baseh; /* hash val */
        dexu->ex1s   = dmop0->bases; /* suffix for var[s], bdr[][][s] */
        dexu->ex1e   = EXP_H3210;    /* 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
        dexu->ex2v   = dmop0->offsv; /* id.type */
        dexu->ex2h   = dmop0->offsh; /* hash val */
        dexu->ex2s   = dmop0->offss; /* suffix for var[s], bdr[][][s] */
        dexu->ex2e   = EXP_H3210;    /* 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
        dexu->ex3v   = T_NONE;       /* id.type */
        dexu->ex3h   = -1;           /* hash val */
        dexu->ex3s   = -1;           /* suffix for var[s], bdr[][][s] */
        dexu->ex3e   =  0;           /* 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
        dexu->e2iv   = T_NONE;       /* id.type */
        dexu->e2ih   = -1;           /* hash val */
        dexu->e2is   =  0;           /* selector 0:e2imm, 1:ex2, 2:ex3 */
        dexu->e3iv   = T_NONE;       /* id.type */
        dexu->e3ih   = -1;           /* hash val */
        dexu->e3is   =  0;           /* selector 0:e3imm, 1:ex3 */
        dexu->exdv   = dmop0->basev; /* id.type */
        dexu->exdh   = dmop0->baseh; /* hash val */
        dexu->exds   = dmop0->bases; /* suffix for var[s], bdr[][][s] */
        dmop1->updt  = 1;            /* for internal update of ea1 */
        dmop1->offsm = 14;           /* for internal update of ea1 */
      }
      else if (insn[i].imop.mtype == MTYPE_TRANS) { /* MTYPE_TRANSのPARAM*4送信設定 */
        /*-------------★★★★★★★★-----------------*/
        dmop1->updt  = 1;            /* for internal update of ea1 */
        dmop1->offsm = 14;           /* for internal update of ea1 */
      }
      /* 1-5 */
      if (insn[i].imop.mtype == MTYPE_RLOAD) { /* mop1 */
        /* LD with force-read=0 and ptop==NULL generates current(lmr) and reuse LMM. same as lmr in EMAX4                     curr  1  top  blk  len   0  0  0 */
        /* LD with force-read=1 and ptop==NULL generates current(lmf) and !reuse LMM. same as lmf in EMAX4                    curr  1  top  blk  len   0  1  0 */
        /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist!=0                               curr  1  top  blk  len   0  0  0 */
        /*                                                                                                                  c+dist  1 ptop  blk  len   0  0  1 */
        /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   0  0  1 */
        /*                                                                                                               p=1の場合,pref-addrは常にlmmi.top+ofs */
        /* LDDMQ set f=1 and p=1 in lmmc automatically                                                                        curr  1  top  -    -     0  1  1 */
	set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
        set_reg_path(last_row, last_col, 0, type, RTYPE_OFFS, 1, dmop1->offsv, dmop1->offsh, dmop1->offss);
        if (dmop1->topv  == T_VARIABLE) {
	  int rw = (dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1;
	  int f  = id[dmop1->forceh].val;
	  int p  = 0; /* initial value */
	  switch ((rw<<2)|(f<<1)|p) { /* AXI->LMM write対象(lmr/lmf/lmp/lmxの場合1:rw_f_p=000,010,001,110) *//* AXI<-LMM read対象(lmw/lmx/lmdの場合1:rw_f_p=100,110,101) */
	  case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
	  case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
	  case 6: /* lmx */                                     conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
	  case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
	  }
	  conf[last_row][last_col].cdw2.lmm_mode = 3;
	  lmmi[last_row][last_col].v     = 1;
	  lmmi[last_row][last_col].rw    = rw;
	  lmmi[last_row][last_col].f     = f;
	  lmmi[last_row][last_col].p     = p;
	  lmmi[last_row][last_col].blk   = dmop1->blk;
	  lmmi[last_row][last_col].cidx  = id[dmop1->toph].cidx;
	  lmmi[last_row][last_col].len   = id[dmop1->lenh].val-1;
	  lmmi[last_row][last_col].ofs   = 0; /* initial value */
	  lmmi[last_row][last_col].top   = (Ull)id[dmop1->toph].name;
	  lmmx[last_row][last_col].forcev= dmop1->forcev;
	  lmmx[last_row][last_col].forceh= dmop1->forceh;
	  lmmx[last_row][last_col].lenv  = dmop1->lenv;
	  lmmx[last_row][last_col].lenh  = dmop1->lenh;
        }
        if (dmop1->ptopv == T_VARIABLE) { /* lmp */
          if (last_row+current_mapdist >= EMAX_DEPTH) { /* copy前に検査 */
            printf("in %s: [%d][%d] prefetch exceeds EMAX_DEPTH\n", id[current_prefix].name, last_row, last_col);
            exit(1);
          }
          if (dec[last_row+current_mapdist][last_col].dmop0.op) {
            printf("in %s: [%d][%d] prefetch may conflict with other mop\n", id[current_prefix].name, last_row, last_col);
            exit(1);
          }
          if (current_mapdist==0) { /* old_LDBFQ */
            if (id[dmop1->forceh].val) { /* reserved for LDDMQ */
              /* f=1を指定してもignored */
            }
	    lmmi[last_row][last_col].p   = 1; /* optional prefetch *//* lmm_axiw/lmm_axirは，lmrとlmpとで同じ扱いなので設定済 */
	    lmmi[last_row][last_col].ofs = (Uint)(id[dmop1->ptoph].name - id[dmop1->toph].name);
          }
          else {
	    int rw = (dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1;
	    int f  = 0;
	    int p  = 1;
	    switch ((rw<<2)|(f<<1)|p) { /* AXI->LMM write対象(lmr/lmf/lmp/lmxの場合1:rw_f_p=000,010,001,110) *//* AXI<-LMM read対象(lmw/lmx/lmdの場合1:rw_f_p=100,110,101) */
	    case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row+current_mapdist][last_col].cdw2.lmm_axiw = 1; conf[last_row+current_mapdist][last_col].cdw2.lmm_axir = 0; break;
	    case 4: /* lmw */ case 5: /* lmd */                   conf[last_row+current_mapdist][last_col].cdw2.lmm_axiw = 0; conf[last_row+current_mapdist][last_col].cdw2.lmm_axir = 1; break;
	    case 6: /* lmx */                                     conf[last_row+current_mapdist][last_col].cdw2.lmm_axiw = 1; conf[last_row+current_mapdist][last_col].cdw2.lmm_axir = 1; break;
	    case 3: /* lddmq */ case 7: /* tr */                  conf[last_row+current_mapdist][last_col].cdw2.lmm_axiw = 0; conf[last_row+current_mapdist][last_col].cdw2.lmm_axir = 0; break;
	    }
	    conf[last_row+current_mapdist][last_col].cdw2.lmm_mode = 3;
	    lmmi[last_row+current_mapdist][last_col].v     = 1;
	    lmmi[last_row+current_mapdist][last_col].rw    = rw;
	    lmmi[last_row+current_mapdist][last_col].f     = f;
	    lmmi[last_row+current_mapdist][last_col].p     = p;
	    lmmi[last_row+current_mapdist][last_col].blk   = dmop1->blk;
	    lmmi[last_row+current_mapdist][last_col].cidx  = id[dmop1->ptoph].cidx;
	    lmmi[last_row+current_mapdist][last_col].len   = id[dmop1->plenh].val-1;
	    lmmi[last_row+current_mapdist][last_col].ofs   = 0;
	    lmmi[last_row+current_mapdist][last_col].top   = (Ull)id[dmop1->ptoph].name;
	    lmmx[last_row+current_mapdist][last_col].forcev= dmop1->forcev;
	    lmmx[last_row+current_mapdist][last_col].forceh= dmop1->forceh;
	    lmmx[last_row+current_mapdist][last_col].lenv  = dmop1->plenv;
	    lmmx[last_row+current_mapdist][last_col].lenh  = dmop1->plenh;
          }
        }
      }
      else { /* MTYPE_RSTORE, MTYPE_DLOAD, MTYPE_TRANS */
        /* ST with force-read=0 and ptop==NULL generates current(lmw) and reuse+wback LMM. same as lmw in EMAX4               curr  1  top  blk  len   1  0  0 */
        /* ST with force-read=1 and ptop==NULL generates current(lmx) and !reuse+wback LMM. same as lmx in EMAX4              curr  1  top  blk  len   1  1  0 */
        /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist!=0                               curr  1  top  blk  len   1  0  0 */
        /*                                                                                                                  c-dist  1 ptop  blk  len   1  0  1 */
        /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   1  0  1 */
        /*                                                                                                              p=1の場合,drain-addrは常にlmmi.top+ofs */
        /* TR    set f=1 and p=1 in lmmc automatically                                                                        curr  1  top  -    -     1  1  1 */
        if (insn[i].imop.mtype == MTYPE_RSTORE) { /* 3,2,1,0 */
          set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
          set_reg_path(last_row, last_col, 0, type, RTYPE_OFFS, 0, dmop0->offsv, dmop0->offsh, dmop0->offss);
          for (j=0; j<UNIT_WIDTH; j++)
            set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dmop0->mopdv, dmop0->mopdh, j);
        }
        else if (insn[i].imop.mtype == MTYPE_DLOAD) {
          set_reg_path(last_row, last_col, 0, 4 /*EXE*/, RTYPE_DATA, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
          set_reg_path(last_row, last_col, 0, 4 /*EXE*/, RTYPE_DATA, 0, dmop0->offsv, dmop0->offsh, dmop0->offss);
        }
        else if (insn[i].imop.mtype == MTYPE_TRANS) { /* 3,2,1,0 */
          for (j=0; j<=last_col; j++) /* OP_TR can accept empty portion */
            set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dmop0->mopdv, dmop0->mopdh, j);
        }
        if (dmop0->topv  == T_VARIABLE) {
	  int rw = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
	  int f  = (dmop0->mtype==MTYPE_DLOAD||dmop0->mtype==MTYPE_TRANS)?1:id[dmop0->forceh].val;
	  int p  = (dmop0->mtype==MTYPE_DLOAD||dmop0->mtype==MTYPE_TRANS)?1:0; /* initial value */
	  switch ((rw<<2)|(f<<1)|p) { /* AXI->LMM write対象(lmr/lmf/lmp/lmxの場合1:rw_f_p=000,010,001,110) *//* AXI<-LMM read対象(lmw/lmx/lmdの場合1:rw_f_p=100,110,101) */
	  case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
	  case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
	  case 6: /* lmx */                                     conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
	  case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
	  }
	  conf[last_row][last_col].cdw2.lmm_mode = 3;
	  lmmi[last_row][last_col].v     = 1;
	  lmmi[last_row][last_col].rw    = rw;
	  lmmi[last_row][last_col].f     = f;
	  lmmi[last_row][last_col].p     = p;
	  lmmi[last_row][last_col].blk   = dmop0->blk;
	  lmmi[last_row][last_col].cidx  = id[dmop0->toph].cidx;
	  lmmi[last_row][last_col].len   = id[dmop0->lenh].val-1;
	  lmmi[last_row][last_col].ofs   = 0; /* initial value */
	  lmmi[last_row][last_col].top   = (Ull)id[dmop0->toph].name;
	  lmmx[last_row][last_col].forcev= dmop0->forcev;
	  lmmx[last_row][last_col].forceh= dmop0->forceh;
	  lmmx[last_row][last_col].lenv  = dmop0->lenv;
	  lmmx[last_row][last_col].lenh  = dmop0->lenh;
        }
        else { /* LDDMQはtopv==NULL */
          if (insn[i].imop.mtype == MTYPE_DLOAD) {
	    int rw = 0;
	    int f  = 1;
	    int p  = 1;
	    switch ((rw<<2)|(f<<1)|p) { /* AXI->LMM write対象(lmr/lmf/lmp/lmxの場合1:rw_f_p=000,010,001,110) *//* AXI<-LMM read対象(lmw/lmx/lmdの場合1:rw_f_p=100,110,101) */
	    case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
	    case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
	    case 6: /* lmx */                                     conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
	    case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
	    }
	    conf[last_row][last_col].cdw2.lmm_mode = 3;
	    lmmi[last_row][last_col].v     = 1;
	    lmmi[last_row][last_col].rw    = rw;
	    lmmi[last_row][last_col].f     = f;
	    lmmi[last_row][last_col].p     = p;
	    lmmi[last_row][last_col].blk   = 0;
	    lmmi[last_row][last_col].cidx  = id[dmop0->toph].cidx;
	    lmmi[last_row][last_col].len   = 0;
	    lmmi[last_row][last_col].ofs   = 0;
	    lmmi[last_row][last_col].top   = (Ull)id[dmop0->toph].name;
	    lmmx[last_row][last_col].forcev= dmop0->forcev;
	    lmmx[last_row][last_col].forceh= dmop0->forceh;
	    lmmx[last_row][last_col].lenv  = dmop0->lenv;
	    lmmx[last_row][last_col].lenh  = dmop0->lenh;
          }
        }
        if (dmop0->ptopv == T_VARIABLE) { /* lmd */
          if (last_row-current_mapdist < 0) { /* copy前に検査 */
            printf("in %s: [%d][%d] drain exceeds EMAX_DEPTH\n", id[current_prefix].name, last_row, last_col);
            exit(1);
          }
          if (dec[last_row-current_mapdist][last_col].dmop1.op) {
            printf("in %s: [%d][%d] drain may conflict with other mop\n", id[current_prefix].name, last_row, last_col);
            exit(1);
          }
          if (current_mapdist==0) { /* old_STBFQ */
            if (id[dmop0->forceh].val) { /* reserved for TR */
              /* f=1を指定してもignored */
            }
	    lmmi[last_row][last_col].p   = 1; /* optional postdrain *//* lmm_axiw/lmm_axirは，lmwとlmdとで同じ扱いなので設定済 */
	    lmmi[last_row][last_col].ofs = (Uint)(id[dmop0->ptoph].name - id[dmop0->toph].name);
          }
          else {
	    if (lmmi[last_row-current_mapdist][last_col].v) {
	      printf("in %s: [%d][%d] drain may conflict with other lmm\n", id[current_prefix].name, last_row, last_col);
	      exit(1);
	    }
	    int rw = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
	    int f  = 0;
	    int p  = 1;
	    switch ((rw<<2)|(f<<1)|p) { /* AXI->LMM write対象(lmr/lmf/lmp/lmxの場合1:rw_f_p=000,010,001,110) *//* AXI<-LMM read対象(lmw/lmx/lmdの場合1:rw_f_p=100,110,101) */
	    case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row-current_mapdist][last_col].cdw2.lmm_axiw = 1; conf[last_row-current_mapdist][last_col].cdw2.lmm_axir = 0; break;
	    case 4: /* lmw */ case 5: /* lmd */                   conf[last_row-current_mapdist][last_col].cdw2.lmm_axiw = 0; conf[last_row-current_mapdist][last_col].cdw2.lmm_axir = 1; break;
	    case 6: /* lmx */                                     conf[last_row-current_mapdist][last_col].cdw2.lmm_axiw = 1; conf[last_row-current_mapdist][last_col].cdw2.lmm_axir = 1; break;
	    case 3: /* lddmq */ case 7: /* tr */                  conf[last_row-current_mapdist][last_col].cdw2.lmm_axiw = 0; conf[last_row-current_mapdist][last_col].cdw2.lmm_axir = 0; break;
	    }
	    conf[last_row-current_mapdist][last_col].cdw2.lmm_mode = 3;
	    lmmi[last_row-current_mapdist][last_col].v     = 1;
	    lmmi[last_row-current_mapdist][last_col].rw    = rw;
	    lmmi[last_row-current_mapdist][last_col].f     = f;
	    lmmi[last_row-current_mapdist][last_col].p     = p;
	    lmmi[last_row-current_mapdist][last_col].blk   = dmop0->blk;
	    lmmi[last_row-current_mapdist][last_col].cidx  = id[dmop0->ptoph].cidx;
	    lmmi[last_row-current_mapdist][last_col].len   = id[dmop0->plenh].val-1;
	    lmmi[last_row-current_mapdist][last_col].ofs   = 0;
	    lmmi[last_row-current_mapdist][last_col].top   = (Ull)id[dmop0->ptoph].name;
	    lmmx[last_row-current_mapdist][last_col].forcev= dmop0->forcev;
	    lmmx[last_row-current_mapdist][last_col].forceh= dmop0->forceh;
	    lmmx[last_row-current_mapdist][last_col].lenv  = dmop0->plenv;
	    lmmx[last_row-current_mapdist][last_col].lenh  = dmop0->plenh;
          }
        }
      }
      /* 1-6 *//* RLOAD,DLOAD:格納先busmapはBR止まり RSTORE,TRANS: 格納先busmapはMW止まり */
      if (insn[i].imop.mtype == MTYPE_RLOAD) {
        if (dmop1->topv  == T_VARIABLE) {
          for (j=0; j<UNIT_WIDTH; j++) {
            bus[last_row][last_col].lmwd[j].v = dmop1->topv;
            bus[last_row][last_col].lmwd[j].h = dmop1->toph;
            bus[last_row][last_col].lmwd[j].s = j;
            /* mwは実行時設定を優先(STATUS_LOADが実行時設定を無視) */
          }
        }
        if (dmop1->ptopv == T_VARIABLE) { /* lmp */
          dec[last_row+current_mapdist][last_col].dmop0.op = OP_IM_PREF; /* mapdist=0含む */
          for (j=0; j<UNIT_WIDTH; j++) {
            bus[last_row+current_mapdist][last_col].lmwd[j].v = dmop1->ptopv;
            bus[last_row+current_mapdist][last_col].lmwd[j].h = dmop1->ptoph;
            bus[last_row+current_mapdist][last_col].lmwd[j].s = j;
            bus[last_row+current_mapdist][last_col].mw[j].v = dmop1->ptopv;
            bus[last_row+current_mapdist][last_col].mw[j].h = dmop1->ptoph;
            bus[last_row+current_mapdist][last_col].mw[j].s = j;
          }
        }
        for (j=0; j<UNIT_WIDTH; j++) {
          bus[last_row][last_col].br[j].v = dmop1->mopdv;
          bus[last_row][last_col].br[j].h = dmop1->mopdh;
          bus[last_row][last_col].br[j].s = j;
        }
        conf[last_row][last_col].cdw2.brs0 = 1; /* 1:mr10 */
        conf[last_row][last_col].cdw2.brs1 = 1; /* 1:mr11 */
        conf[last_row][last_col].cdw2.brs2 = 1; /* 1:mr12 */
        conf[last_row][last_col].cdw2.brs3 = 1; /* 1:mr13 */
        id[insn[i].imop.mopdh].itype = ITYPE_MO4;
        id[insn[i].imop.mopdh].row   = last_row;
        id[insn[i].imop.mopdh].col   = last_col;
      }
      else if (insn[i].imop.mtype == MTYPE_DLOAD) { /* MTYPE_DLOADの主記憶ADDR送信設定 */
        /*-------------★★★★★★★★-----------------*/
        bus[last_row][last_col].exdrv = dexu->exdv;
        bus[last_row][last_col].exdrh = dexu->exdh;
        bus[last_row][last_col].exdrs = dexu->exds; /* &VARの場合-1, &VAR[c]の場合c, &AR[r][c]の場合c */
        /* setup LMM as FIFO */
        bus[last_row][last_col].ea0brv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査のため場所予約 */
        bus[last_row][last_col].ea0brh = -1;
        bus[last_row][last_col].ea0orv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査のため場所予約 */
        bus[last_row][last_col].ea0orh = -1;
        bus[last_row][last_col].ea1brv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査のため場所予約 */
        bus[last_row][last_col].ea1brh = -1;
        bus[last_row][last_col].ea1orv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査のため場所予約 */
        bus[last_row][last_col].ea1orh = -1;
        regv[last_row][last_col].ea0b_v = T_IMMEDIATE;
        regv[last_row][last_col].ea0b_h = hash_reg_immediate(0LL);
        regv[last_row][last_col].ea0b_s = -1;
        regv[last_row][last_col].ea0o_v = T_IMMEDIATE;
        regv[last_row][last_col].ea0o_h = hash_reg_immediate(32LL);
        regv[last_row][last_col].ea0o_s = -1;
        regv[last_row][last_col].ea1b_v = T_IMMEDIATE;
        regv[last_row][last_col].ea1b_h = hash_reg_immediate(0LL);
        regv[last_row][last_col].ea1b_s = -1;
        regv[last_row][last_col].ea1o_v = T_IMMEDIATE;
        regv[last_row][last_col].ea1o_h = hash_reg_immediate(32LL);
        regv[last_row][last_col].ea1o_s = -1;

        bus[last_row][last_col].mw[0].v = dmop0->basev;
        bus[last_row][last_col].mw[0].h = dmop0->baseh;
        bus[last_row][last_col].mw[0].s = dmop0->bases;
        bus[last_row][last_col].lmrd[0].v = dmop0->basev; /* for DLOAD-addr */
        bus[last_row][last_col].lmrd[0].h = dmop0->baseh; /* for DLOAD-addr */
        bus[last_row][last_col].lmrd[0].s = dmop0->bases; /* for DLOAD-addr */
        for (j=0; j<UNIT_WIDTH; j++) {
          bus[last_row][last_col].lmwd[j].v = dmop0->mopdv;
          bus[last_row][last_col].lmwd[j].h = dmop0->mopdh;
          bus[last_row][last_col].lmwd[j].s = j;
          bus[last_row][last_col].tr[j].v   = dmop0->mopdv;
          bus[last_row][last_col].tr[j].h   = dmop0->mopdh;
          bus[last_row][last_col].tr[j].s   = j;
          bus[last_row][last_col].br[j].v   = dmop0->mopdv;
          bus[last_row][last_col].br[j].h   = dmop0->mopdh;
          bus[last_row][last_col].br[j].s   = j;
        }
        conf[last_row][last_col].cdw2.brs0 = 2; /* 2:tr0 */
        conf[last_row][last_col].cdw2.brs1 = 2; /* 2:tr1 */
        conf[last_row][last_col].cdw2.brs2 = 2; /* 2:tr2 */
        conf[last_row][last_col].cdw2.brs3 = 2; /* 2:tr3 */
        id[insn[i].imop.mopdh].itype = ITYPE_MO4;
        id[insn[i].imop.mopdh].row   = last_row;
        id[insn[i].imop.mopdh].col   = last_col;
      }
      else if (insn[i].imop.mtype == MTYPE_TRANS) { /* MTYPE_TRANSのPARAM*4送信設定 */
        /*-------------★★★★★★★★-----------------*/
        /* dec[last_row][last_col].dmop0.op = OP_TR; /* may be redundant */
        /* setup LMM as FIFO */
        bus[last_row][last_col].ea0brv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査のため場所予約 */
        bus[last_row][last_col].ea0brh = -1;
        bus[last_row][last_col].ea0orv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査のため場所予約 */
        bus[last_row][last_col].ea0orh = -1;
        bus[last_row][last_col].ea1brv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査のため場所予約 */
        bus[last_row][last_col].ea1brh = -1;
        bus[last_row][last_col].ea1orv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査のため場所予約 */
        bus[last_row][last_col].ea1orh = -1;
        regv[last_row][last_col].ea0b_v = T_IMMEDIATE;
        regv[last_row][last_col].ea0b_h = hash_reg_immediate(0LL);
        regv[last_row][last_col].ea0b_s = -1;
        regv[last_row][last_col].ea0o_v = T_IMMEDIATE;
        regv[last_row][last_col].ea0o_h = hash_reg_immediate(32LL);
        regv[last_row][last_col].ea0o_s = -1;
        regv[last_row][last_col].ea1b_v = T_IMMEDIATE;
        regv[last_row][last_col].ea1b_h = hash_reg_immediate(0LL);
        regv[last_row][last_col].ea1b_s = -1;
        regv[last_row][last_col].ea1o_v = T_IMMEDIATE;
        regv[last_row][last_col].ea1o_h = hash_reg_immediate(32LL);
        regv[last_row][last_col].ea1o_s = -1;

        for (j=0; j<=last_col; j++) { /* OP_TR can accept empty portion */
          bus[last_row][last_col].mw[j].v = dmop0->mopdv;
          bus[last_row][last_col].mw[j].h = dmop0->mopdh;
          bus[last_row][last_col].mw[j].s = j;
          bus[last_row][last_col].lmrd[j].v = dmop0->mopdv;
          bus[last_row][last_col].lmrd[j].h = dmop0->mopdh;
          bus[last_row][last_col].lmrd[j].s = j;
        }
      }
      else { /* MTYPE_RSTORE */
        if (dmop0->ptopv == T_VARIABLE) { /* lmd */
          dec[last_row-current_mapdist][last_col].dmop1.op = OP_IM_DRAIN; /* mapdist=0含む */
          for (j=0; j<UNIT_WIDTH; j++) {
            bus[last_row-current_mapdist][last_col].lmrd[j].v = dmop0->ptopv;
            bus[last_row-current_mapdist][last_col].lmrd[j].h = dmop0->ptoph;
            bus[last_row-current_mapdist][last_col].lmrd[j].s = j;
          }
        }
        for (j=0; j<UNIT_WIDTH; j++) {
          bus[last_row][last_col].mw[j].v = dmop0->mopdv;
          bus[last_row][last_col].mw[j].h = dmop0->mopdh;
          bus[last_row][last_col].mw[j].s = j;
        }
      }
      insn[i].iheader.fixed = 1;
      break;
    case ITYPE_MOP: /* MOP */
      /***************************************************************/
      /* 1-1                                                         */
      /* MOP has &var,   &var[], &gpr,   &alr[][], &bdr[][][] as src */
      /*         store1, store1, store1, store1,   load1             */
      /***************************************************************/
      switch (insn[i].imop.op) {
      case OP_STR:  /* 64bit */
      case OP_STWR: /* 32bit */
//    case OP_STHR: /* 16bit */
      case OP_STBR: /*  8bit */
        current_lmmwb = 1; /* mark as dirty L1 shold be flushed+cleared before starting EMAX */
        get_valid_row(ITYPE_MOP, 1, insn[i].imop.mopdv, insn[i].imop.mopdh, rdep);
      case OP_LDR:  /* 64bit */
      case OP_LDWR: /* 32bit unsigned */
//    case OP_LDHR: /* 16bit unsigned */
      case OP_LDBR: /*  8bit unsigned */
        get_valid_row(ITYPE_MOP, 1, insn[i].imop.exv,   insn[i].imop.exh,   rdep);
        get_valid_row(ITYPE_MOP, 0, insn[i].imop.basev, insn[i].imop.baseh, rdep);
        get_valid_row(ITYPE_MOP, 0, insn[i].imop.offsv, insn[i].imop.offsh, rdep);
        break;
      default:
        printf("in %s: mop found illegal op=%d\n", id[current_prefix].name, insn[i].imop.op);
        exit(1);
      }

      folding = 0; /* reset */

      if (insn[i].imop.mtype == MTYPE_RLOAD)
        last_mop = 1;
      else /* MTYPE_RSTORE, MTYPE_DLOAD, MTYPE_TRANS */
        last_mop = 0;
      if (row < 0) { /* none of WHILE/ALR/BDR is specified */
        /* 1-2a */
        if (last_row < *rdep) { /* 間を空けて配置可能 */
          last_row = *rdep;
          last_col = 0; /* 位置指定可能ex4.dstはALRのみ.var経由の同一row内後続st4()を配置可能 */
        }
        else { /* last_row >= *rdep *//* 最終位置と依存関係制約位置が一致 */
          int op0 = dec[last_row][last_col].dmop0.op;
          int op1 = dec[last_row][last_col].dmop1.op;
          int typ = dec[last_row][last_col].dmop1.mtype;
          int tpv = dec[last_row][last_col].dmop1.topv;
          int tph = dec[last_row][last_col].dmop1.toph;
          int lev = dec[last_row][last_col].dmop1.lenv;
          int leh = dec[last_row][last_col].dmop1.lenh;
          int blk = dec[last_row][last_col].dmop1.blk;
          int fcev= dec[last_row][last_col].dmop1.forcev;
          int fceh= dec[last_row][last_col].dmop1.forceh;
          int ldx2_and_op0_is_empty = (op1 && !op0) && (typ == MTYPE_RLOAD)
                                   && (typ == insn[i].imop.mtype)
                                   && (tpv == insn[i].imop.topv)
                                   && (tph == insn[i].imop.toph)
                                   && (lev == insn[i].imop.lenv)
                                   && (leh == insn[i].imop.lenh)
                                   && (blk == insn[i].imop.blk)
                                   && (fcev== insn[i].imop.forcev)
                                   && (fceh== insn[i].imop.forceh);
          if (ldx2_and_op0_is_empty)
            last_mop = 0; /* secoundary load */
	  else if (insn[i].imop.mtype == MTYPE_RSTORE) { /* first pair of EXE0->ST0;EXE1->ST1 */
	    for (j=0; j<EMAX_WIDTH; j++) {
	      if (insn[i].imop.mopdh == dec[last_row][j].dexu.exdh) {
		last_col = j;
		break;
	      }
	    }
	    if (dec[last_row][last_col].dexu.fold) { /* exeがfoldなら同一unit.storeも無条件でfold */
	      printf("load-exe-store folding assumed ");
	      folding = 1; /* load-exe-store folding */
	    }
	  }
	  else if (op0 && !op1 && insn[i].imop.mtype == MTYPE_RLOAD) { /* double buffering (st+ld) */
	    /* allocate LD at the same col as ST */
	  }
          else if (op0 || op1) { /* mop0(l/s)=full */
	    /* new_load,new_storeは次colへ */
	    last_col++; /* overflowはあとで検査.EXEがWIDTH以上あれば次段へ移動 */
	    if (last_col >= EMAX_WIDTH) {
	      last_row++;
	      last_col = 0;
	    }
          }
        }
      }
      else { /* WHILE/ALR/BDR is specified */
        /* 1-2b */
        if (row < *rdep) { /* 指定rowには配置困難 */
          printf("in %s: mop cannot locate destination ALRNO/BDRNO (row=%d)\n", id[current_prefix].name, row);
          exit(1);
        }
        else if (row < last_row) {
          printf("in %s: mop found violation of sequence (row=%d < last_row=%d)\n", id[current_prefix].name, row, last_row);
          exit(1);
        }
        else {
          last_row = row;
          last_col = col;
          int op0 = dec[last_row][last_col].dmop0.op;
          int op1 = dec[last_row][last_col].dmop1.op;
          int typ = dec[last_row][last_col].dmop1.mtype;
          int tpv = dec[last_row][last_col].dmop1.topv;
          int tph = dec[last_row][last_col].dmop1.toph;
          int lev = dec[last_row][last_col].dmop1.lenv;
          int leh = dec[last_row][last_col].dmop1.lenh;
          int blk = dec[last_row][last_col].dmop1.blk;
          int fcev= dec[last_row][last_col].dmop1.forcev;
          int fceh= dec[last_row][last_col].dmop1.forceh;
          int ldx2_and_op0_is_empty = (op1 && !op0) && (typ == MTYPE_RLOAD)
                                   && (typ == insn[i].imop.mtype)
                                   && (tpv == insn[i].imop.topv)
                                   && (tph == insn[i].imop.toph)
                                   && (lev == insn[i].imop.lenv)
                                   && (leh == insn[i].imop.lenh)
                                   && (blk == insn[i].imop.blk)
                                   && (fcev== insn[i].imop.forcev)
                                   && (fceh== insn[i].imop.forceh);
          int mex2_and_op0_is_empty = (op1 && !op0) && (typ == MTYPE_RLOAD)
                                   && (typ == insn[i].imop.mtype)
                                   && (blk == insn[i].imop.blk)
                                   && (fcev== insn[i].imop.forcev)
                                   && (fceh== insn[i].imop.forceh)
	                           && (dec[last_row][last_col].dmex.op0)
	                           && (dec[last_row][last_col].dmex.op1);
          if (ldx2_and_op0_is_empty)
            last_mop = 0; /* load */
	  else if (mex2_and_op0_is_empty) /* mex should merge op1(map to LMM/col2) and op0(map to LMM/col1) w/ different top */
	    last_mop = 0; /* mex load */
	  else if (insn[i].imop.mtype == MTYPE_RSTORE) { /* first pair of EXE0->ST0;EXE1->ST1 */
	    if (dec[last_row][last_col].dexu.fold) { /* exeがfoldなら同一unit.storeも無条件でfold */
	      printf("load-exe-store folding assumed ");
	      folding = 1; /* load-exe-store folding */
	    }
	  }
        }
      }
      /* 1-3 */
      if (last_row >= EMAX_DEPTH || last_col >= EMAX_WIDTH) { /* copy前に検査 */
        printf("in %s: [%d][%d] mop exceeds EMAX_DEPTH/EMAX_WIDTH\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      if (last_mop==0 && dec[last_row][last_col].dmop0.op) {
        printf("in %s: [%d][%d] mop conflicts\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      if (last_mop==1 && dec[last_row][last_col].dmop1.op) {
        printf("in %s: [%d][%d] mop conflicts\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
      /* 1-4 */
      dmex  = &dec[last_row][last_col].dmex;
      dmop0 = &dec[last_row][last_col].dmop0;
      dmop1 = &dec[last_row][last_col].dmop1;
      if (last_mop==1) { /* load */
        *dmop1 = insn[i].imop;
	if (dmex->op1 && insn[i].imex.op1) {
	  printf("in %s: [%d][%d] mex1 & mop1(adr++) conflicts\n", id[current_prefix].name, last_row, last_col);
	  exit(1);
	}
	else if (insn[i].imex.op0) { /* mop()のINCR情報はmex0にある */
	  dmex->op1    = insn[i].imex.op0;
	  dmex->dist2v = insn[i].imex.dist1v;
	  dmex->dist2h = insn[i].imex.dist1h;
	}
      }
      else { /* store/load */
        *dmop0 = insn[i].imop;
	if (dmex->op0 && insn[i].imex.op0) {
	  printf("in %s: [%d][%d] mex0 & mop0(adr++) conflicts\n", id[current_prefix].name, last_row, last_col);
	  exit(1);
	}
	else if (insn[i].imex.op0) { /* mop()のINCR情報はmex0にある */
	  *dmex = insn[i].imex;
	  dmex->op0    = insn[i].imex.op0;
	  dmex->dist1v = insn[i].imex.dist1v;
	  dmex->dist1h = insn[i].imex.dist1h;
	}
      }
      /* 1-5 */
      if (last_mop==1) { /* load */
        /* LD with force-read=0 and ptop==NULL generates current(lmr) and reuse LMM. same as lmr in EMAX4                     curr  1  top  blk  len   0  0  0 */
        /* LD with force-read=1 and ptop==NULL generates current(lmf) and !reuse LMM. same as lmf in EMAX4                    curr  1  top  blk  len   0  1  0 */
        /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist!=0                               curr  1  top  blk  len   0  0  0 */
        /*                                                                                                                  c+dist  1 ptop  blk  len   0  0  1 */
        /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   0  0  1 */
        /*                                                                                                               p=1の場合,pref-addrは常にlmmi.top+ofs */
        /* LDDMQ set f=1 and p=1 in lmmc automatically                                                                        curr  1  top  -    -     0  1  1 */
	if (!(dmex->op1 && dmex->mexd1h == dmop1->baseh))
	  set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
        set_reg_path(last_row, last_col, 0, type, RTYPE_OFFS, 1, dmop1->offsv, dmop1->offsh, dmop1->offss);
        if (dmop1->topv  == T_VARIABLE) {
	  int rw = (dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1;
	  int f  = id[dmop1->forceh].val;
	  int p  = 0; /* initial value */
	  int last_col_mex = last_col;
          if (dmop1->mtype == MTYPE_RLOAD && (dmex->op1== OP_CMPA_LE || dmex->op1 == OP_CMPA_GE)) {
	    //printf("MOP1 CMPA RLOAD\n");
	  }
	  else if (last_col == 1 && dmop1->mtype == MTYPE_RLOAD && (dec[last_row][2].dmex.op0 == OP_CMPA_LE || dec[last_row][2].dmex.op0 == OP_CMPA_GE)) { /* load in load-cfma-store */
	    //printf("MOP0 CMPA RLOAD(load-cfms-store)\n");
	    last_col_mex = 0; //★★★ last_col=1の場合,mop0のlast_col_mexは0固定でよい
	  }
	  switch ((rw<<2)|(f<<1)|p) { /* AXI->LMM write対象(lmr/lmf/lmp/lmxの場合1:rw_f_p=000,010,001,110) *//* AXI<-LMM read対象(lmw/lmx/lmdの場合1:rw_f_p=100,110,101) */
	  case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col_mex].cdw2.lmm_axiw = 1; conf[last_row][last_col_mex].cdw2.lmm_axir = 0; break;
	  case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col_mex].cdw2.lmm_axiw = 0; conf[last_row][last_col_mex].cdw2.lmm_axir = 1; break;
	  case 6: /* lmx */                                     conf[last_row][last_col_mex].cdw2.lmm_axiw = 1; conf[last_row][last_col_mex].cdw2.lmm_axir = 1; break;
	  case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col_mex].cdw2.lmm_axiw = 0; conf[last_row][last_col_mex].cdw2.lmm_axir = 0; break;
	  }
	  conf[last_row][last_col_mex].cdw2.lmm_mode = 3;
	  lmmi[last_row][last_col_mex].v     = 1;
	  lmmi[last_row][last_col_mex].rw    = rw;
	  lmmi[last_row][last_col_mex].f     = f;
	  lmmi[last_row][last_col_mex].p     = p;
	  lmmi[last_row][last_col_mex].blk   = dmop1->blk;
	  lmmi[last_row][last_col_mex].cidx  = id[dmop1->toph].cidx;
	  lmmi[last_row][last_col_mex].len   = id[dmop1->lenh].val-1;
	  lmmi[last_row][last_col_mex].ofs   = 0; /* initial value */
	  lmmi[last_row][last_col_mex].top   = (Ull)id[dmop1->toph].name;
	  lmmx[last_row][last_col_mex].forcev= dmop1->forcev;
	  lmmx[last_row][last_col_mex].forceh= dmop1->forceh;
	  lmmx[last_row][last_col_mex].lenv  = dmop1->lenv;
	  lmmx[last_row][last_col_mex].lenh  = dmop1->lenh;
        }
        if (dmop1->ptopv == T_VARIABLE) { /* lmp */
          if (last_row+current_mapdist >= EMAX_DEPTH) { /* copy前に検査 */
            printf("in %s: [%d][%d] prefetch exceeds EMAX_DEPTH\n", id[current_prefix].name, last_row, last_col);
            exit(1);
          }
          if (dec[last_row+current_mapdist][last_col].dmop0.op) {
            printf("in %s: [%d][%d] prefetch may conflict with other mop\n", id[current_prefix].name, last_row, last_col);
            exit(1);
          }
          if (current_mapdist==0) { /* old_LDBF */
            if (id[dmop1->forceh].val) { /* reserved for LDDMQ */
              /* f=1を指定してもignored */
            }
	    lmmi[last_row][last_col].p   = 1; /* optional prefetch *//* lmm_axiw/lmm_axirは，lmrとlmpとで同じ扱いなので設定済 */
	    lmmi[last_row][last_col].ofs = (Uint)(id[dmop1->ptoph].name - id[dmop1->toph].name);
          }
          else {
	    int rw = (dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1;
	    int f  = 0;
	    int p  = 1;
	    switch ((rw<<2)|(f<<1)|p) { /* AXI->LMM write対象(lmr/lmf/lmp/lmxの場合1:rw_f_p=000,010,001,110) *//* AXI<-LMM read対象(lmw/lmx/lmdの場合1:rw_f_p=100,110,101) */
	    case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row+current_mapdist][last_col].cdw2.lmm_axiw = 1; conf[last_row+current_mapdist][last_col].cdw2.lmm_axir = 0; break;
	    case 4: /* lmw */ case 5: /* lmd */                   conf[last_row+current_mapdist][last_col].cdw2.lmm_axiw = 0; conf[last_row+current_mapdist][last_col].cdw2.lmm_axir = 1; break;
	    case 6: /* lmx */                                     conf[last_row+current_mapdist][last_col].cdw2.lmm_axiw = 1; conf[last_row+current_mapdist][last_col].cdw2.lmm_axir = 1; break;
	    case 3: /* lddmq */ case 7: /* tr */                  conf[last_row+current_mapdist][last_col].cdw2.lmm_axiw = 0; conf[last_row+current_mapdist][last_col].cdw2.lmm_axir = 0; break;
	    }
	    conf[last_row+current_mapdist][last_col].cdw2.lmm_mode = 3;
	    lmmi[last_row+current_mapdist][last_col].v     = 1;
	    lmmi[last_row+current_mapdist][last_col].rw    = rw;
	    lmmi[last_row+current_mapdist][last_col].f     = f;
	    lmmi[last_row+current_mapdist][last_col].p     = p;
	    lmmi[last_row+current_mapdist][last_col].blk   = dmop1->blk;
	    lmmi[last_row+current_mapdist][last_col].cidx  = id[dmop1->ptoph].cidx;
	    lmmi[last_row+current_mapdist][last_col].len   = id[dmop1->plenh].val-1;
	    lmmi[last_row+current_mapdist][last_col].ofs   = 0;
	    lmmi[last_row+current_mapdist][last_col].top   = (Ull)id[dmop1->ptoph].name;
	    lmmx[last_row+current_mapdist][last_col].forcev= dmop1->forcev;
	    lmmx[last_row+current_mapdist][last_col].forceh= dmop1->forceh;
	    lmmx[last_row+current_mapdist][last_col].lenv  = dmop1->plenv;
	    lmmx[last_row+current_mapdist][last_col].lenh  = dmop1->plenh;
          }
        }
      }
      else { /* store/load */
        /* ST with force-read=0 and ptop==NULL generates current(lmw) and reuse+wback LMM. same as lmw in EMAX4               curr  1  top  blk  len   1  0  0 */
        /* ST with force-read=1 and ptop==NULL generates current(lmx) and !reuse+wback LMM. same as lmx in EMAX4              curr  1  top  blk  len   1  1  0 */
        /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist!=0                               curr  1  top  blk  len   1  0  0 */
        /*                                                                                                                  c-dist  1 ptop  blk  len   1  0  1 */
        /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   1  0  1 */
        /*                                                                                                              p=1の場合,drain-addrは常にlmmi.top+ofs */
        /* TR    set f=1 and p=1 in lmmc automatically                                                                        curr  1  top  -    -     1  1  1 */
        if (insn[i].imop.mtype == MTYPE_RSTORE)
          set_reg_path(last_row, last_col, folding, type, RTYPE_DATA, 0, dmop0->mopdv, dmop0->mopdh, dmop0->mopds);
	if (!(dmex->op0 && dmex->mexd0h == dmop0->baseh))
	  set_reg_path(last_row, last_col, folding, type, RTYPE_BASE, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
        set_reg_path(last_row, last_col, folding, type, RTYPE_OFFS, 0, dmop0->offsv, dmop0->offsh, dmop0->offss);
        if (dmop0->topv  == T_VARIABLE) {
	  int rw = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
	  int f  = id[dmop0->forceh].val;
	  int p  = 0; /* initial value */
	  int last_col_mex = last_col;
          if (dmop0->mtype == MTYPE_RLOAD && !(dmex->op0 == OP_CMPA_LE || dmex->op0 == OP_CMPA_GE)) {
            /* if ldx2_and_op0_is_empty==true, dmop0 can share lmmi with dmop1 */
          }
          else {
	    if (dmex->op0 == OP_CMPA_LE || dmex->op0 == OP_CMPA_GE) { /* dmop0->mtype == MTYPE_RLOAD && (dmex->op0 == OP_CMPA_LE || dmex->op0 == OP_CMPA_GE) */
	      //printf("MOP0 CMPA RLOAD\n");
	      if (last_col < 2) {
		printf("in %s: [%d][%d] mex0 should be located col>=2\n", id[current_prefix].name, last_row, last_col);
		exit(1);
	      }
	      if (id[dmop0->toph].name != id[dmop1->toph].name) { /* lmm領域が異なる場合(Sparse matrix) */
		last_col_mex = 1; //★★★ last_col=3,2の場合,mop0のlast_col_mexは1固定でよい
	        printf("dmex0.lmm moved from col%d to col%d ", last_col, last_col_mex);
	      }
	      else { /* lmm領域が同じ場合(Merge sort) */
	        printf("dmex0.lmm keep col%d ", last_col_mex);
	      }
	    }
	    else if (last_col == 1 && dmop0->mtype == MTYPE_RSTORE && (dec[last_row][2].dmex.op0 == OP_CMPA_LE || dec[last_row][2].dmex.op0 == OP_CMPA_GE)) { /* store in load-cfma-store */
	      //printf("MOP0 CMPA RSTORE(load-cfms-store)\n");
	      last_col_mex = 0; //★★★ last_col=1の場合,mop0のlast_col_mexは0固定でよい
	    }
	    switch ((rw<<2)|(f<<1)|p) { /* AXI->LMM write対象(lmr/lmf/lmp/lmxの場合1:rw_f_p=000,010,001,110) *//* AXI<-LMM read対象(lmw/lmx/lmdの場合1:rw_f_p=100,110,101) */
	    case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col_mex].cdw2.lmm_axiw = 1; conf[last_row][last_col_mex].cdw2.lmm_axir = 0; break;
	    case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col_mex].cdw2.lmm_axiw = 0; conf[last_row][last_col_mex].cdw2.lmm_axir = 1; break;
	    case 6: /* lmx */                                     conf[last_row][last_col_mex].cdw2.lmm_axiw = 1; conf[last_row][last_col_mex].cdw2.lmm_axir = 1; break;
	    case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col_mex].cdw2.lmm_axiw = 0; conf[last_row][last_col_mex].cdw2.lmm_axir = 0; break;
	    }
	    conf[last_row][last_col_mex].cdw2.lmm_mode = 3;
            lmmi[last_row][last_col_mex].v     = 1;
            lmmi[last_row][last_col_mex].rw    = rw;
            lmmi[last_row][last_col_mex].f     = f;
            lmmi[last_row][last_col_mex].p     = p;
            lmmi[last_row][last_col_mex].blk   = dmop0->blk;
	    lmmi[last_row][last_col_mex].cidx  = id[dmop0->toph].cidx;
            lmmi[last_row][last_col_mex].len   = id[dmop0->lenh].val-1;
            lmmi[last_row][last_col_mex].ofs   = 0; /* initial value */
            lmmi[last_row][last_col_mex].top   = (Ull)id[dmop0->toph].name;
            lmmx[last_row][last_col_mex].forcev= dmop0->forcev;
            lmmx[last_row][last_col_mex].forceh= dmop0->forceh;
            lmmx[last_row][last_col_mex].lenv  = dmop0->lenv;
            lmmx[last_row][last_col_mex].lenh  = dmop0->lenh;
          }
        }
        if (dmop0->ptopv == T_VARIABLE) { /* lmd */
          if (insn[i].imop.mtype == MTYPE_RLOAD) {
            /* if ldx2_and_op0_is_empty==true, dmop0 can share lmmi with dmop1 */
          }
          else { /* MTYPE_RSTORE */
            if (last_row-current_mapdist < 0) { /* copy前に検査 */
              printf("in %s: [%d][%d] drain exceeds EMAX_DEPTH\n", id[current_prefix].name, last_row, last_col);
              exit(1);
            }
            if (dec[last_row-current_mapdist][last_col].dmop1.op) {
              printf("in %s: [%d][%d] drain may conflict with other mop\n", id[current_prefix].name, last_row, last_col);
              exit(1);
            }
            if (current_mapdist==0) { /* old_STBF */
              if (id[dmop0->forceh].val) { /* reserved for TR */
                /* f=1を指定してもignored */
              }
              lmmi[last_row][last_col].p   = 1; /* optional postdrain *//* lmm_axiw/lmm_axirは，lmwとlmdとで同じ扱いなので設定済 */
              lmmi[last_row][last_col].ofs = (Uint)(id[dmop0->ptoph].name - id[dmop0->toph].name);
            }
            else {
              if (lmmi[last_row-current_mapdist][last_col].v) {
                printf("in %s: [%d][%d] drain may conflict with other lmm\n", id[current_prefix].name, last_row, last_col);
                exit(1);
              }
	      int rw = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
	      int f  = 0;
	      int p  = 1;
	      switch ((rw<<2)|(f<<1)|p) { /* AXI->LMM write対象(lmr/lmf/lmp/lmxの場合1:rw_f_p=000,010,001,110) *//* AXI<-LMM read対象(lmw/lmx/lmdの場合1:rw_f_p=100,110,101) */
	      case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row-current_mapdist][last_col].cdw2.lmm_axiw = 1; conf[last_row-current_mapdist][last_col].cdw2.lmm_axir = 0; break;
	      case 4: /* lmw */ case 5: /* lmd */                   conf[last_row-current_mapdist][last_col].cdw2.lmm_axiw = 0; conf[last_row-current_mapdist][last_col].cdw2.lmm_axir = 1; break;
	      case 6: /* lmx */                                     conf[last_row-current_mapdist][last_col].cdw2.lmm_axiw = 1; conf[last_row-current_mapdist][last_col].cdw2.lmm_axir = 1; break;
	      case 3: /* lddmq */ case 7: /* tr */                  conf[last_row-current_mapdist][last_col].cdw2.lmm_axiw = 0; conf[last_row-current_mapdist][last_col].cdw2.lmm_axir = 0; break;
	      }
	      conf[last_row-current_mapdist][last_col].cdw2.lmm_mode = 3;
              lmmi[last_row-current_mapdist][last_col].v     = 1;
              lmmi[last_row-current_mapdist][last_col].rw    = rw;
              lmmi[last_row-current_mapdist][last_col].f     = f;
              lmmi[last_row-current_mapdist][last_col].p     = p;
              lmmi[last_row-current_mapdist][last_col].blk   = dmop0->blk;
	      lmmi[last_row-current_mapdist][last_col].cidx  = id[dmop0->ptoph].cidx;
              lmmi[last_row-current_mapdist][last_col].len   = id[dmop0->plenh].val-1;
              lmmi[last_row-current_mapdist][last_col].ofs   = 0;
              lmmi[last_row-current_mapdist][last_col].top   = (Ull)id[dmop0->ptoph].name;
              lmmx[last_row-current_mapdist][last_col].forcev= dmop0->forcev;
              lmmx[last_row-current_mapdist][last_col].forceh= dmop0->forceh;
              lmmx[last_row-current_mapdist][last_col].lenv  = dmop0->plenv;
              lmmx[last_row-current_mapdist][last_col].lenh  = dmop0->plenh;
            }
          }
        }
      }
      /* 1-6 *//* RLOAD,DLOAD:格納先busmapはBR止まり RSTORE,TRANS: 格納先busmapはTR止まり */
      if (insn[i].imop.mtype == MTYPE_RLOAD) {
        if (last_mop==1) { /* load */
          if (dmop1->topv  == T_VARIABLE) {
            for (j=0; j<UNIT_WIDTH; j++) {
              bus[last_row][last_col].lmwd[j].v = dmop1->topv;
              bus[last_row][last_col].lmwd[j].h = dmop1->toph;
              bus[last_row][last_col].lmwd[j].s = j;
              /* mwは実行時設定を優先(STATUS_LOADが実行時設定を無視) */
            }
          }
          if (dmop1->ptopv == T_VARIABLE) { /* lmp */
            dec[last_row+current_mapdist][last_col].dmop0.op = OP_IM_PREF; /* mapdist=0含む */
            for (j=0; j<UNIT_WIDTH; j++) {
              bus[last_row+current_mapdist][last_col].lmwd[j].v = dmop1->ptopv;
              bus[last_row+current_mapdist][last_col].lmwd[j].h = dmop1->ptoph;
              bus[last_row+current_mapdist][last_col].lmwd[j].s = j;
              bus[last_row+current_mapdist][last_col].mw[j].v   = dmop1->ptopv;
              bus[last_row+current_mapdist][last_col].mw[j].h   = dmop1->ptoph;
              bus[last_row+current_mapdist][last_col].mw[j].s   = j;
            }
          }
          if (dmop1->mopds == 0) {
            printf("in %s: [%d][%d] mop1 cannot connect to %s[%d]\n", id[current_prefix].name, last_row, last_col, id[dmop1->mopdh].name,dmop1->mopds);
            exit(1);
          }
          bus[last_row][last_col].br[1].v = dmop1->mopdv;
          bus[last_row][last_col].br[1].h = dmop1->mopdh;
          bus[last_row][last_col].br[1].s = dmop1->mopds;
          conf[last_row][last_col].cdw2.brs1 = 3; /* 3:mr1 */
        }
        else { /* store/load */
          if (dmop0->mopds == 1) {
            printf("in %s: [%d][%d] mop0 cannot connect to %s[%d]\n", id[current_prefix].name, last_row, last_col, id[dmop1->mopdh].name,dmop1->mopds);
            exit(1);
          }
          bus[last_row][last_col].br[0].v = dmop0->mopdv;
          bus[last_row][last_col].br[0].h = dmop0->mopdh;
          bus[last_row][last_col].br[0].s = dmop0->mopds;
          conf[last_row][last_col].cdw2.brs0 = 3; /* 3:mr0 */
        }
        id[insn[i].imop.mopdh].itype = ITYPE_MOP;
        id[insn[i].imop.mopdh].row   = last_row;
        id[insn[i].imop.mopdh].col   = last_col;
      }
      else { /* MTYPE_RSTORE */
        if (dmop0->ptopv == T_VARIABLE) { /* lmd */
          dec[last_row-current_mapdist][last_col].dmop1.op = OP_IM_DRAIN; /* mapdist=0含む */
          for (j=0; j<UNIT_WIDTH; j++) {
            bus[last_row-current_mapdist][last_col].lmrd[j].v = dmop0->ptopv;
            bus[last_row-current_mapdist][last_col].lmrd[j].h = dmop0->ptoph;
            bus[last_row-current_mapdist][last_col].lmrd[j].s = j;
          }
        }
        for (j=0; j<UNIT_WIDTH; j++) {
          bus[last_row][last_col].mw[j].v = dmop0->mopdv;
          bus[last_row][last_col].mw[j].h = dmop0->mopdh;
          bus[last_row][last_col].mw[j].s = dmop0->mopds;
        }
      }
      insn[i].iheader.fixed = 1;
      break;
    default: /* illegal */
      break;
    }
#if 1
    printf("dec[%d][%d]:type=%d\n", last_row, last_col, type);
#endif
    if (last_col == 0 && dec[last_row][0].dexu.op1 == OP_FOR && dec[last_row][1].dexu.op1 == OP_FOR)
      last_col++; /* max number of LOOP# */
  }
  /**********************************************************************************************************/
  /* Step 2 ... setup conf[][]                                                                              */
  /* 2-1. select EXE-in                                                                                     */
  /* 2-2. select CEX-in and EAG-in                                                                          */
  /**********************************************************************************************************/
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      int ea0rs, ea1rs;
      /* 2-1 */
      /* ex[123] depends on busmap[i][j].br[prev][] and decode[i][j].dexu.ex[123] */
      conf[i][j].cdw0.v      = (i <= last_row) ? 1 : 0;
      conf[i][j].cdw0.op1    = dec[i][j].dexu.op1;
      conf[i][j].cdw0.op2    = dec[i][j].dexu.op2;
      conf[i][j].cdw0.op3    = dec[i][j].dexu.op3;
      conf[i][j].cdw0.ex1brs = search_prev_br0(i, dec[i][j].dexu.fold, dec[i][j].dexu.ex1v, dec[i][j].dexu.ex1h, dec[i][j].dexu.ex1s);
      conf[i][j].cdw0.ex1s   = dec[i][j].dexu.updt; /* 0->0 or 0->1 */
      conf[i][j].cdw0.ex1exp = dec[i][j].dexu.ex1e;
      conf[i][j].cdw0.ex2brs = search_prev_br0(i, dec[i][j].dexu.fold, dec[i][j].dexu.ex2v, dec[i][j].dexu.ex2h, dec[i][j].dexu.ex2s);
      conf[i][j].cdw0.ex2exp = dec[i][j].dexu.ex2e;
      conf[i][j].cdw0.ex3brs = search_prev_br0(i, dec[i][j].dexu.fold, dec[i][j].dexu.ex3v, dec[i][j].dexu.ex3h, dec[i][j].dexu.ex3s);
      conf[i][j].cdw0.ex3exp = dec[i][j].dexu.ex3e;
      if (dec[i][j].dexu.e2iv==T_IMMEDIATE)
        conf[i][j].cdw3.e2imm  = id[dec[i][j].dexu.e2ih].val;
      else
        conf[i][j].cdw3.e2imm  = 0;
      conf[i][j].cdw0.e2is   = dec[i][j].dexu.e2is;
      if (dec[i][j].dexu.e3iv==T_IMMEDIATE) {
        if ((Ull)id[dec[i][j].dexu.e3ih].val > (1<<E3IMMBITS)-1) {
          printf("in %s: [%d][%d] cannot fit to e3imm(unsigned %dbit) immediate=0x%08.8x%08.8x\n", id[current_prefix].name, i, j, E3IMMBITS, (Uint)(id[dec[i][j].dexu.e3ih].val>>32), (Uint)id[dec[i][j].dexu.e3ih].val);
          exit(1);
        }
        conf[i][j].cdw0.e3imm  = id[dec[i][j].dexu.e3ih].val;
      }
      else
        conf[i][j].cdw0.e3imm  = 0;
      conf[i][j].cdw0.e3is   = dec[i][j].dexu.e3is;
      conf[i][j].cdw0.init   = dec[i][j].dexu.init; /* case of updt=0: bit0:activate s2+INIT0 bit1:activate s3+INIT1 */
      conf[i][j].cdw0.fold   = dec[i][j].dexu.fold; /* for load-exe-store folding */
      //printf("conf[%d][%d]: init=%d fold=%d\n", i, j, conf[i][j].cdw0.init, conf[i][j].cdw0.fold);

      /* 2-2 */
      /* cs[0-3] depends on busmap[i][j].br[prev][] and decode[i][j].dcex.bit[0-3] */
      conf[i][j].cdw1.cs0    = search_prev_br0(i, dec[i][j].dexu.fold, dec[i][j].dcex.bit0v, dec[i][j].dcex.bit0h, -1);
      conf[i][j].cdw1.cs1    = search_prev_br0(i, dec[i][j].dexu.fold, dec[i][j].dcex.bit1v, dec[i][j].dcex.bit1h, -1);
      conf[i][j].cdw1.cs2    = search_prev_br0(i, dec[i][j].dexu.fold, dec[i][j].dcex.bit2v, dec[i][j].dcex.bit2h, -1);
      conf[i][j].cdw1.cs3    = search_prev_br0(i, dec[i][j].dexu.fold, dec[i][j].dcex.bit3v, dec[i][j].dcex.bit3h, -1);
      conf[i][j].cdw1.cex_tab= dec[i][j].dcex.op ? dec[i][j].dcex.table : 0xffff; /* always true */

      /* mex0/mop0 */
      conf[i][j].cdw0.mex0op   = dec[i][j].dmex.op0;
      conf[i][j].cdw0.mex0init = dec[i][j].dmex.init;
      switch (id[dec[i][j].dmex.dist1h].val) { /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
      case  0: conf[i][j].cdw0.mex0dist = 0; break;
      case  1: conf[i][j].cdw0.mex0dist = 1; break;
      case  2: conf[i][j].cdw0.mex0dist = 2; break;
      case  4: conf[i][j].cdw0.mex0dist = 3; break;
      case  8: conf[i][j].cdw0.mex0dist = 4; break;
      case 16: conf[i][j].cdw0.mex0dist = 5; break;
      case 32: conf[i][j].cdw0.mex0dist = 6; break;
      default: conf[i][j].cdw0.mex0dist = 7; break;
      }
      if (dec[i][j].dmex.op0) {
	switch (id[dec[i][j].dmex.limith].val) { /* limit 0:0, 1:8, 2:16, .... 10:4096, 11:8192, 12:16384, 13:32768 */
	case     0: conf[i][j].cdw0.mexlimit = 0; break;
	case     8: conf[i][j].cdw0.mexlimit = 1; break;
	case    16: conf[i][j].cdw0.mexlimit = 2; break;
	case    32: conf[i][j].cdw0.mexlimit = 3; break;
	case    64: conf[i][j].cdw0.mexlimit = 4; break;
	case   128: conf[i][j].cdw0.mexlimit = 5; break;
	case   256: conf[i][j].cdw0.mexlimit = 6; break;
	case   512: conf[i][j].cdw0.mexlimit = 7; break;
	case  1024: conf[i][j].cdw0.mexlimit = 8; break;
	case  2048: conf[i][j].cdw0.mexlimit = 9; break;
	case  4096: conf[i][j].cdw0.mexlimit =10; break;
	case  8192: conf[i][j].cdw0.mexlimit =11; break;
	case 16384: conf[i][j].cdw0.mexlimit =12; break;
	case 32768: conf[i][j].cdw0.mexlimit =13; break;
	case 65536: conf[i][j].cdw0.mexlimit =14; break;
	default:    conf[i][j].cdw0.mexlimit =15; break;
	}
      }
      /* mex0.mexdh and mop0.mopdh */
      if (dec[i][j].dmex.op0 && dec[i][j].dmex.mexd0h == dec[i][j].dmop0.baseh) {
	printf("[%d][%d] detected dmex0.dst==mop0.base.", i, j);
	                    dec[i][j].dmop0.updt  = 1;
	regv[i][j].ea0b_v = dec[i][j].dmop0.basev = dec[i][j].dmex.adr1v; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea0b_h = dec[i][j].dmop0.baseh = dec[i][j].dmex.adr1h; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea0b_s = dec[i][j].dmop0.bases = dec[i][j].dmex.adr1s; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
	printf(" mop0 renamed from %s to %s\n", id[dec[i][j].dmex.mexd0h].name, id[dec[i][j].dmop0.baseh].name);
      }

      /* ea[bo] depends on busmap[i][j].br[prev][] and decode[i][j].dmop.ex[123] */
      /* mapdist=0の場合,dmop0.op=OP_IM_PREFの可能性あり,比較対象外 */
      conf[i][j].cdw1.ea0op  = dec[i][j].dmop0.op;
      conf[i][j].cdw1.ea0bs  = ((!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0brv?0:2)|(dec[i][j].dmop0.updt?1:0); /* 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
      conf[i][j].cdw1.ea0os  = ( !dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0orv?0:1; /* 0:ea0or, 1:eaobrs */
      conf[i][j].cdw1.ea0msk = dec[i][j].dmop0.offsm;

      /* mex1/mop1 */
      conf[i][j].cdw0.mex1op   = dec[i][j].dmex.op1;
      conf[i][j].cdw0.mex1init = dec[i][j].dmex.init;
      switch (id[dec[i][j].dmex.dist2h].val) { /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
      case  0: conf[i][j].cdw0.mex1dist = 0; break;
      case  1: conf[i][j].cdw0.mex1dist = 1; break;
      case  2: conf[i][j].cdw0.mex1dist = 2; break;
      case  4: conf[i][j].cdw0.mex1dist = 3; break;
      case  8: conf[i][j].cdw0.mex1dist = 4; break;
      case 16: conf[i][j].cdw0.mex1dist = 5; break;
      case 32: conf[i][j].cdw0.mex1dist = 6; break;
      default: conf[i][j].cdw0.mex1dist = 7; break;
      }
      if (dec[i][j].dmex.op1) {
	switch (id[dec[i][j].dmex.limith].val) { /* limit 0:0, 1:8, 2:16, .... 10:4096, 11:8192, 12:16384, 13:32768 */
	case     0: conf[i][j].cdw0.mexlimit = 0; break;
	case     8: conf[i][j].cdw0.mexlimit = 1; break;
	case    16: conf[i][j].cdw0.mexlimit = 2; break;
	case    32: conf[i][j].cdw0.mexlimit = 3; break;
	case    64: conf[i][j].cdw0.mexlimit = 4; break;
	case   128: conf[i][j].cdw0.mexlimit = 5; break;
	case   256: conf[i][j].cdw0.mexlimit = 6; break;
	case   512: conf[i][j].cdw0.mexlimit = 7; break;
	case  1024: conf[i][j].cdw0.mexlimit = 8; break;
	case  2048: conf[i][j].cdw0.mexlimit = 9; break;
	case  4096: conf[i][j].cdw0.mexlimit =10; break;
	case  8192: conf[i][j].cdw0.mexlimit =11; break;
	case 16384: conf[i][j].cdw0.mexlimit =12; break;
	case 32768: conf[i][j].cdw0.mexlimit =13; break;
	case 65536: conf[i][j].cdw0.mexlimit =14; break;
	default:    conf[i][j].cdw0.mexlimit =15; break;
	}
      }
      /* mex1.mexdh and mop1.mopdh */
      if (dec[i][j].dmex.op1 && dec[i][j].dmex.mexd1h == dec[i][j].dmop1.baseh) {
	printf("[%d][%d] detected dmex1.dst==mop1.base.", i, j);
	                    dec[i][j].dmop1.updt  = 1;
	regv[i][j].ea1b_v = dec[i][j].dmop1.basev = dec[i][j].dmex.adr3v; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea1b_h = dec[i][j].dmop1.baseh = dec[i][j].dmex.adr3h; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea1b_s = dec[i][j].dmop1.bases = dec[i][j].dmex.adr3s; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
	printf(" mop1 renamed from %s to %s\n", id[dec[i][j].dmex.mexd1h].name, id[dec[i][j].dmop1.baseh].name);
      }

      /* ea[bo] depends on busmap[i][j].br[prev][] and decode[i][j].dmop.ex[123] */
      /* mapdist=0の場合,dmop1.op=OP_IM_DRAINの可能性あり,比較対象外 */
      if (dec[i][j].dmop0.op == OP_LDDMQ || dec[i][j].dmop0.op == OP_TR)
        conf[i][j].cdw1.ea1op = dec[i][j].dmop0.op;
      else
        conf[i][j].cdw1.ea1op = dec[i][j].dmop1.op;
      conf[i][j].cdw1.ea1bs  = ((!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1brv?0:2)|(dec[i][j].dmop1.updt?1:0); /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
      conf[i][j].cdw1.ea1os  = ( !dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1orv?0:1; /* 0:ea1or, 1:eaobrs */
      conf[i][j].cdw1.ea1msk = dec[i][j].dmop1.offsm;

      //printf("conf[%d][%d]: mex0=%d.%d.%d mex1=%d.%d.%d\n", i, j, conf[i][j].cdw0.mex0op, conf[i][j].cdw0.mex0init, conf[i][j].cdw0.mex0dist, conf[i][j].cdw0.mex1op, conf[i][j].cdw0.mex1init, conf[i][j].cdw0.mex1dist);

      if (conf[i][j].cdw1.ea0bs&2) /* find source of eabbrs */
        ea0rs = search_prev_br0(i, dec[i][j].dexu.fold, dec[i][j].dmop0.basev, dec[i][j].dmop0.baseh, dec[i][j].dmop0.bases);
      else
        ea0rs = -1;
      if (conf[i][j].cdw1.ea1bs&2) /* find source of eabbrs */
        ea1rs = search_prev_br0(i, 0, dec[i][j].dmop1.basev, dec[i][j].dmop1.baseh, dec[i][j].dmop1.bases);
      else
        ea1rs = -1;
      if ((conf[i][j].cdw1.ea0bs&2) && (conf[i][j].cdw1.ea1bs&2)) { /* eabbrs is shared */
        /* check conflict */
        if (ea0rs != ea1rs) { /* conflict */
          printf("in %s: [%d][%d] dmop1.base(%s.%d) and dmop0.base(%s.%d) conflict\n", id[current_prefix].name, i, j, id[dec[i][j].dmop1.baseh].name, ea1rs, id[dec[i][j].dmop0.baseh].name, ea0rs);
          exit(1);
        }
        conf[i][j].cdw1.eabbrs = ea0rs; /* dmop0.base takes eabbrs */
      }
      else if (conf[i][j].cdw1.ea0bs&2)
        conf[i][j].cdw1.eabbrs = ea0rs; /* dmop0.base takes eabbrs */
      else if (conf[i][j].cdw1.ea1bs&2)
        conf[i][j].cdw1.eabbrs = ea1rs; /* dmop1.base takes eabbrs */
      else
        conf[i][j].cdw1.eabbrs = 0; /* not used */
      if (conf[i][j].cdw1.ea0os)
        ea0rs = search_prev_br0(i, dec[i][j].dexu.fold, dec[i][j].dmop0.offsv, dec[i][j].dmop0.offsh, dec[i][j].dmop0.offss);
      if (conf[i][j].cdw1.ea1os)
        ea1rs = search_prev_br0(i, 0, dec[i][j].dmop1.offsv, dec[i][j].dmop1.offsh, dec[i][j].dmop1.offss);
      if (conf[i][j].cdw1.ea0os && conf[i][j].cdw1.ea1os) { /* eaobrs is selected */
        /* check conflict */
        if (ea0rs != ea1rs) { /* conflict */
          printf("in %s: [%d][%d] dmop1.offs(%s.%d) and dmop0.offs(%s.%d) conflict\n", id[current_prefix].name, i, j, id[dec[i][j].dmop1.offsh].name, ea1rs, id[dec[i][j].dmop0.offsh].name, ea0rs);
          exit(1);
        }
        conf[i][j].cdw1.eaobrs = ea0rs; /* dmop0.offs takes eaobrs */
      }
      else if (conf[i][j].cdw1.ea0os)
        conf[i][j].cdw1.eaobrs = ea0rs; /* dmop0.offs takes eaobrs */
      else if (conf[i][j].cdw1.ea1os)
        conf[i][j].cdw1.eaobrs = ea1rs; /* dmop1.offs takes eaobrs */
      else
        conf[i][j].cdw1.eaobrs = 0; /* not used */
    }
  }
  /**********************************************************************************************************/
  /* Step 3 ... setup conf[][]                                                                              */
  /* 3-1. select MW-in                                                                                      */
  /* 3-2. select BR-in                                                                                      */
  /* 3-3. set mapdist                                                                                       */
  /**********************************************************************************************************/
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      /* 3-1 */
      /* tr[0],mw[0] */
      /* AR->TRのパスがあればEX4結果伝搬用 */
      /* BR->TRのパスがあれば伝搬用 */
      if (bus[i][j].tr[0].v) { /* tr[0] active */
        if ((k = search_prev_ar0_tr(i, j, 0, bus[i][j].tr[0].v, bus[i][j].tr[0].h, bus[i][j].tr[0].s)) >= 0) {
          conf[i][j].cdw2.trs0 = k;
        }
        else {
          k = search_prev_br0(i, 0, bus[i][j].tr[0].v, bus[i][j].tr[0].h, bus[i][j].tr[0].s);
          conf[i][j].cdw2.ts0  = k;
          conf[i][j].cdw2.trs0 = 2; /* ts0 */
        }
      }
      /* AR->MWのパスがあればset */
      /* BR->MWのパスがあればset */
      /* LMWD->MWのパスがあればset */
      if (bus[i][j].mw[0].v) { /* mw[0] active */
        if ((k = search_prev_ar0_mw(i, j, 0, bus[i][j].mw[0].v, bus[i][j].mw[0].h, bus[i][j].mw[0].s)) >= 0) {
          conf[i][j].cdw2.mws0 = k;
        }
        else {
          k = search_prev_br0(i, dec[i][j].dexu.fold, bus[i][j].mw[0].v, bus[i][j].mw[0].h, bus[i][j].mw[0].s);
          conf[i][j].cdw2.ts0  = k;
          conf[i][j].cdw2.mws0 = 2; /* ts0 */
        }
      }
      /* mws0... 0:lmwd0, 1:exdr, 2:ts0 */
      /* mwsa... 0:lmwa,  1:ea0d *//* for STATUS_EXEC+lmp */
      switch (conf[i][j].cdw2.mws0) {
      case 0: conf[i][j].cdw2.mwsa = 0; break;
      default:conf[i][j].cdw2.mwsa = 1; break;
      }

      /* tr[1],mw[1] */
      if (bus[i][j].tr[1].v) { /* tr[1] active */
        if ((k = search_prev_ar0_tr(i, j, 1, bus[i][j].tr[1].v, bus[i][j].tr[1].h, bus[i][j].tr[1].s)) >= 0) {
          conf[i][j].cdw2.trs1 = k;
        }
        else {
          k = search_prev_br0(i, 0, bus[i][j].tr[1].v, bus[i][j].tr[1].h, bus[i][j].tr[1].s);
          conf[i][j].cdw2.ts1  = k;
          conf[i][j].cdw2.trs1 = 2; /* ts1 */
        }
      }
      if (bus[i][j].mw[1].v) { /* mw[1] active */
        if ((k = search_prev_ar0_mw(i, j, 1, bus[i][j].mw[1].v, bus[i][j].mw[1].h, bus[i][j].mw[1].s)) >= 0) {
          conf[i][j].cdw2.mws1 = k;
        }
        else {
          k = search_prev_br0(i, dec[i][j].dexu.fold, bus[i][j].mw[1].v, bus[i][j].mw[1].h, bus[i][j].mw[1].s);
          conf[i][j].cdw2.ts1  = k;
          conf[i][j].cdw2.mws1 = 2; /* ts1 */
        }
      }

      /* tr[2],mw[2] */
      if (bus[i][j].tr[2].v) { /* tr[2] active */
        if ((k = search_prev_ar0_tr(i, j, 2, bus[i][j].tr[2].v, bus[i][j].tr[2].h, bus[i][j].tr[2].s)) >= 0) {
          conf[i][j].cdw2.trs2 = k;
        }
        else {
          k = search_prev_br0(i, 0, bus[i][j].tr[2].v, bus[i][j].tr[2].h, bus[i][j].tr[2].s);
          conf[i][j].cdw2.ts2  = k;
          conf[i][j].cdw2.trs2 = 2; /* ts2 */
        }
      }
      if (bus[i][j].mw[2].v) { /* mw[2] active */
        if ((k = search_prev_ar0_mw(i, j, 2, bus[i][j].mw[2].v, bus[i][j].mw[2].h, bus[i][j].mw[2].s)) >= 0) {
          conf[i][j].cdw2.mws2 = k;
        }
        else {
          k = search_prev_br0(i, dec[i][j].dexu.fold, bus[i][j].mw[2].v, bus[i][j].mw[2].h, bus[i][j].mw[2].s);
          conf[i][j].cdw2.ts2  = k;
          conf[i][j].cdw2.mws2 = 2; /* ts2 */
        }
      }

      /* tr[3],mw[3] */
      if (bus[i][j].tr[3].v) { /* tr[3] active */
        if ((k = search_prev_ar0_tr(i, j, 3, bus[i][j].tr[3].v, bus[i][j].tr[3].h, bus[i][j].tr[3].s)) >= 0) {
          conf[i][j].cdw2.trs3 = k;
        }
        else {
          k = search_prev_br0(i, 0, bus[i][j].tr[3].v, bus[i][j].tr[3].h, bus[i][j].tr[3].s);
          conf[i][j].cdw2.ts3  = k;
          conf[i][j].cdw2.trs3 = 2; /* ts3 */
        }
      }
      if (bus[i][j].mw[3].v) { /* mw[3] active */
        if ((k = search_prev_ar0_mw(i, j, 3, bus[i][j].mw[3].v, bus[i][j].mw[3].h, bus[i][j].mw[3].s)) >= 0) {
          conf[i][j].cdw2.mws3 = k;
        }
        else {
          k = search_prev_br0(i, dec[i][j].dexu.fold, bus[i][j].mw[3].v, bus[i][j].mw[3].h, bus[i][j].mw[3].s);
          conf[i][j].cdw2.ts3  = k;
          conf[i][j].cdw2.mws3 = 2; /* ts3 */
        }
      }

      /* 3-2 */
      /* conf[i][j].cdw2.brs0; *//* set with bus.tr[]/br[] */
      /* conf[i][j].cdw2.brs1; *//* set with bus.tr[]/br[] */
      /* conf[i][j].cdw2.brs2; *//* set with bus.tr[]/br[] */
      /* conf[i][j].cdw2.brs3; *//* set with bus.tr[]/br[] */
      /* exdr is connected by default (brs=0) */

      /* 3-3 */
      conf[i][j].cdw2.mapdist = current_mapdist;
    }
  }
  /**********************************************************************************************************/
  /* Step 4 ... Insert LMM-buffering for neighbor LDDMQ                                                     */
  /*            Multiple LDDMQ in the same row is not allowed                                               */
  /**********************************************************************************************************/
  for (i=0; i<EMAX_DEPTH; i++) {
    /* checking LDDMQ */
    int lddmq_loc = -1;
    for (j=0; j<EMAX_WIDTH; j++) {
      if (conf[i][j].cdw1.ea0op == OP_LDDMQ) {
        lddmq_loc = j;
        break;
      }
    }
    if (lddmq_loc < 0)
      continue;
    for (j=0; j<EMAX_WIDTH; j++) {
      if (j == lddmq_loc)
        continue;
      /* LMM-buffering replacement */
      if (conf[i][j].cdw2.brs0 || conf[i][j].cdw2.brs1 || conf[i][j].cdw2.brs2 || conf[i][j].cdw2.brs3) {
        if (conf[i][j].cdw1.ea0op || conf[i][j].cdw1.ea1op) { /* error if EAGs are occupied */
          printf("in %s: [%d][%d] cannot remap BR-buffering for neighbor lddmq (ea0op=%d ea1op=%d\n",
                 id[current_prefix].name, i, j, conf[i][j].cdw1.ea0op, conf[i][j].cdw1.ea1op);
          exit(1);
        }
        /* setup LMM as FIFO */
	conf[i][j].cdw2.lmm_mode = 3;
        conf[i][j].cdw1.ea0op  = OP_IM_BUFWR;
        conf[i][j].cdw1.ea0bs  = 1; /* ea0br+self-loop */
        conf[i][j].cdw1.ea0os  = 0; /* ea0or           */
        conf[i][j].cdw1.ea0msk = 15;/* 64bit           */
        conf[i][j].cdw1.ea1op  = OP_IM_BUFRD;
        conf[i][j].cdw1.ea1bs  = 1; /* ea1br+self-loop */
        conf[i][j].cdw1.ea1os  = 0; /* ea1or           */
        conf[i][j].cdw1.ea1msk = 15;/* 64bit           */
        conf[i][j].cdw1.eabbrs = 0; /* not used */
        conf[i][j].cdw1.eaobrs = 0; /* not used */
        regv[i][j].ea0b_v = T_IMMEDIATE;
        regv[i][j].ea0b_h = hash_reg_immediate(0LL);
        regv[i][j].ea0b_s = -1;
        regv[i][j].ea0o_v = T_IMMEDIATE;
        regv[i][j].ea0o_h = hash_reg_immediate(32LL);
        regv[i][j].ea0o_s = -1;
        regv[i][j].ea1b_v = T_IMMEDIATE;
        regv[i][j].ea1b_h = hash_reg_immediate(0LL);
        regv[i][j].ea1b_s = -1;
        regv[i][j].ea1o_v = T_IMMEDIATE;
        regv[i][j].ea1o_h = hash_reg_immediate(32LL);
        regv[i][j].ea1o_s = -1;

        /* ts0-3は維持 */
        /* brs0-3がTRかEXDRであることを確認し,mws0-3に反映 */
        /* brs0-3をmr10-13に切替え */
        printf("Lmm-buffering is inserted in conf[%d][%d]", i, j);
        switch (conf[i][j].cdw2.brs3) {
        case 2: conf[i][j].cdw2.mws3 = 2; conf[i][j].cdw2.brs3 = 1; printf(".t3"); break; /* tr3: ts3->mw3->mr13 */
        default:                          conf[i][j].cdw2.brs3 = 0; break; /* off */
        }
        switch (conf[i][j].cdw2.brs2) {
        case 2: conf[i][j].cdw2.mws2 = 2; conf[i][j].cdw2.brs2 = 1; printf(".t2"); break; /* tr2: ts2->mw2->mr12 */
        case 3: conf[i][j].cdw2.mws2 = 0; conf[i][j].cdw2.brs2 = 1; printf(".ex"); break; /* exd: exd->mw2->mr12 */
        default:                          conf[i][j].cdw2.brs2 = 0; break; /* off */
        }
        switch (conf[i][j].cdw2.brs1) {
        case 2: conf[i][j].cdw2.mws1 = 2; conf[i][j].cdw2.brs1 = 1; printf(".t1"); break; /* tr1: ts1->mw1->mr11 */
        default:                          conf[i][j].cdw2.brs1 = 0; break; /* off */
        }
        switch (conf[i][j].cdw2.brs0) {
        case 2: conf[i][j].cdw2.mws0 = 2; conf[i][j].cdw2.brs0 = 1; printf(".t0"); break; /* tr0: ts0->mw0->mr10 */
        default:                          conf[i][j].cdw2.brs0 = 0; break; /* off */
        }
        printf(" for [%d][%d].lddmq\n", i, lddmq_loc);
      }
    }
    /**/
  }
  /**********************************************************************************************************/
  /* Step 5 ... Merge LMM                                                                                   */
  /**********************************************************************************************************/
  /* merge lmmi pass1                                                                                       */
  /*  -.                            LDDMQがある場合,LMM-bufferingも存在 ... 必ずlmm_mode=3とする            */
  /*                                  並置IM-BUFFはよいとして                                               */
  /*                                  並置IM_PREFがlmm_mode=3であれば,前段LDRもlmm_mode=3が必要             */
  /*                                  つまり単独LDRをmode=0に拡張できるかは対応IM_PREF依存                  */
  /*  -.                            TRANSがある場合,隣接LMMは未使用     ... lmm_mode=0にできる              */
  /*  -.                            IM_PREF とRLOADは,セットで同じlmm_modeでなければならない                */
  /*  -.                            IM_DRAINとRSTOREはセットで同じlmm_modeでなければならない                */
  /*                                                                                                        */
  /* lmp/lmdの場合,ptop情報を使ってlmwd/lmrdに識別子がセットされている                                      */
  /* 水平方向に比較し,重複lmwdをマージする.                                                                 */
  /* LMM使用命令   (RLOAD,RSTORE,LDDMQ,TRANS) はFSMとのインタラクションがあるのでlmmi.v=1                   */
  /* LMM-buffering (conf.ea0op=OP_IM_BUFWR)   はFSMとのインタラクションがないのでlmmi.v=0                   */
  /*      col#3 col#2 col#1 col#0                                                                           */
  /* 5-0.                           imm_modeの初期値は,OP_IM_BUFRD/WRを含めて3                              */
  /* 5-0.                           stage毎にcolumn間(3-2,1-0)を検査し,上記機能の干渉に応じて               */
  /* 5-0.                           lmmを集約し,あとでIM_PREF/DRAINと整合させる                             */
  /* 5-1.           mode=0 | mode=0 1-0を検査し,#1/#0空  #0.mode=2/#1.mode=2(merge)                         */
  /* 5-1.                  =        1-0を検査し,同一なら #1.mode=2&#0.mode=2(merge)                         */
  /* 5-1.                 !=        1-0を検査し,その他   #1.mode=3,#0.mode=3                                */
  /* 5-2. mode=0 | mode=0           3-2を検査し,#3/#2空  #2.mode=2/#3.mode=2(merge)                         */
  /* 5-2.        =                  3-2を検査し,同一なら #3.mode=2&#2.mode=2(merge)                         */
  /* 5-2.       !=                  3-2を検査し,その他   #3.mode=3,#2.mode=3                                */
  /* 5-3.   mode=0,0 | mode=0,0     (3-2)と(1-0)を検査し,#2.mode=2/#0.mode=2&空有なら,mode=1(merge)         */
  /* 5-3.     mode=2 = mode=2       (3-2)と(1-0)を検査し,#2.mode=2&#0.mode=2&同一なら,mode=1(merge)         */
  /* 5-3.           !=              (3-2)と(1-0)を検査し,その他,                      そのまま              */
  /* 5-4.                           mapdist!=0とmop=IM_PREF/DRAINの検出により対応IMの調整が可能             */
  /*                                一通りmode拡張後,最後に,幅の狭いほうにあわせて再分割する                */
  for (i=0; i<EMAX_DEPTH; i++) {
    /* 5-1 */
    if (conf[i][1].cdw2.lmm_mode == 0 && conf[i][0].cdw2.lmm_mode == 0) { /* 0 0 */
      /* do nothing */
    }
    else if (conf[i][0].cdw2.lmm_mode == 0) /* 3 0 -> 2 0 */
      conf[i][1].cdw2.lmm_mode = 2; /* merge */
    else if (conf[i][1].cdw2.lmm_mode == 0) /* 0 3 -> 0 2 */
      conf[i][0].cdw2.lmm_mode = 2; /* merge */
    else if (lmmi[i][1].v     && lmmi[i][0].v
        /*&& lmmi[i][1].rw    == lmmi[i][0].rw*/
	  && lmmi[i][1].f     == lmmi[i][0].f
	  && lmmi[i][1].p     == lmmi[i][0].p
	  && lmmi[i][1].blk   == lmmi[i][0].blk
	  && lmmi[i][1].len   == lmmi[i][0].len
          && lmmi[i][1].top   == lmmi[i][0].top) { /* 3 3 -> 2 2 */
      conf[i][0].cdw2.lmm_mode = 2; /* merge */
      conf[i][1].cdw2.lmm_mode = 2; /* merge */
      lmmi[i][0].bcas |= (1<<1);    /* 1<-0 */
      lmmi[i][1].hcopy = 1;         /* mark as copy */
    }
    else { /* 3 3 */
      /* do nothing */
    }
    /* 5-2 */
    if (conf[i][3].cdw2.lmm_mode == 0 && conf[i][2].cdw2.lmm_mode == 0) { /* 0 0 */
      /* do nothing */
    }
    else if (conf[i][2].cdw2.lmm_mode == 0) /* 3 0 -> 2 0 */
      conf[i][3].cdw2.lmm_mode = 2; /* merge */
    else if (conf[i][3].cdw2.lmm_mode == 0) /* 0 3 -> 0 2 */
      conf[i][2].cdw2.lmm_mode = 2; /* merge */
    else if (lmmi[i][3].v     && lmmi[i][2].v
	/*&& lmmi[i][3].rw    == lmmi[i][2].rw*/
	  && lmmi[i][3].f     == lmmi[i][2].f
	  && lmmi[i][3].p     == lmmi[i][2].p
	  && lmmi[i][3].blk   == lmmi[i][2].blk
	  && lmmi[i][3].len   == lmmi[i][2].len
          && lmmi[i][3].top   == lmmi[i][2].top) { /* 3 3 -> 2 2 */
      conf[i][2].cdw2.lmm_mode = 2; /* merge */
      conf[i][3].cdw2.lmm_mode = 2; /* merge */
      lmmi[i][2].bcas |= (1<<3);    /* 3<-2 */
      lmmi[i][3].hcopy = 1;         /* mark as copy */
    }
    else { /* 3 3 */
      /* do nothing */
    }
    /* 5-3 */
    if (conf[i][3].cdw2.lmm_mode == 0 && conf[i][2].cdw2.lmm_mode == 0
     && conf[i][1].cdw2.lmm_mode == 0 && conf[i][0].cdw2.lmm_mode == 0) { /* 0 0 0 0 */
      /* do nothing */
    }
    else if (conf[i][3].cdw2.lmm_mode == 0 && conf[i][2].cdw2.lmm_mode == 0) { /* 0 0 - - */
      if (conf[i][1].cdw2.lmm_mode == 2 && conf[i][0].cdw2.lmm_mode == 2) { /* 0 0 2 2 */
	conf[i][0].cdw2.lmm_mode = 1; /* merge */
	conf[i][1].cdw2.lmm_mode = 1; /* merge */
      }
      else if (conf[i][0].cdw2.lmm_mode == 2) /* 0 0 0 2 */
	conf[i][0].cdw2.lmm_mode = 1; /* merge */
      else if (conf[i][1].cdw2.lmm_mode == 2) /* 0 0 2 0 */
	conf[i][1].cdw2.lmm_mode = 1; /* merge */
    }
    else if (conf[i][1].cdw2.lmm_mode == 0 && conf[i][0].cdw2.lmm_mode == 0) { /* - - 0 0 */
      if (conf[i][3].cdw2.lmm_mode == 2 && conf[i][2].cdw2.lmm_mode == 2) { /* 2 2 0 0 */
	conf[i][2].cdw2.lmm_mode = 1; /* merge */
	conf[i][3].cdw2.lmm_mode = 1; /* merge */
      }
      else if (conf[i][2].cdw2.lmm_mode == 2) /* 0 2 0 0 */
	conf[i][2].cdw2.lmm_mode = 1; /* merge */
      else if (conf[i][3].cdw2.lmm_mode == 2) /* 2 0 0 0 */
	conf[i][3].cdw2.lmm_mode = 1; /* merge */
    }
    else if (conf[i][1].cdw2.lmm_mode == 2 && conf[i][0].cdw2.lmm_mode == 2) { /* 0/2/3 0/2/3 2 2 */
      if (conf[i][2].cdw2.lmm_mode == 2) { /* 0/2 2 2 2 */
	if (lmmi[i][2].v     && lmmi[i][0].v
       /*&& lmmi[i][2].rw    == lmmi[i][0].rw*/
         && lmmi[i][2].f     == lmmi[i][0].f
         && lmmi[i][2].p     == lmmi[i][0].p
         && lmmi[i][2].blk   == lmmi[i][0].blk
         && lmmi[i][2].len   == lmmi[i][0].len
         && lmmi[i][2].top   == lmmi[i][0].top) {
	  conf[i][0].cdw2.lmm_mode = 1; /* merge */
	  conf[i][1].cdw2.lmm_mode = 1; /* merge */
	  conf[i][2].cdw2.lmm_mode = 1; /* merge */
	  lmmi[i][0].bcas |= (1<<2);    /* 2<-0 */
	  lmmi[i][2].bcas = 0;          /* reset bcas */
	  lmmi[i][2].hcopy = 1;         /* mark as copy */
	}
      }
      if (conf[i][3].cdw2.lmm_mode == 2) { /* 2 0/2 2 2 */
	if (lmmi[i][3].v     && lmmi[i][0].v
       /*&& lmmi[i][3].rw    == lmmi[i][0].rw*/
         && lmmi[i][3].f     == lmmi[i][0].f
         && lmmi[i][3].p     == lmmi[i][0].p
         && lmmi[i][3].blk   == lmmi[i][0].blk
         && lmmi[i][3].len   == lmmi[i][0].len
         && lmmi[i][3].top   == lmmi[i][0].top) {
	  conf[i][0].cdw2.lmm_mode = 1; /* merge */
	  conf[i][1].cdw2.lmm_mode = 1; /* merge */
	  conf[i][3].cdw2.lmm_mode = 1; /* merge */
	  lmmi[i][0].bcas |= (1<<3);    /* 3<-0 */
	  lmmi[i][3].bcas = 0;          /* reset bcas */
	  lmmi[i][3].hcopy = 1;         /* mark as copy */
	}
      }
    }
    else if (conf[i][0].cdw2.lmm_mode == 2) { /* 0/2/3 0/2/3 0 2 */
      if (conf[i][2].cdw2.lmm_mode == 2) { /* 0/2 2 0 2 */
	if (lmmi[i][2].v     && lmmi[i][0].v
       /*&& lmmi[i][2].rw    == lmmi[i][0].rw*/
         && lmmi[i][2].f     == lmmi[i][0].f
         && lmmi[i][2].p     == lmmi[i][0].p
         && lmmi[i][2].blk   == lmmi[i][0].blk
         && lmmi[i][2].len   == lmmi[i][0].len
         && lmmi[i][2].top   == lmmi[i][0].top) {
	  conf[i][0].cdw2.lmm_mode = 1; /* merge */
	  conf[i][2].cdw2.lmm_mode = 1; /* merge */
	  lmmi[i][0].bcas |= (1<<2);    /* 2<-0 */
	  lmmi[i][2].bcas = 0;          /* reset bcas */
	  lmmi[i][2].hcopy = 1;         /* mark as copy */
	}
      }
      if (conf[i][3].cdw2.lmm_mode == 2) { /* 2 0/2 0 2 */
	if (lmmi[i][3].v     && lmmi[i][0].v
       /*&& lmmi[i][3].rw    == lmmi[i][0].rw*/
         && lmmi[i][3].f     == lmmi[i][0].f
         && lmmi[i][3].p     == lmmi[i][0].p
         && lmmi[i][3].blk   == lmmi[i][0].blk
         && lmmi[i][3].len   == lmmi[i][0].len
         && lmmi[i][3].top   == lmmi[i][0].top) {
	  conf[i][0].cdw2.lmm_mode = 1; /* merge */
	  conf[i][3].cdw2.lmm_mode = 1; /* merge */
	  lmmi[i][0].bcas |= (1<<3);    /* 3<-0 */
	  lmmi[i][3].bcas = 0;          /* reset bcas */
	  lmmi[i][3].hcopy = 1;         /* mark as copy */
	}
      }
    }
    else if (conf[i][1].cdw2.lmm_mode == 2) { /* 0/2/3 0/2/3 2 0 */
      if (conf[i][2].cdw2.lmm_mode == 2) { /* 0/2 2 2 0 */
	if (lmmi[i][2].v     && lmmi[i][1].v
       /*&& lmmi[i][2].rw    == lmmi[i][1].rw*/
         && lmmi[i][2].f     == lmmi[i][1].f
         && lmmi[i][2].p     == lmmi[i][1].p
         && lmmi[i][2].blk   == lmmi[i][1].blk
         && lmmi[i][2].len   == lmmi[i][1].len
         && lmmi[i][2].top   == lmmi[i][1].top) {
	  conf[i][1].cdw2.lmm_mode = 1; /* merge */
	  conf[i][2].cdw2.lmm_mode = 1; /* merge */
	  lmmi[i][1].bcas |= (1<<2);    /* 2<-0 */
	  lmmi[i][2].bcas = 0;          /* reset bcas */
	  lmmi[i][2].hcopy = 1;         /* mark as copy */
	}
      }
      if (conf[i][3].cdw2.lmm_mode == 2) { /* 2 0/2 2 0 */
	if (lmmi[i][3].v     && lmmi[i][1].v
       /*&& lmmi[i][3].rw    == lmmi[i][1].rw*/
         && lmmi[i][3].f     == lmmi[i][1].f
         && lmmi[i][3].p     == lmmi[i][1].p
         && lmmi[i][3].blk   == lmmi[i][1].blk
         && lmmi[i][3].len   == lmmi[i][1].len
         && lmmi[i][3].top   == lmmi[i][1].top) {
	  conf[i][1].cdw2.lmm_mode = 1; /* merge */
	  conf[i][3].cdw2.lmm_mode = 1; /* merge */
	  lmmi[i][1].bcas |= (1<<3);    /* 3<-0 */
	  lmmi[i][3].bcas = 0;          /* reset bcas */
	  lmmi[i][3].hcopy = 1;         /* mark as copy */
	}
      }
    }
  }
  /* 5-4 */
  if (current_mapdist > 0) {
    for (i=0; i<EMAX_DEPTH; i++) {
      /* column-0 */
      if ((lmmi[i                ][0].v && lmmi[i                ][0].rw==0 && !lmmi[i                ][0].f && !lmmi[i                ][0].p
        && lmmi[i+current_mapdist][0].v && lmmi[i+current_mapdist][0].rw==0 && !lmmi[i+current_mapdist][0].f &&  lmmi[i+current_mapdist][0].p)    /* c+dist:lmp */
       || (lmmi[i                ][0].v && lmmi[i                ][0].rw==1 && !lmmi[i                ][0].f &&  lmmi[i                ][0].p  
        && lmmi[i+current_mapdist][0].v && lmmi[i+current_mapdist][0].rw==1 && !lmmi[i+current_mapdist][0].f && !lmmi[i+current_mapdist][0].p)) { /* c-dist:lmd */
	if      (conf[i][0].cdw2.lmm_mode < conf[i+current_mapdist][0].cdw2.lmm_mode) { /* [i]の集約を[i+c]に合わせて戻す */
	  if      (conf[i][0].cdw2.lmm_mode==1 && conf[i+current_mapdist][0].cdw2.lmm_mode==2) { /* -- -- 0/1 1 | -- -- 0/2 2 */
	    conf[i][0].cdw2.lmm_mode = 2;   /* split */
	    if (conf[i][1].cdw2.lmm_mode == 1)
	      conf[i][1].cdw2.lmm_mode = 2; /* split */
	    if (conf[i][3].cdw2.lmm_mode || conf[i][2].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=1,2\n", id[current_prefix].name, i, 0, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][0].cdw2.lmm_mode==1 && conf[i+current_mapdist][0].cdw2.lmm_mode==3) { /* -- -- --  1 | -- -- --  3 */
	    conf[i][0].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i][3].cdw2.lmm_mode || conf[i][2].cdw2.lmm_mode || conf[i][1].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=1,3\n", id[current_prefix].name, i, 0, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][0].cdw2.lmm_mode==2 && conf[i+current_mapdist][0].cdw2.lmm_mode==3) { /* -- -- --  2 | -- -- --  3 */
	    conf[i][0].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i][1].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=2,3\n", id[current_prefix].name, i, 0, current_mapdist);
	      exit(1);
	    }
	  }
	}
	else if (conf[i][0].cdw2.lmm_mode > conf[i+current_mapdist][0].cdw2.lmm_mode) { /* [i+c]の集約を[i]に合わせて戻す */
	  if      (conf[i][0].cdw2.lmm_mode==2 && conf[i+current_mapdist][0].cdw2.lmm_mode==1) { /* -- -- 0/2 2 | -- -- 0/1 1 */
	    conf[i+current_mapdist][0].cdw2.lmm_mode = 2;   /* split */
	    if (conf[i+current_mapdist][1].cdw2.lmm_mode == 1)
	      conf[i+current_mapdist][1].cdw2.lmm_mode = 2; /* split */
	    if (conf[i+current_mapdist][3].cdw2.lmm_mode || conf[i+current_mapdist][2].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=2,1\n", id[current_prefix].name, i, 0, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][0].cdw2.lmm_mode==3 && conf[i+current_mapdist][0].cdw2.lmm_mode==1) { /* -- -- --  3 | -- -- --  1 */
	    conf[i+current_mapdist][0].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i+current_mapdist][3].cdw2.lmm_mode || conf[i+current_mapdist][2].cdw2.lmm_mode || conf[i+current_mapdist][1].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=3,1\n", id[current_prefix].name, i, 0, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][0].cdw2.lmm_mode==3 && conf[i+current_mapdist][0].cdw2.lmm_mode==2) { /* -- -- --  3 | -- -- --  2 */
	    conf[i+current_mapdist][0].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i+current_mapdist][1].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=3,2\n", id[current_prefix].name, i, 0, current_mapdist);
	      exit(1);
	    }
	  }
	}
      }
      /* column-1 */
      if ((lmmi[i                ][1].v && lmmi[i                ][1].rw==0 && !lmmi[i                ][1].f && !lmmi[i                ][1].p
        && lmmi[i+current_mapdist][1].v && lmmi[i+current_mapdist][1].rw==0 && !lmmi[i+current_mapdist][1].f &&  lmmi[i+current_mapdist][1].p)    /* c+dist:lmp */
       || (lmmi[i                ][1].v && lmmi[i                ][1].rw==1 && !lmmi[i                ][1].f &&  lmmi[i                ][1].p  
        && lmmi[i+current_mapdist][1].v && lmmi[i+current_mapdist][1].rw==1 && !lmmi[i+current_mapdist][1].f && !lmmi[i+current_mapdist][1].p)) { /* c-dist:lmd */
	if      (conf[i][1].cdw2.lmm_mode < conf[i+current_mapdist][1].cdw2.lmm_mode) { /* [i]の集約を[i+c]に合わせて戻す */
	  if      (conf[i][1].cdw2.lmm_mode==1 && conf[i+current_mapdist][1].cdw2.lmm_mode==2) { /* -- -- 1 0/1 | -- -- 2 0/2 */
	    conf[i][1].cdw2.lmm_mode = 2;   /* split */
	    if (conf[i][0].cdw2.lmm_mode == 1)
	      conf[i][0].cdw2.lmm_mode = 2; /* split */
	    if (conf[i][3].cdw2.lmm_mode || conf[i][2].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=1,2\n", id[current_prefix].name, i, 1, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][1].cdw2.lmm_mode==1 && conf[i+current_mapdist][1].cdw2.lmm_mode==3) { /* -- --  1 -- | -- --  3 -- */
	    conf[i][1].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i][3].cdw2.lmm_mode || conf[i][2].cdw2.lmm_mode || conf[i][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=1,3\n", id[current_prefix].name, i, 1, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][1].cdw2.lmm_mode==2 && conf[i+current_mapdist][1].cdw2.lmm_mode==3) { /* -- --  2 -- | -- --  3 -- */
	    conf[i][1].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=2,3\n", id[current_prefix].name, i, 1, current_mapdist);
	      exit(1);
	    }
	  }
	}
	else if (conf[i][1].cdw2.lmm_mode > conf[i+current_mapdist][1].cdw2.lmm_mode) { /* [i+c]の集約を[i]に合わせて戻す */
	  if      (conf[i][1].cdw2.lmm_mode==2 && conf[i+current_mapdist][1].cdw2.lmm_mode==1) { /* -- -- 2 0/2 | -- -- 1 0/1 */
	    conf[i+current_mapdist][1].cdw2.lmm_mode = 2;   /* split */
	    if (conf[i+current_mapdist][0].cdw2.lmm_mode == 1)
	      conf[i+current_mapdist][0].cdw2.lmm_mode = 2; /* split */
	    if (conf[i+current_mapdist][3].cdw2.lmm_mode || conf[i+current_mapdist][2].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=2,1\n", id[current_prefix].name, i, 1, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][1].cdw2.lmm_mode==3 && conf[i+current_mapdist][1].cdw2.lmm_mode==1) { /* -- --  3 -- | -- --  1 -- */
	    conf[i+current_mapdist][1].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i+current_mapdist][3].cdw2.lmm_mode || conf[i+current_mapdist][2].cdw2.lmm_mode || conf[i+current_mapdist][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=3,1\n", id[current_prefix].name, i, 1, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][1].cdw2.lmm_mode==3 && conf[i+current_mapdist][1].cdw2.lmm_mode==2) { /* -- --  3 -- | -- --  2 -- */
	    conf[i+current_mapdist][1].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i+current_mapdist][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=3,2\n", id[current_prefix].name, i, 1, current_mapdist);
	      exit(1);
	    }
	  }
	}
      }
      /* column-2 */
      if ((lmmi[i                ][2].v && lmmi[i                ][2].rw==0 && !lmmi[i                ][2].f && !lmmi[i                ][2].p
        && lmmi[i+current_mapdist][2].v && lmmi[i+current_mapdist][2].rw==0 && !lmmi[i+current_mapdist][2].f &&  lmmi[i+current_mapdist][2].p)    /* c+dist:lmp */
       || (lmmi[i                ][2].v && lmmi[i                ][2].rw==1 && !lmmi[i                ][2].f &&  lmmi[i                ][2].p  
        && lmmi[i+current_mapdist][2].v && lmmi[i+current_mapdist][2].rw==1 && !lmmi[i+current_mapdist][2].f && !lmmi[i+current_mapdist][2].p)) { /* c-dist:lmd */
	if      (conf[i][2].cdw2.lmm_mode < conf[i+current_mapdist][2].cdw2.lmm_mode) { /* [i]の集約を[i+c]に合わせて戻す */
	  if      (conf[i][2].cdw2.lmm_mode==1 && conf[i+current_mapdist][2].cdw2.lmm_mode==2) { /* 0/1 1 -- -- | 0/2 2 -- -- */
	    conf[i][2].cdw2.lmm_mode = 2;   /* split */
	    if (conf[i][3].cdw2.lmm_mode == 1)
	      conf[i][3].cdw2.lmm_mode = 2; /* split */
	    if (conf[i][1].cdw2.lmm_mode || conf[i][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=1,2\n", id[current_prefix].name, i, 2, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][2].cdw2.lmm_mode==1 && conf[i+current_mapdist][2].cdw2.lmm_mode==3) { /* --  1 -- -- | --  3 -- -- */
	    conf[i][2].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i][3].cdw2.lmm_mode || conf[i][1].cdw2.lmm_mode || conf[i][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=1,3\n", id[current_prefix].name, i, 2, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][2].cdw2.lmm_mode==2 && conf[i+current_mapdist][2].cdw2.lmm_mode==3) { /* --  2 -- -- | --  3 -- -- */
	    conf[i][2].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i][3].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=2,3\n", id[current_prefix].name, i, 2, current_mapdist);
	      exit(1);
	    }
	  }
	}
	else if (conf[i][2].cdw2.lmm_mode > conf[i+current_mapdist][2].cdw2.lmm_mode) { /* [i+c]の集約を[i]に合わせて戻す */
	  if      (conf[i][2].cdw2.lmm_mode==2 && conf[i+current_mapdist][2].cdw2.lmm_mode==1) { /* 0/2 2 -- -- | 0/1 1 -- -- */
	    conf[i+current_mapdist][2].cdw2.lmm_mode = 2;   /* split */
	    if (conf[i+current_mapdist][3].cdw2.lmm_mode == 1)
	      conf[i+current_mapdist][3].cdw2.lmm_mode = 2; /* split */
	    if (conf[i+current_mapdist][1].cdw2.lmm_mode || conf[i+current_mapdist][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=2,1\n", id[current_prefix].name, i, 2, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][2].cdw2.lmm_mode==3 && conf[i+current_mapdist][2].cdw2.lmm_mode==1) { /* --  3 -- -- | --  1 -- -- */
	    conf[i+current_mapdist][2].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i+current_mapdist][3].cdw2.lmm_mode || conf[i+current_mapdist][1].cdw2.lmm_mode || conf[i+current_mapdist][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=3,1\n", id[current_prefix].name, i, 2, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][2].cdw2.lmm_mode==3 && conf[i+current_mapdist][2].cdw2.lmm_mode==2) { /* --  3 -- -- | --  2 -- -- */
	    conf[i+current_mapdist][2].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i+current_mapdist][3].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=3,2\n", id[current_prefix].name, i, 2, current_mapdist);
	      exit(1);
	    }
	  }
	}
      }
      /* column-3 */
      if ((lmmi[i                ][3].v && lmmi[i                ][3].rw==0 && !lmmi[i                ][3].f && !lmmi[i                ][3].p
        && lmmi[i+current_mapdist][3].v && lmmi[i+current_mapdist][3].rw==0 && !lmmi[i+current_mapdist][3].f &&  lmmi[i+current_mapdist][3].p)    /* c+dist:lmp */
       || (lmmi[i                ][3].v && lmmi[i                ][3].rw==1 && !lmmi[i                ][3].f &&  lmmi[i                ][3].p  
        && lmmi[i+current_mapdist][3].v && lmmi[i+current_mapdist][3].rw==1 && !lmmi[i+current_mapdist][3].f && !lmmi[i+current_mapdist][3].p)) { /* c-dist:lmd */
	if      (conf[i][3].cdw2.lmm_mode < conf[i+current_mapdist][3].cdw2.lmm_mode) { /* [i]の集約を[i+c]に合わせて戻す */
	  if      (conf[i][3].cdw2.lmm_mode==1 && conf[i+current_mapdist][3].cdw2.lmm_mode==2) { /* 1 0/1 -- -- | 2 0/2 -- -- */
	    conf[i][3].cdw2.lmm_mode = 2;   /* split */
	    if (conf[i][2].cdw2.lmm_mode == 1)
	      conf[i][2].cdw2.lmm_mode = 2; /* split */
	    if (conf[i][1].cdw2.lmm_mode || conf[i][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=1,2\n", id[current_prefix].name, i, 3, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][3].cdw2.lmm_mode==1 && conf[i+current_mapdist][3].cdw2.lmm_mode==3) { /*  1 -- -- -- |  3 -- -- -- */
	    conf[i][3].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i][2].cdw2.lmm_mode || conf[i][1].cdw2.lmm_mode || conf[i][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=1,3\n", id[current_prefix].name, i, 3, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][3].cdw2.lmm_mode==2 && conf[i+current_mapdist][3].cdw2.lmm_mode==3) { /*  2 -- -- -- |  3 -- -- -- */
	    conf[i][3].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i][2].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=2,3\n", id[current_prefix].name, i, 3, current_mapdist);
	      exit(1);
	    }
	  }
	}
	else if (conf[i][3].cdw2.lmm_mode > conf[i+current_mapdist][3].cdw2.lmm_mode) { /* [i+c]の集約を[i]に合わせて戻す */
	  if      (conf[i][3].cdw2.lmm_mode==2 && conf[i+current_mapdist][3].cdw2.lmm_mode==1) { /* 2 0/2 -- -- | 1 0/1 -- -- */
	    conf[i+current_mapdist][3].cdw2.lmm_mode = 2;   /* split */
	    if (conf[i+current_mapdist][2].cdw2.lmm_mode == 1)
	      conf[i+current_mapdist][2].cdw2.lmm_mode = 2; /* split */
	    if (conf[i+current_mapdist][1].cdw2.lmm_mode || conf[i+current_mapdist][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=2,1\n", id[current_prefix].name, i, 3, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][3].cdw2.lmm_mode==3 && conf[i+current_mapdist][3].cdw2.lmm_mode==1) { /*  3 -- -- -- |  1 -- -- -- */
	    conf[i+current_mapdist][3].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i+current_mapdist][2].cdw2.lmm_mode || conf[i+current_mapdist][1].cdw2.lmm_mode || conf[i+current_mapdist][0].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=3,1\n", id[current_prefix].name, i, 3, current_mapdist);
	      exit(1);
	    }
	  }
	  else if (conf[i][3].cdw2.lmm_mode==3 && conf[i+current_mapdist][3].cdw2.lmm_mode==2) { /*  3 -- -- -- |  2 -- -- -- */
	    conf[i+current_mapdist][3].cdw2.lmm_mode = 3;   /* split */
	    if (conf[i+current_mapdist][2].cdw2.lmm_mode) {
	      printf("in %s: [%d][%d] split_lmm found incomplete pair of lmr+lmp: mapdist=%d mode=3,2\n", id[current_prefix].name, i, 3, current_mapdist);
	      exit(1);
	    }
	  }
	}
      }
    }
  }
  /**********************************************************************************************************/
  /* Step 6 ... Set additional copy-flag for Vertical Broadcast(slave)                                      */
  /*            上から探して後段のvcopyを1にすると,lmf+lmxの場合,lmxがbitmapから消され,結果がDRAINされない  */
  /*            下から探して前段のvcopyを1にするのが正しい                                                  */
  /**********************************************************************************************************/
  for (j=0; j<EMAX_WIDTH; j++) {
    for (i=EMAX_DEPTH-1; i>0; i--) {
      for (k=i-1; k>=0; k--) {
	if (lmmi[i][j].v           && lmmi[k][j].v
         && lmmi[i][j].hcopy  == 0 && lmmi[k][j].hcopy  == 0
	 && lmmi[i][j].vcopy  == 0 && lmmi[k][j].vcopy  == 0
       /*&& lmmi[i][j].rw     == lmmi[k][j].rw*//* lmf and lmx can be merged */
         && lmmi[i][j].f      == lmmi[k][j].f
         && lmmi[i][j].p      == lmmi[k][j].p
         && lmmi[i][j].blk    == lmmi[k][j].blk
         && lmmi[i][j].len    == lmmi[k][j].len
	 && lmmi[i][j].top    == lmmi[k][j].top) {
	  if (lmmi[i][j].rw && lmmi[k][j].rw) { /* Check same addr-range in lmw/lmx */
	    printf("in %s: OP_ST with same addr-range in row[%d] and row[%d] will produce unpredictable result\n", id[current_prefix].name, k, i);
	    exit(1);
	  }
	  lmmi[k][j].vcopy = 1; /* mark as copy */
	  range_link[k][j] = i; /* for setting valid range[] from valid lmmi[] */
	                        /* share variables and reduce cache miss */
	}
      }
    }
  }
  /**********************************************************************************************************/
  /* Step 7 ... emit EMAX6 SC (soft-CGRA for manycore)                                                      */
  /**********************************************************************************************************/
  fprintf(s1fil, "/* EMAXSC start */\n");
  if (!s1fil_header_ready) {
    s1fil_header_ready = 1;
    fprintf(s1fil, "struct  sc_pth   {int dmy[16];} sc_pth[%d] __attribute__((aligned(64)));\n", EMAX_DEPTH);
    fprintf(s1fil, "struct  sc_param {int LOOP0; int LOOP1;} sc_param[%d];\n", EMAX_DEPTH);
    fprintf(s1fil, "struct  {unsigned long long b[%d][%d],o[%d][%d];} SCM0[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* eag0 */
    fprintf(s1fil, "struct  {unsigned long long b[%d][%d],o[%d][%d];} SCM1[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* eag1 */
    fprintf(s1fil, "volatile struct {unsigned long long r[%d][2][%d],enq[%d],d0[8-%d],deq[%d],d1[8-%d];} SCBR[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH*UNIT_WIDTH, EMAX_NCHIP, EMAX_NCHIP, EMAX_NCHIP, EMAX_NCHIP, EMAX_DEPTH); /* br   */
  }
  for (i=0; i<=last_row; i++)
    fprintf(s1fil, "void emax6sc_pth_%s_%02.2d(struct sc_param *);\n", id[current_prefix].name, i);
  fprintf(s1fil, "/* EMAXSC end */\n");

  /* multithreading IMAX2 */
  for (i=0; i<=last_row; i++) {
    /*********************************************************************************************************/
    fprintf(s2fil, "/* EMAXSC start */\n");
    fprintf(s2fil, "void emax6sc_pth_%s_%02.2d(struct sc_param *param) {\n", id[current_prefix].name, i);
    fprintf(s2fil, "Ull  CHIP, LOOP0=param->LOOP0, LOOP1=param->LOOP1;\n");
    fprintf(s2fil, "Ull  INIT1[%d], INIT0[%d];\n", EMAX_NCHIP, EMAX_NCHIP);
    fprintf(s2fil, "Uint uLOOP[%d], enq[%d];\n", EMAX_NCHIP, EMAX_NCHIP, EMAX_NCHIP);
    fprintf(s2fil, "Ull  awoo1[%d][%d], awoo0[%d][%d], mexd1[%d][%d], mexd0[%d][%d], alud[%d][%d];\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH);
    fprintf(s2fil, "for (CHIP=0; CHIP<%d; CHIP++) { /* unit%d */\n", current_nchip, i);
    if (conf[0][0].cdw0.op1 == OP_WHILE)
      fprintf(s2fil, "LOOP1=1;uLOOP[CHIP]=LOOP0=%s;\n", id[dec[i][j].dexu.ex1h].name);
    else if (conf[0][1].cdw0.op1 == OP_FOR)
      fprintf(s2fil, "uLOOP[CHIP]=LOOP1*LOOP0;\n");
    else
      fprintf(s2fil, "LOOP1=1;uLOOP[CHIP]=LOOP0;\n");
    fprintf(s2fil, "}\n");
    fprintf(s2fil, "while (1) {\n");
    fprintf(s2fil, "for (CHIP=0; CHIP<%d; CHIP++)\n", current_nchip);
    fprintf(s2fil, "if (uLOOP[CHIP]) break;\n");
    fprintf(s2fil, "if (CHIP==%d) break;\n", current_nchip);
    fprintf(s2fil, "for (CHIP=0; CHIP<%d; CHIP++) {\n", current_nchip); /* 各unit内でsoft-multithreading */
    fprintf(s2fil, "if (uLOOP[CHIP]==0 || (%d && SCBR[%d].enq[CHIP]==SCBR[%d].deq[CHIP]) || (%d<%d && SCBR[%d].enq[CHIP]!=SCBR[%d].deq[CHIP])) continue;\n", i, (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, last_row, i, i);
    fprintf(s2fil, "SCBR[%d].deq[CHIP] = 1-SCBR[%d].deq[CHIP];\n", (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH);
    fprintf(s2fil, "enq[CHIP] = SCBR[%d].enq[CHIP];\n", i);
    fprintf(s2fil, "INIT1[CHIP]=(uLOOP[CHIP]>LOOP1*LOOP0-LOOP0);\n");
    fprintf(s2fil, "INIT0[CHIP]=(uLOOP[CHIP]==uLOOP[CHIP]/LOOP0*LOOP0);\n");
    /* BR[i-1][0]             |  r  r     |           |  r  r     |        */
    /* BR[i-1][1]             |           |  r  r     |           |  r  r  */
    /* deq-          0  0  0  0->1  1  1  1->0  0  0  0->1  1  1  1->0  0  */
    /*                        V           V           V           V        */
    /* exe[i]                 *  *  * (E) *  *  * (E) *  *  * (E) *  *  *  ((先頭||enq-!=deq-) && enq0==deq0)なら,deq-=1-deq-,exe開始. exe後enq0=1-enq0 */
    /*                        A  |  |  V  A  |  |  V  A  |  |  V  A  |  |              */
    /* enq0          0  0  0  0  0  0  1  1  1  1  0  0  0  0  1  1  1  1  0  0  0  0  */
    /* BR[i][0]               |  w  w  |  r  r     |     w  w  |  r  r     |     w  w  */
    /* BR[i][1]               |        |     w  w  |  r  r     |     w  w  |  r  r     */
    /* deq0          0  0  0  0  0  0  0->1  1  1  1->0  0  0  0->1  1  1  1->0  0  0  */
    /*                                 V        A  V        A  V        A  V           */
    /* exe[i+1]                        *  *  * (E) *  *  * (E) *  *  * (E) *  *  * ((先頭||enq0!=deq0) && enq1==deq1)なら,deq0=1-deq0,exe開始. exe後enq1=1-enq1 */
    /*                                 A  |  |  V  A  |  |  V  A  |  |  V  A  |  |  
    /* enq1          0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  1  1  1  1  0  0  0  0  */
    /* BR[i+1][0]                      |  w  w  |  r  r     |     w  w  |  r  r     |     w  w  */
    /* BR[i+1][1]                      |        |     w  w  |  r  r     |     w  w  |  r  r     */
    /* deq1          0  0  0  0  0  0  0  0  0  0->1  1  1  1->0  0  0  0->1  1  1  1->0  0  0  */

    for (j=0; j<EMAX_WIDTH; j++) {
      fprintf(s2fil, "{\n");
      /*********************************************************************************************************/
      if (conf[i][j].cdw2.brs0 == 2) { /* 0:off, 1:mr10, 2:tr0, 3:mr0  */
	int ts0   = conf[i][j].cdw2.ts0;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", i, j*UNIT_WIDTH+0, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts0);
      }
      if (conf[i][j].cdw2.brs1 == 2) { /* 0:off, 1:mr10, 2:tr0, 3:mr0  */
	int ts1   = conf[i][j].cdw2.ts1;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", i, j*UNIT_WIDTH+1, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts1);
      }
      if (conf[i][j].cdw2.brs2 == 2) { /* 0:off, 1:mr12, 2:tr2, 3:exdr */
	int ts2   = conf[i][j].cdw2.ts2;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", i, j*UNIT_WIDTH+2, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts2);
      }
      if (conf[i][j].cdw2.brs3 == 2) { /* 0:off, 1:mr13, 2:tr3         */
	int ts3   = conf[i][j].cdw2.ts3;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", i, j*UNIT_WIDTH+3, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts3);
      }
      fprintf(s2fil, "}\n");
    }

    for (j=0; j<EMAX_WIDTH; j++) {
      fprintf(s2fil, "{ Ull base, offs, adr, mexdist, mexlimit, load64;\n");
      fprintf(s2fil, "  static int emax6_unaligned_load_valid;\n");
      fprintf(s2fil, "  static Ull emax6_unaligned_load_high;\n");
      /*********************************************************************************************************/
      if (conf[i][j].cdw1.ea1op && conf[i][j].cdw1.ea1op < OP_IM_BUFRD) { /* LOAD1 */
	int eab   = conf[i][j].cdw1.eabbrs;
	int eao   = conf[i][j].cdw1.eaobrs;
	int ea1bs = conf[i][j].cdw1.ea1bs;  /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
	int ea1os = conf[i][j].cdw1.ea1os;  /* 0:ea1or, 1:eaobrs */

	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][enq[CHIP]][%d]:SCM1[%d].b[CHIP][%d]) : awoo1[CHIP][%d];\n", ea1bs, ea1bs, (i+EMAX_DEPTH-1)%EMAX_DEPTH, eab, i, j, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "offs = eam(%d ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : SCM1[%d].o[CHIP][%d], %d);\n", ea1os, (i+EMAX_DEPTH-1)%EMAX_DEPTH, eao, i, j, (Uint)conf[i][j].cdw1.ea1msk);
	fprintf(s2fil, "mexdist = INIT0[CHIP] ? 0 : %d;\n", conf[i][j].cdw0.mex1dist==0? 0: conf[i][j].cdw0.mex1dist==1? 1: conf[i][j].cdw0.mex1dist==2? 2:
                                                            conf[i][j].cdw0.mex1dist==3? 4: conf[i][j].cdw0.mex1dist==4? 8: conf[i][j].cdw0.mex1dist==5?16:
                                                            conf[i][j].cdw0.mex1dist==6?32:64);
	fprintf(s2fil, "mexlimit = %d;\n", conf[i][j].cdw0.mexlimit== 0?    0: conf[i][j].cdw0.mexlimit== 1?    8: conf[i][j].cdw0.mexlimit== 2?    16:
                                           conf[i][j].cdw0.mexlimit== 3?   32: conf[i][j].cdw0.mexlimit== 4?   64: conf[i][j].cdw0.mexlimit== 5?   128:
                                           conf[i][j].cdw0.mexlimit== 6?  256: conf[i][j].cdw0.mexlimit== 7?  512: conf[i][j].cdw0.mexlimit== 8?  1024:
                                           conf[i][j].cdw0.mexlimit== 9? 2048: conf[i][j].cdw0.mexlimit==10? 4096: conf[i][j].cdw0.mexlimit==11?  8192:
                                           conf[i][j].cdw0.mexlimit==12?16384: conf[i][j].cdw0.mexlimit==13?32768: conf[i][j].cdw0.mexlimit==14? 65536:131072);
	switch (conf[i][j].cdw0.mex1op) {
	case OP_NOP:
	  fprintf(s2fil, "awoo1[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo1[CHIP][%d]);\n", j, j);
	  break;
	case OP_ALWAYS: /* base++ 対応 */
	  fprintf(s2fil, "awoo1[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo1[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", j, j);
	  break;
	case OP_CMPA_LE:
	  fprintf(s2fil, "if (!mexlimit) awoo1[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo1[CHIP][%d])+(INIT0[CHIP]?0:((mexd1[CHIP][%d]>>32)!=0xffffffff && (mexd1[CHIP][%d]>>32)<=(mexd0[CHIP][%d]>>32))?mexdist:0);\n", j, j, j, j, j);
	  break;
	case OP_CMPA_GE:
	  fprintf(s2fil, "if (!mexlimit) awoo1[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo1[CHIP][%d])+(INIT0[CHIP]?0:((mexd0[CHIP][%d]>>32)!=0xffffffff && (mexd1[CHIP][%d]>>32)>=(mexd0[CHIP][%d]>>32))?mexdist:0);\n", j, j, j, j, j);
	  break;
	default:
	  printf("EMAXSC:undefined conf[%d][%d].mex1op=%d\n", i, j, conf[i][j].cdw0.mex1op);
	  break;
	}  

#if defined(__i386)
	fprintf(s2fil, "adr = (Uint)(awoo1[CHIP][%d] + offs);\n", j);
#else
	fprintf(s2fil, "adr = (Ull)(awoo1[CHIP][%d] + offs);\n", j);
#endif

	switch (conf[i][j].cdw1.ea1op) {
	case OP_LDR: /* 64bit lmm LMM is preloaded, random-access */
	  fprintf(s2fil, "load64 = *(Ull*)(adr&~7LL);\n");
	  fprintf(s2fil, "if ((adr&7) == 0)\n");
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq[CHIP]][%d] = load64;\n", i, j*UNIT_WIDTH+1);
	  fprintf(s2fil, "else if (!emax6_unaligned_load_valid) { /* BR[][][1] */\n");
	  fprintf(s2fil, "  emax6_unaligned_load_valid = 1;\n");
	  fprintf(s2fil, "  emax6_unaligned_load_high = load64;\n");
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq[CHIP]][%d] = load64 >> (adr&7)*8;\n", i, j*UNIT_WIDTH+1);
	  fprintf(s2fil, "}\n");
	  fprintf(s2fil, "else { /* BR[][][0] */\n");
	  fprintf(s2fil, "  emax6_unaligned_load_valid = 0;\n");
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq[CHIP]][%d] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, j*UNIT_WIDTH+1);
	  fprintf(s2fil, "}\n");
	  break;
	case OP_LDWR: /* u32bit lmm LMM is preloaded, random-access */
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, j*UNIT_WIDTH+1);
	  break;
	case OP_LDBR: /* u8bit lmm LMM is preloaded, random-access */
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, j*UNIT_WIDTH+1);
	  break;
	case OP_LDRQ: /* 64bit*4 lmm LMM is preloaded, random-access */
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, j*UNIT_WIDTH+0);
          fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, j*UNIT_WIDTH+1);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, j*UNIT_WIDTH+2);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, j*UNIT_WIDTH+3);
	  break;
	default:
	  printf("EMAXSC:undefined conf[%d][%d].cdw1.ea1op=%d\n", i, j, conf[i][j].cdw1.ea1op);
	  break;
	}
      }

      /*********************************************************************************************************/
      if (conf[i][j].cdw1.ea0op && conf[i][j].cdw1.ea0op < OP_IM_BUFRD) { /* LOAD0 */
	int eab   = conf[i][j].cdw1.eabbrs;
	int eao   = conf[i][j].cdw1.eaobrs;
	int ea0bs = conf[i][j].cdw1.ea0bs;  /* 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
	int ea0os = conf[i][j].cdw1.ea0os;  /* 0:ea0or, 1:eaobrs */
	
	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : awoo0[CHIP][%d];\n", ea0bs, ea0bs, (i+EMAX_DEPTH-1)%EMAX_DEPTH, eab, i, j, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "offs = eam(%d ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", ea0os, (i+EMAX_DEPTH-1)%EMAX_DEPTH, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
	fprintf(s2fil, "mexdist = INIT0[CHIP] ? 0 : %d;\n", conf[i][j].cdw0.mex0dist==0? 0: conf[i][j].cdw0.mex0dist==1? 1: conf[i][j].cdw0.mex0dist==2? 2:
                                                            conf[i][j].cdw0.mex0dist==3? 4: conf[i][j].cdw0.mex0dist==4? 8: conf[i][j].cdw0.mex0dist==5?16:
                                                            conf[i][j].cdw0.mex0dist==6?32:64);
	fprintf(s2fil, "mexlimit = %d;\n", conf[i][j].cdw0.mexlimit== 0?    0: conf[i][j].cdw0.mexlimit== 1?    8: conf[i][j].cdw0.mexlimit== 2?    16:
                                           conf[i][j].cdw0.mexlimit== 3?   32: conf[i][j].cdw0.mexlimit== 4?   64: conf[i][j].cdw0.mexlimit== 5?   128:
                                           conf[i][j].cdw0.mexlimit== 6?  256: conf[i][j].cdw0.mexlimit== 7?  512: conf[i][j].cdw0.mexlimit== 8?  1024:
                                           conf[i][j].cdw0.mexlimit== 9? 2048: conf[i][j].cdw0.mexlimit==10? 4096: conf[i][j].cdw0.mexlimit==11?  8192:
                                           conf[i][j].cdw0.mexlimit==12?16384: conf[i][j].cdw0.mexlimit==13?32768: conf[i][j].cdw0.mexlimit==14? 65536:131072);
	switch (conf[i][j].cdw0.mex0op) {
	case OP_NOP:
	  fprintf(s2fil, "awoo0[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo0[CHIP][%d]);\n", j, j);
	  break;
	case OP_ALWAYS: /* base++ 対応 */
	  fprintf(s2fil, "awoo0[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo0[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", j, j);
	  break;
	case OP_CMPA_LE:
	  fprintf(s2fil, "if (!mexlimit) awoo0[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo0[CHIP][%d])+(INIT0[CHIP]?0:((mexd1[CHIP][%d]>>32)!=0xffffffff && (mexd1[CHIP][%d]>>32)<=(mexd0[CHIP][%d]>>32))?mexdist:0);\n", j, j, j, j, j);
	  break;
	case OP_CMPA_GE:
	  fprintf(s2fil, "if (!mexlimit) awoo0[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo0[CHIP][%d])+(INIT0[CHIP]?0:((mexd0[CHIP][%d]>>32)!=0xffffffff && (mexd1[CHIP][%d]>>32)>=(mexd0[CHIP][%d]>>32))?mexdist:0);\n", j, j, j, j, j);
	  break;
	default:
	  printf("EMAXSC:undefined conf[%d][%d].mex0op=%d\n", i, j, conf[i][j].cdw0.mex0op);
	  break;
	}  

#if defined(__i386)
	fprintf(s2fil, "adr = (Uint)(awoo0[CHIP][%d] + offs);\n", j);
#else
	fprintf(s2fil, "adr = (Ull)(awoo0[CHIP][%d] + offs);\n", j);
#endif

	switch (conf[i][j].cdw1.ea0op) {
	case OP_LDR: /* 64bit lmm LMM is preloaded, random-access */
	  fprintf(s2fil, "load64 = *(Ull*)(adr&~7LL);\n");
	  fprintf(s2fil, "if ((adr&7) == 0)\n");
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq[CHIP]][%d] = load64;\n", i, j*UNIT_WIDTH+0);
	  fprintf(s2fil, "else if (!emax6_unaligned_load_valid) { /* BR[][][1] */\n");
	  fprintf(s2fil, "  emax6_unaligned_load_valid = 1;\n");
	  fprintf(s2fil, "  emax6_unaligned_load_high = load64;\n");
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq[CHIP]][%d] = load64 >> (adr&7)*8;\n", i, j*UNIT_WIDTH+0);
	  fprintf(s2fil, "}\n");
	  fprintf(s2fil, "else { /* BR[][][0] */\n");
	  fprintf(s2fil, "  emax6_unaligned_load_valid = 0;\n");
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq[CHIP]][%d] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, j*UNIT_WIDTH+0);
	  fprintf(s2fil, "}\n");
	  break;
	case OP_LDWR: /* u32bit lmm LMM is preloaded, random-access */
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, j*UNIT_WIDTH+0);
	  break;
	case OP_LDBR: /* u8bit lmm LMM is preloaded, random-access */
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, j*UNIT_WIDTH+0);
	  break;
	case OP_LDRQ: /* 64bit*4 lmm LMM is preloaded, random-access */
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, j*UNIT_WIDTH+0);
          fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, j*UNIT_WIDTH+1);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, j*UNIT_WIDTH+2);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, j*UNIT_WIDTH+3);
	  break;
	default:
	  printf("EMAXSC:undefined conf[%d][%d].cdw1.ea0op=%d\n", i, j, conf[i][j].cdw1.ea0op);
	  break;
	}
      }

      if (conf[i][j].cdw1.ea1op && conf[i][j].cdw1.ea1op < OP_IM_BUFRD) { /* LOAD1 */
	fprintf(s2fil, "mexd1[CHIP][%d] = SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", j, i, j*UNIT_WIDTH+1);
	
      }
      if (conf[i][j].cdw1.ea0op && conf[i][j].cdw1.ea0op < OP_IM_BUFRD) { /* LOAD0 */
	fprintf(s2fil, "mexd0[CHIP][%d] = SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", j, i, j*UNIT_WIDTH+0);
      }
      
      fprintf(s2fil, "}\n");
    }

    for (j=0; j<EMAX_WIDTH; j++) {
      fprintf(s2fil, "{ union { Uint i; float f; } f3, f2, f1, f0; Ull t3, t2, t1, t0, ex1, ex2, ex3, ex4, ex5, c1, c0, ex1_outd, ex2_outd;\n");
      /*********************************************************************************************************/
      if (conf[i][j].cdw0.op1 || conf[i][j].cdw0.op2 || conf[i][j].cdw0.op3) {
	int ex1brs = conf[i][j].cdw0.ex1brs; /* 0:br0_0, 1:br0_1, ... 15:3_3 */
	int ex1s   = conf[i][j].cdw0.ex1s;   /* 0:ex1brs, 1:exdr(self-loop) */
	int ex1exp = conf[i][j].cdw0.ex1exp; /* 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
	int ex2brs = conf[i][j].cdw0.ex2brs; /* 0:br0_0, 1:br0_1, ... 15:3_3 */
	int ex2exp = conf[i][j].cdw0.ex2exp; /* 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
	int ex3brs = conf[i][j].cdw0.ex3brs; /* 0:br0_0, 1:br0_1, ... 15:3_3 */
	int ex3exp = conf[i][j].cdw0.ex3exp; /* 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
	Ull e2imm  = conf[i][j].cdw3.e2imm;
	int e2is   = conf[i][j].cdw0.e2is;   /* 0:e2imm, 1:ex2, 2:ex3 */
	int e3imm  = conf[i][j].cdw0.e3imm;
	int e3is   = conf[i][j].cdw0.e3is;   /* 0:e3imm, 1:ex3 */
	int init   = conf[i][j].cdw0.init;   /* bit0:activate s1+INIT0 bit1:activate s2+INIT0 */
	int fold   = conf[i][j].cdw0.fold;   /* 0:normal, 1:load-exe-store folding */

	/* foldの場合も,1サイクル送らせる必要はなく,LDに続けてexe-stを実行すれば良い */
	switch (conf[i][j].cdw0.op1) {
	case OP_NOP:
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex1_outd = ex1;\n");
	  break;
	case OP_WHILE:
	case OP_FOR:
	  break;
	case OP_CFMA: /* [idx|32bit]*2 3in =(idx2==idx3)?r1+r2*r3:r1 */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n",                                    !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs, ex3exp);
	  fprintf(s2fil, "f1.i = (Uint)(ex1);\n");
	  fprintf(s2fil, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(s2fil, "f3.i = (Uint)(ex3>>32);\n");
	  fprintf(s2fil, "if (f2.i != -1 && f2.i == f3.i) {\n");
	  fprintf(s2fil, "  f2.i = (Uint)(ex2);\n");
	  fprintf(s2fil, "  f3.i = (Uint)(ex3);\n");
	  fprintf(s2fil, "  f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(s2fil, "}\n");
	  fprintf(s2fil, "else {\n");
	  fprintf(s2fil, "  f0.f = f1.f;\n");
	  fprintf(s2fil, "}\n");
	  fprintf(s2fil, "t0 = f0.i;\n");
	  fprintf(s2fil, "ex1_outd = t0;\n");
	  break;
	case OP_FMA: /* 32bit*2 3in floating-point r1+r2*r3 */
	case OP_FMS: /* 32bit*2 3in floating-point r1-r2*r3 */
	  /* *(double*)&ex1_outd = *(double*)&r1 + (*(double*)&r2 * *(double*)&r3);*/
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n",                                    !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs, ex3exp);
	  fprintf(s2fil, "f1.i = (Uint)(ex1>>32);\n");
	  fprintf(s2fil, "f2.i = (Uint)(ex2>>32)^%08.8x;\n", conf[i][j].cdw0.op1==OP_FMA?0:0x80000000);
	  fprintf(s2fil, "f3.i = (Uint)(ex3>>32);\n");
	  fprintf(s2fil, "f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(s2fil, "t2 = f0.i;\n");
	  fprintf(s2fil, "f1.i = (Uint)(ex1);\n");
	  fprintf(s2fil, "f2.i = (Uint)(ex2)^%08.8x;\n", conf[i][j].cdw0.op1==OP_FMA?0:0x80000000);
	  fprintf(s2fil, "f3.i = (Uint)(ex3);\n");
	  fprintf(s2fil, "f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(s2fil, "t0 = f0.i;\n");
	  fprintf(s2fil, "ex1_outd = (t2<<32)|(t0);\n");
	  break;
	case OP_FAD: /* 32bit*2 3in floating-point r1+r2 */
	  /* *(double*)&ex1_outd = *(double*)&r1 + *(double*)&r2;*/
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "f1.i = (Uint)(ex1>>32);\n");
	  fprintf(s2fil, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(s2fil, "f0.f = f1.f + f2.f;\n");
	  fprintf(s2fil, "t2 = f0.i;\n");
	  fprintf(s2fil, "f1.i = (Uint)(ex1);\n");
	  fprintf(s2fil, "f2.i = (Uint)(ex2);\n");
	  fprintf(s2fil, "f0.f = f1.f + f2.f;\n");
	  fprintf(s2fil, "t0 = f0.i;\n");
	  fprintf(s2fil, "ex1_outd = (t2<<32)|(t0);\n");
	  break;
	case OP_FML: /* 32bit*2 3in floating-point r1*r2 */
	  /* *(double*)&ex1_outd = *(double*)&r1 * *(double*)&r2;*/
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "f1.i = (Uint)(ex1>>32);\n");
	  fprintf(s2fil, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(s2fil, "f0.f = f1.f * f2.f;\n");
	  fprintf(s2fil, "t2 = f0.i;\n");
	  fprintf(s2fil, "f1.i = (Uint)(ex1);\n");
	  fprintf(s2fil, "f2.i = (Uint)(ex2);\n");
	  fprintf(s2fil, "f0.f = f1.f * f2.f;\n");
	  fprintf(s2fil, "t0 = f0.i;\n");
	  fprintf(s2fil, "ex1_outd = (t2<<32)|(t0);\n");
	  break;
	case OP_ADD3: /* 32bit*2 3in integer add s1+(s2+s3) */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n",                                    !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs, ex3exp);
	  fprintf(s2fil, "t2 = (ex1>>32&0x00000000ffffffffLL)+((ex2>>32&0x00000000ffffffffLL)+(ex3>>32&0x00000000ffffffffLL));\n");
	  fprintf(s2fil, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(s2fil, "t0 = (ex1    &0x00000000ffffffffLL)+((ex2    &0x00000000ffffffffLL)+(ex3    &0x00000000ffffffffLL));\n");
	  fprintf(s2fil, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(s2fil, "ex1_outd = (t2<<32)|(t0);\n");
	  break;
	case OP_SUB3: /* 32bit*2 3in integer subtract s1-(s2+s3) */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n",                                    !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs, ex3exp);
	  fprintf(s2fil, "t2 = (ex1>>32&0x00000000ffffffffLL)-((ex2>>32&0x00000000ffffffffLL)+(ex3>>32&0x00000000ffffffffLL));\n");
	  fprintf(s2fil, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(s2fil, "t0 = (ex1    &0x00000000ffffffffLL)-((ex2    &0x00000000ffffffffLL)+(ex3    &0x00000000ffffffffLL));\n");
	  fprintf(s2fil, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(s2fil, "ex1_outd = (t2<<32)|(t0);\n");
	  break;
	case OP_ADD: /* 32bit*2 2in integer add s1+s2 */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "t2 = (ex1>>32&0x00000000ffffffffLL)+(ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(s2fil, "t0 = (ex1    &0x00000000ffffffffLL)+(ex2    &0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(s2fil, "ex1_outd = (t2<<32)|(t0);\n");
	  break;
	case OP_SUB: /* 32bit*2 2in integer subtract s1-s2 */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "t2 = (ex1>>32&0x00000000ffffffffLL)-(ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(s2fil, "t0 = (ex1    &0x00000000ffffffffLL)-(ex2    &0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(s2fil, "ex1_outd = (t2<<32)|(t0);\n");
	  break;
	case OP_CMP_EQ: /* 32bit*2 2in compare and set 1*2bit-CC */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "c1 = (ex1>>32&0x00000000ffffffffLL) == (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "c0 = (ex1    &0x00000000ffffffffLL) == (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "ex1_outd = (c1<<32)|c0;\n");
	  break;
	case OP_CMP_NE: /* 32bit*2 2in compare and set 1*2bit-CC */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "c1 = (ex1>>32&0x00000000ffffffffLL) != (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "c0 = (ex1    &0x00000000ffffffffLL) != (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "ex1_outd = (c1<<32)|c0;\n");
	  break;
	case OP_CMP_LT: /* 32bit*2 2in compare and set 1*2bit-CC */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "c1 = (ex1>>32&0x00000000ffffffffLL) < (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "c0 = (ex1    &0x00000000ffffffffLL) < (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "ex1_outd = (c1<<32)|c0;\n");
	  break;
	case OP_CMP_LE: /* 32bit*2 2in compare and set 1*2bit-CC */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "c1 = (ex1>>32&0x00000000ffffffffLL) <= (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "c0 = (ex1    &0x00000000ffffffffLL) <= (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "ex1_outd = (c1<<32)|c0;\n");
	  break;
	case OP_CMP_GT: /* 32bit*2 2in compare and set 1*2bit-CC */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "c1 = (ex1>>32&0x00000000ffffffffLL) > (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "c0 = (ex1    &0x00000000ffffffffLL) > (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "ex1_outd = (c1<<32)|c0;\n");
	  break;
	case OP_CMP_GE: /* 32bit*2 2in compare and set 1*2bit-CC */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "c1 = (ex1>>32&0x00000000ffffffffLL) >= (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "c0 = (ex1    &0x00000000ffffffffLL) >= (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "ex1_outd = (c1<<32)|c0;\n");
	  break;
	case OP_CMOV: /* 32bit*2 3in 2bit conditional move */
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][enq[CHIP]][%d], %d);\n",                                    !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs, ex3exp);
	  fprintf(s2fil, "c1 = ex1>>32&1;\n");
	  fprintf(s2fil, "c0 = ex1    &1;\n");
	  fprintf(s2fil, "t2 = c1 ? (ex2&0xffffffff00000000LL) : (ex3&0xffffffff00000000LL);\n");
	  fprintf(s2fil, "t0 = c0 ? (ex2&0x00000000ffffffffLL) : (ex3&0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "ex1_outd = t2 | t0;\n");
	  break;
	default:
	  printf("EMAXSC:undefined conf[%d][%d].cdw0.op1=%d\n", i, j, conf[i][j].cdw0.op1);
	  break;
	}

	switch (conf[i][j].cdw0.op2) {
	case OP_NOP:
	  if (conf[i][j].cdw0.op1 != OP_WHILE && conf[i][j].cdw0.op1 != OP_FOR)
	  fprintf(s2fil, "ex2_outd = ex1_outd;\n");
	  break;
	case OP_AND: /* 64bit 2in logical and s1&s2 */
	  fprintf(s2fil, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs);
	  fprintf(s2fil, "ex2_outd = ex1_outd & ex4;\n");
	  break;
	case OP_OR: /* 64bit 2in logical or s1|s2 */
	  fprintf(s2fil, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs);
	  fprintf(s2fil, "ex2_outd = ex1_outd | ex4;\n");
	  break;
	case OP_XOR: /* 64bit 2in logical xor s1^s2 */
	  fprintf(s2fil, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs);
	  fprintf(s2fil, "ex2_outd = ex1_outd ^ ex4;\n");
	  break;
	default:
	  printf("EMAXSC:undefined conf[%d][%d].cdw0.op2=%d\n", i, j, conf[i][j].cdw0.op2);
	  break;
	}
	
	switch (conf[i][j].cdw0.op3) {
	case OP_NOP:
	  if (conf[i][j].cdw0.op1 != OP_WHILE && conf[i][j].cdw0.op1 != OP_FOR)
	  fprintf(s2fil, "alud[CHIP][%d] = ex2_outd;\n", j);
	  break;
	case OP_SLL: /* 32bit*2 2in 32bit logical shift to left */
	  fprintf(s2fil, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs);
	  fprintf(s2fil, "t1 = (Ull)(ex2_outd     &0xffffffff00000000LL)<<ex5;\n");
	  fprintf(s2fil, "t0 = (Ull)(ex2_outd<<ex5&0x00000000ffffffffLL);\n");
	  fprintf(s2fil, "alud[CHIP][%d] = t1 | t0;\n", j);
	  break;
	case OP_SRL: /* 32bit*2 2in 32bit logical shift to right */
	  fprintf(s2fil, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs);
	  fprintf(s2fil, "t1 = (Ull)(ex2_outd>>ex5&0xffffffff00000000LL);\n");
	  fprintf(s2fil, "t0 = (Ull)(ex2_outd     &0x00000000ffffffffLL)>>ex5;\n");
	  fprintf(s2fil, "alud[CHIP][%d] = t1 | t0;\n", j);
	  break;
	default:
	  printf("EMAXSC:undefined conf[%d][%d].cdw0.op3=%d\n", i, j, conf[i][j].cdw0.op3);
	  break;
	}

	if (conf[i][j].cdw2.brs2 == 3) { /* 0:off, 1:mr12, 2:tr2, 3:exdr */
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq[CHIP]][%d] = alud[CHIP][%d];\n", i, j*UNIT_WIDTH+2, j);
	}
      }
      fprintf(s2fil, "}\n");
    }

    for (j=0; j<EMAX_WIDTH; j++) {
      fprintf(s2fil, "{ Ull cs0, cs1, cs2, cs3, cex, base, offs, adr, mexdist;\n");
      /*********************************************************************************************************/
      if (dec[i][j].dcex.op) { /* confに存在しない */
	int fold    = conf[i][j].cdw0.fold;    /* 0:normal, 1:load-exe-store folding */
	int cs0     = conf[i][j].cdw1.cs0;     /* 0:br0_0, 1:br0_1, ... 15:3_3 */
	int cs1     = conf[i][j].cdw1.cs1;     /* 0:br0_0, 1:br0_1, ... 15:3_3 */
	int cs2     = conf[i][j].cdw1.cs2;     /* 0:br0_0, 1:br0_1, ... 15:3_3 */
	int cs3     = conf[i][j].cdw1.cs3;     /* 0:br0_0, 1:br0_1, ... 15:3_3 */
	int cex_tab = conf[i][j].cdw1.cex_tab; /* c3.c2.c1.c0の組合せ (cop=NOPの場合,ffff) */

	fprintf(s2fil, "cs0 = SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, cs0);
	fprintf(s2fil, "cs1 = SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, cs1);
	fprintf(s2fil, "cs2 = SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, cs2);
	fprintf(s2fil, "cs3 = SCBR[%d].r[CHIP][enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, cs3);
	fprintf(s2fil, "cex = ((0x%04.4x>>(((cs3>>32&1)<<3)|((cs2>>32&1)<<2)|((cs1>>32&1)<<1)|(cs0>>32&1))&1)?2:0) | ((0x%04.4x>>(((cs3&1)<<3)|((cs2&1)<<2)|((cs1&1)<<1)|(cs0&1))&1)?1:0);\n", cex_tab, cex_tab);
      }

      /*********************************************************************************************************/
      if (conf[i][j].cdw1.ea0op > OP_IM_BUFRD) { /* STORE */
	int fold  = conf[i][j].cdw0.fold;   /* 0:normal, 1:load-exe-store folding */
	int eab   = conf[i][j].cdw1.eabbrs;
	int eao   = conf[i][j].cdw1.eaobrs;
	int ea0bs = conf[i][j].cdw1.ea0bs;  /* 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
	int ea0os = conf[i][j].cdw1.ea0os;  /* 0:ea0or, 1:eaobrs */
	int ts0   = conf[i][j].cdw2.ts0;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	int ts1   = conf[i][j].cdw2.ts1;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	int ts2   = conf[i][j].cdw2.ts2;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	int ts3   = conf[i][j].cdw2.ts3;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	int mws0  = conf[i][j].cdw2.mws0;   /* 0:lmwd0, 1:exdr, 2:ts0 */
	int mws1  = conf[i][j].cdw2.mws1;   /* 0:lmwd1, 1:exdr, 2:ts1 */
	int mws2  = conf[i][j].cdw2.mws2;   /* 0:lmwd2, 1:exdr, 2:ts2 */
	int mws3  = conf[i][j].cdw2.mws3;   /* 0:lmwd3, 1:exdr, 2:ts3 */

	if (!dec[i][j].dcex.op)
	  fprintf(s2fil, "cex = 3;\n");

	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : awoo0[CHIP][%d];\n", ea0bs, ea0bs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, eab, i, j, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "offs = eam(%d ? SCBR[%d].r[CHIP][enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", ea0os, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
	fprintf(s2fil, "mexdist = INIT0[CHIP] ? 0 : %d;\n", conf[i][j].cdw0.mex0dist==0? 0: conf[i][j].cdw0.mex0dist==1? 1: conf[i][j].cdw0.mex0dist==2? 2:
                                                            conf[i][j].cdw0.mex0dist==3? 4: conf[i][j].cdw0.mex0dist==4? 8: conf[i][j].cdw0.mex0dist==5?16:
                                                            conf[i][j].cdw0.mex0dist==6?32:64);
	switch (conf[i][j].cdw0.mex0op) {
	case OP_NOP:
	  fprintf(s2fil, "awoo0[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo0[CHIP][%d]);\n", j, j);
	  break;
	case OP_ALWAYS: /* base++ 対応 */
	  fprintf(s2fil, "awoo0[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo0[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", j, j);
	  break;
	default:
	  printf("EMAXSC:undefined conf[%d][%d].mex0op=%d\n", i, j, conf[i][j].cdw0.mex0op);
	  break;
	}  

#if defined(__i386)
	fprintf(s2fil, "adr = (Uint)(awoo0[CHIP][%d] + offs);\n", j);
#else
	fprintf(s2fil, "adr = (Ull)(awoo0[CHIP][%d] + offs);\n", j);
#endif
	  
	switch (conf[i][j].cdw1.ea0op) {
	case OP_STR: /* 64bit lmm LMM is drained. random-access */
	  fprintf(s2fil, "if (cex>>1&1) *((Uint*)(adr&~7LL)+1) = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][enq[CHIP]][%d])>>32;\n", mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts0);
	  fprintf(s2fil, "if (cex   &1) *((Uint*)(adr&~7LL)  ) = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][enq[CHIP]][%d]);\n",     mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts0);
	  break;
	case OP_STWR: /* 32bit lmm LMM is drained. random-access */
	  fprintf(s2fil, "if (cex   &1) *(Uint*)(adr&~3LL) = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][enq[CHIP]][%d]);\n", mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts0);
	  break;
	case OP_STBR: /* 8bit lmm LMM is drained. random-access */
	  fprintf(s2fil, "if (cex   &1) *(Uchar*)adr = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][enq[CHIP]][%d]);\n", mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts0);
	  break;
	case OP_STRQ: /* 64bit*4 lmm LMM is drained. random-access */
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+0) = (%d==1? alud[CHIP][0] : SCBR[%d].r[CHIP][enq[CHIP]][%d]);\n", mws0, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts0);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+1) = (%d==1? alud[CHIP][1] : SCBR[%d].r[CHIP][enq[CHIP]][%d]);\n", mws1, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts1);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+2) = (%d==1? alud[CHIP][2] : SCBR[%d].r[CHIP][enq[CHIP]][%d]);\n", mws2, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts2);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+3) = (%d==1? alud[CHIP][3] : SCBR[%d].r[CHIP][enq[CHIP]][%d]);\n", mws3, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts3);
	  break;
	default:
	  printf("emax6lib: mmp: undefined op_mm=%d\n", dec[i][j].dmop0.op);
	  break;
	}
      }
      fprintf(s2fil, "}\n");
    }

    fprintf(s2fil, "SCBR[%d].enq[CHIP] = 1-SCBR[%d].enq[CHIP];\n", i, i);
    fprintf(s2fil, "uLOOP[CHIP]--;\n");
    fprintf(s2fil, "}\n"); /* for (CHIP) */
    fprintf(s2fil, "}\n"); /* while (1) */
    fprintf(s2fil, "}\n"); /* pth_func() */
    fprintf(s2fil, "/* EMAXSC end */\n");
  }

  /**********************************************************************************************************/
  fprintf(ofile, "#ifdef EMAXSC\n");
  fprintf(ofile, "/* EMAXSC start */\n");
    
  /* init REGV(breg) */
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      for (k=0; k<UNIT_WIDTH; k++) {
	if (regv[i][j].br[k].v) {
	  if (id[regv[i][j].br[k].h].chip) { /* CHIP */
	    for (c=0; c<current_nchip; c++) {
	      fprintf(ofile, "SCBR[%d].r[%d][0][%d] = %d;\n", i, c, j*UNIT_WIDTH+k, c);
	      fprintf(ofile, "SCBR[%d].r[%d][1][%d] = %d;\n", i, c, j*UNIT_WIDTH+k, c);
	    }
	  }
	  else if (id[regv[i][j].br[k].h].cidx) { /* xxx[CHIP] */
	    for (c=0; c<current_nchip; c++) {
	      fprintf(ofile, "SCBR[%d].r[%d][0][%d] = %s[%d];\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name, c);
	      fprintf(ofile, "SCBR[%d].r[%d][1][%d] = %s[%d];\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name, c);
	    }
	  }
	  else if (regv[i][j].br[k].s < 0) {
	    for (c=0; c<current_nchip; c++) {
	      fprintf(ofile, "SCBR[%d].r[%d][0][%d] = %s;\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name);
	      fprintf(ofile, "SCBR[%d].r[%d][1][%d] = %s;\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name);
	    }
	  }
	  else {
	    for (c=0; c<current_nchip; c++) {
	      fprintf(ofile, "SCBR[%d].r[%d][0][%d] = %s[%d];\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name, regv[i][j].br[k].s);
	      fprintf(ofile, "SCBR[%d].r[%d][1][%d] = %s[%d];\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name, regv[i][j].br[k].s);
	    }
	  }
	}
      }
    }
  }

  /* init REGV(eag) */
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (regv[i][j].ea0b_v) {
	if (id[regv[i][j].ea0b_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].b[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea0b_h].name, c);
	}
	else if (regv[i][j].ea0b_s < 0) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].b[%d][%d] = (Ull)%s;\n", i, c, j, id[regv[i][j].ea0b_h].name);
	}
	else {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].b[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
	}
      }
      if (regv[i][j].ea0o_v) {
	if (id[regv[i][j].ea0o_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].o[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea0o_h].name, c);
	}
	else if (regv[i][j].ea0o_s < 0) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].o[%d][%d] = (Ull)%s;\n", i, c, j, id[regv[i][j].ea0o_h].name);
	}
	else {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].o[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
	}
      }
      if (regv[i][j].ea1b_v) {
	if (id[regv[i][j].ea1b_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].b[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea1b_h].name, c);
	}
	else if (regv[i][j].ea1b_s < 0) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].b[%d][%d] = (Ull)%s;\n", i, c, j, id[regv[i][j].ea1b_h].name);
	}
	else {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].b[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
	}
      }
      if (regv[i][j].ea1o_v) {
	if (id[regv[i][j].ea1o_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].o[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea1o_h].name, c);
	}
	else if (regv[i][j].ea1o_s < 0) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].o[%d][%d] = (Ull)%s;\n", i, c, j, id[regv[i][j].ea1o_h].name);
	}
	else {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].o[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
	}
      }
    }
  }

  for (i=0; i<=last_row; i++)
    fprintf(ofile, "sc_param[%d].LOOP0=LOOP0; sc_param[%d].LOOP1=LOOP1; pthread_create((pthread_t*)&sc_pth[%d], 0, emax6sc_pth_%s_%02.2d, &sc_param[%d]);\n", i, i, i, id[current_prefix].name, i, i);
  for (i=0; i<=last_row; i++)
    fprintf(ofile, "pthread_join(*(pthread_t*)&sc_pth[%d], 0);\n", i);

  fprintf(ofile, "/* EMAXSC end */\n");
  fprintf(ofile, "#endif\n");
  /**********************************************************************************************************/
  /* Step 8 ... emit EMAX6 CGRA                                                                             */
  /**********************************************************************************************************/
  /* resolve lmmi -> host-lmmi */
  fprintf(ofile, "#ifndef EMAXSC\n");
  fprintf(ofile, "\temax6.lmmio = emax6.lmmic;\n");
  fprintf(ofile, "\temax6.lmmic = 1-emax6.lmmic;\n");
  fprintf(ofile, "\temax6.mapdist = %d;\n", current_mapdist);
  lmmi_first_loc = -1;
  for (j=0; j<EMAX_WIDTH; j++) {
    lmmi_bitmap[j] = 0LL;
    range_bitmap[j] = 0LL;
  }
  /*                               lmmi-loc  v  top  blk  len  rw  f  p *//*   lmmi bitmap drain load ar pl/pd last_drain */
  /* lmr                               curr  1  top  blk  len   0  0  0 *//*  8  1      1     -   *1   -   -      -       */
  /* lmf                               curr  1  top  blk  len   0  1  0 *//* 10  1      1     -   *1   -   -      -       */
  /* lmr+lmp(mapdist!=0)               curr  1  top  blk  len   0  0  0 *//*  8  1      1     -   *1   -   -      -       */
  /*                                 c+dist  1 ptop  blk  len   0  0  1 *//*  9  1      1     -    -   -  *1      -       */
  /* lmr+lmp(mapdist==0) ofs=ptop-top  curr  1  top  blk  len   0  0  1 *//*  9  1      1     -   *1   1  *1      -       */
  /* lddmq                             curr  1  top  -    -     0  1  1 *//* 11  -      -     -    -   -   -      -       */
  /* lmw    (mapdist!=0)               curr  1  top  blk  len   1  0  0 *//* 12  1      1     -    -   -   -      -       */
  /*                                 c-dist                             *//*     1**    1    *1    -   -   -     *1       */
  /* lmw    (mapdist==0)               curr  1  top  blk  len   1  0  0 *//* 12  1      1    *1    -   -   -     *1       */
  /* lmx    (mapdist!=0)               curr  1  top  blk  len   1  1  0 *//* 14  1      1     -   *1   -   -      -       */
  /*                                 c-dist                             *//*     1**    1    *1    -   -   -     *1       */
  /* lmx    (mapdist==0)               curr  1  top  blk  len   1  1  0 *//* 14  1      1    *1   *1   -   -     *1       */
  /* lmw+lmd(mapdist!=0)               curr  1  top  blk  len   1  0  0 *//* 12  1      1     -    -   -   -      -       */
  /*                                 c-dist  1 ptop  blk  len   1  0  1 *//* 13  1      1     -    -   -  *1     *1       */
  /* lmw+lmd(mapdist==0) ofs=ptop-top  curr  1  top  blk  len   1  0  1 *//* 13  1      1     -    -   1  *1     *1       */
  /* tr                                curr  1  top  -    -     1  1  1 *//* 15  -      -     -    -   -   -      -       */
  /*                                                      v&~copy:  lmmi_bitmap[c     ]=1  rw[c]||(md&&rw[c+d]&&!p[c+d]   */
  /*                                                              **lmmi_bitmap[c-dist]=1       !wr||f                    */
  /*                                                      v      : range_bitmap[c     ]=1             ofs                 */
  /*                                                             **range_bitmap[c-dist]=1                  p              */
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (lmmi[i][j].v && !(lmmx[i][j].lenv == T_IMMEDIATE && lmmi[i][j].len==0xffff) && !lmmi[i][j].hcopy && !lmmi[i][j].vcopy) {
        lmmi_bitmap[j] |= (1LL<<i);
	if (lmmi_first_loc == -1 && !lmmi[i][j].rw && !lmmi[i][j].p) /* lmrとlmfの場合,DYNAMIC_SCONの基準位置として記憶 */
	  lmmi_first_loc = i*EMAX_WIDTH+j;
	if (current_mapdist && lmmi[i][j].rw && !lmmi[i][j].p) /* lmwとlmxの場合,emax6_check_lmmi_and_dma()のためにmarkが必要 */
	  lmmi_bitmap[j] |= (1LL<<(i-current_mapdist));
	if (lmmi[i][j].cidx) { /* NCHIP間でlmm_topが異なる場合 */
	  for (c=0; c<current_nchip; c++) {
	    if (lmmx[i][j].lenv == T_IMMEDIATE) /* IMMEDIATE */
	      fprintf(ofile, "\t*(Uint*)&emax6.lmmi[%d][%d][%d][emax6.lmmic] = 0x%08.8x|(%s<<2);\n", c, i, j, *(Uint*)&lmmi[i][j], id[lmmx[i][j].forceh].name);
	    else /* VARIABLE */
	      fprintf(ofile, "\t*(Uint*)&emax6.lmmi[%d][%d][%d][emax6.lmmic] = ((%s-1)<<16)|0x%04.4x|(%s<<2);\n", c, i, j, id[lmmx[i][j].lenh].name, *(Ushort*)&lmmi[i][j], id[lmmx[i][j].forceh].name);
	    if (lmmi[i][j].ofs) /* ptophが有効の場合,topが[CHIP]ならptopも[CHIP]でなければおかしい */
	      fprintf(ofile, "\temax6.lmmi[%d][%d][%d][emax6.lmmic].ofs = (Uchar*)%s[%d] - (Uchar*)%s[%d];\n", c, i, j, (char*)lmmi[i][j].top + lmmi[i][j].ofs, c, (char*)lmmi[i][j].top, c);
	    else /* ptophが無効 */
	      fprintf(ofile, "\temax6.lmmi[%d][%d][%d][emax6.lmmic].ofs = 0;\n", c, i, j);
	    fprintf(ofile, "\temax6.lmmi[%d][%d][%d][emax6.lmmic].top = %s[%d];\n", c, i, j, (char*)lmmi[i][j].top, c);
	  }
	}
	else {  /* NCHIP間でlmm_topが共通の場合 */
	  if (lmmx[i][j].lenv == T_IMMEDIATE) /* IMMEDIATE */
	    fprintf(ofile, "\t*(Uint*)&emax6.lmmi[0][%d][%d][emax6.lmmic] = 0x%08.8x|(%s<<2);\n", i, j, *(Uint*)&lmmi[i][j], id[lmmx[i][j].forceh].name);
	  else /* VARIABLE */
	    fprintf(ofile, "\t*(Uint*)&emax6.lmmi[0][%d][%d][emax6.lmmic] = ((%s-1)<<16)|0x%04.4x|(%s<<2);\n", i, j, id[lmmx[i][j].lenh].name, *(Ushort*)&lmmi[i][j], id[lmmx[i][j].forceh].name);
	  if (lmmi[i][j].ofs) /* ptophが有効の場合,topが[CHIP]ならptopも[CHIP]でなければおかしい */
	    fprintf(ofile, "\temax6.lmmi[0][%d][%d][emax6.lmmic].ofs = (Uchar*)%s - (Uchar*)%s;\n", i, j, (char*)lmmi[i][j].top + lmmi[i][j].ofs, (char*)lmmi[i][j].top);
	  else /* ptophが無効 */
	    fprintf(ofile, "\temax6.lmmi[0][%d][%d][emax6.lmmic].ofs = 0;\n", i, j);
	  fprintf(ofile, "\temax6.lmmi[0][%d][%d][emax6.lmmic].top = %s;\n", i, j, (char*)lmmi[i][j].top);
	}
      }
      if (lmmi[i][j].v && !(lmmx[i][j].lenv == T_IMMEDIATE && lmmi[i][j].len==0xffff) && !lmmi[i][j].hcopy) {
        range_bitmap[j] |= (1LL<<i);
	if (current_mapdist && lmmi[i][j].rw && !lmmi[i][j].p) /* lmwとlmxの場合,emax6_check_lmmi_and_dma()のためにmarkが必要 */
	  range_bitmap[j] |= (1LL<<(i-current_mapdist));
      }
    }
  }
  /* lmmi_bitmap */
  for (j=0; j<EMAX_WIDTH; j++)
    fprintf(ofile, "\temax6.lmmi_bitmap[%d] = 0x%08.8x%08.8xLL;\n", j, (Uint)(lmmi_bitmap[j]>>32), (Uint)lmmi_bitmap[j]);

mode_drain_dirty_lmm:

  if (mode == 0 && !current_lmmwb) /* for transaction */
    fprintf(ofile, "\temax6_pre_with_keep_cache();\n");
  else /* for normal emax */
    fprintf(ofile, "\temax6_pre_with_drain_cache();\n");

  fprintf(ofile, "\tget_nanosec(NANOS_ARM);\n");/*=================================*/

  /* ■■■dma(drain) */
  /* mode=0,phase=1     (drain) :lmra=lmmio.top     */
  /* mode=1,phase=1     (drain) :lmra=lmmic.top     */
  if (mode == 0) { /* array */
    fprintf(ofile, "\tif (emax6.last_conf == emax6_conf_%s) {\n", id[current_prefix].name);
    fprintf(ofile, "\t  emax6.status = STATUS_DRAIN;\n");
    for (j=0; j<EMAX_WIDTH; j++) {
      for (i=0; i<EMAX_DEPTH; i++) {
	if (lmmi_bitmap[j] & (1LL<<i) && lmmi[i+current_mapdist][j].rw && !lmmi[i+current_mapdist][j].p) {
	  /* 同一conf使用の最後にemax5_drain_dirty_lmm()する前提なので,新lmmi_bitmapと,更新前RANGEの組合せでもOK */
	  /* 但し,SCON後はconf.lmm_modeがずれるので,drainの時にtag_matchしない.drainはlmmi更新後&SCON前 */
	  if (lmmi[i+current_mapdist][j].cidx) { /* NCHIP間でlmm_topが異なる場合 */
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "\t  emax6_check_lmmi_and_dma(0, 1, %d, %d, %d, %d);/*drain*/\n", current_mapdist, c, i, j); /* phase=1 drain */
	  }
	  else /* NCHIP間でlmm_topが共通の場合 */
	    fprintf(ofile, "\t  emax6_check_lmmi_and_dma(0, 1, %d, 0, %d, %d);/*drain*/\n", current_mapdist, i, j); /* phase=1 drain */
	}
      }
    }
    fprintf(ofile, "\t}\n");
  }
  else { /* drain */
    fprintf(ofile, "\t{\n");
    fprintf(ofile, "\t  struct reg_ctrl *reg_ctrl = emax6.reg_ctrl;\n");
    fprintf(ofile, "\t  Uint   lmmic              = emax6.lmmic;\n");
    fprintf(ofile, "\t  Uint   mapdist            = emax6.mapdist;\n");
    fprintf(ofile, "\t  int    c,i,j;\n");
    fprintf(ofile, "\t  emax6.status = STATUS_DRAIN;\n");
    fprintf(ofile, "\t  for (j=0; j<%d; j++) {\n", EMAX_WIDTH);
    fprintf(ofile, "\t    for (i=0; i<%d; i++) {\n", EMAX_DEPTH);
    fprintf(ofile, "\t      if (emax6.lmmi_bitmap[j] & (1LL<<i) && emax6.lmmi[0][i][j][lmmic].rw) {\n");
    fprintf(ofile, "\t        for (c=0; c<%d; c++) {\n", current_nchip);
    fprintf(ofile, "\t          if (emax6.lmmi[0][i][j][lmmic].ofs)\n");
    fprintf(ofile, "\t            *(Ull*)&(reg_ctrl->i[c].addr[i][j].top) = ((Ull)(emax6.lmmi[c][i][j][lmmic].top+*((Ushort*)&emax6.lmmi[c][i][j][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)(Uint)emax6.lmmi[c][i][j][lmmic].top;\n");
    fprintf(ofile, "\t          emax6_check_lmmi_and_dma(1, 1, mapdist, c, i, j);/*drain*/\n"); /* phase=1 drain */
    fprintf(ofile, "\t        }\n");
    fprintf(ofile, "\t      }\n");
    fprintf(ofile, "\t    }\n");
    fprintf(ofile, "\t  }\n");
    fprintf(ofile, "\t}\n");
  }

  fprintf(ofile, "\tget_nanosec(NANOS_DRAIN);\n");/*=================================*/

  if (mode == 1) { /* emit drain */
    fprintf(ofile, "#endif\n");
    return (0);
  }

  /* conf */
  fprintf(ofile, "\tif (emax6.last_conf != emax6_conf_%s) {\n", id[current_prefix].name);
  fprintf(ofile, "\t  Dll *dst, *src;\n");
  fprintf(ofile, "\t  int i,j,hard_stat,hard_depth;\n");
  fprintf(ofile, "\t  emax6.status = STATUS_CONF;\n");
#if 1
  fprintf(ofile, "\t  hard_stat  = ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat>>8 & 0xffffff0f;\n");
  fprintf(ofile, "\t  hard_depth = (hard_stat==3)?64:(hard_stat==2)?32:(hard_stat==1)?16:8;\n");
  fprintf(ofile, "\t  if (hard_depth != %d) {\n", EMAX_DEPTH);
  fprintf(ofile, "\t    printf(\"EMAX_DEPTH mismatch in emax6_conf_%s. hard_depth=%%d code_depth=%d\\n\", hard_depth);\n", id[current_prefix].name, EMAX_DEPTH);
  fprintf(ofile, "\t    exit(1);\n");
  fprintf(ofile, "\t  }\n");
#endif
  fprintf(ofile, "\t  emax6.last_conf = emax6_conf_%s;\n", id[current_prefix].name);
  fprintf(ofile, "\t  emax6.lastdist = 0;\n");
  fprintf(ofile, "\t  dst = (Dll*)(((struct reg_ctrl*)emax6.reg_ctrl)->i[0].conf);\n");
  fprintf(ofile, "\t  src = (Dll*)emax6_conf_%s;\n", id[current_prefix].name);
  fprintf(ofile, "\t  for (i=0; i<(sizeof(struct conf)*%d*%d)/sizeof(Dll); i++)\n", EMAX_DEPTH, EMAX_WIDTH);
  fprintf(ofile, "\t    *dst++ = *src++;\n");

  fprintf(ofile, "\t  for (i=0; i<%d; i++) {\n", EMAX_DEPTH);
  fprintf(ofile, "\t    for (j=0; j<%d; j++)\n", EMAX_WIDTH);
  fprintf(ofile, "\t      emax6.lmmi[0][i][j][emax6.lmmio].v = 0;\n");
  fprintf(ofile, "\t  }\n");
    
  fprintf(ofile, "\t  while (((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat & 0xffff00f0); //LMRING_BUSY \n");
  fprintf(ofile, "\t}\n");

  /* scon */
  if (current_mapdist > 0 && lmmi_first_loc >= 0) {
    int i = lmmi_first_loc/EMAX_WIDTH;
    int j = lmmi_first_loc%EMAX_WIDTH;
    fprintf(ofile, "\telse if (emax6.lmmi[0][%d][%d][emax6.lmmic].top != emax6.lmmi[0][%d][%d][emax6.lmmio].top) {\n", i, j, i, j);
    fprintf(ofile, "\t  emax6.status = STATUS_SCON;\n");
    fprintf(ofile, "\t  emax6.lastdist = emax6.mapdist;\n");
    fprintf(ofile, "\t  ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].cmd = 2LL; // SCON\n");
    fprintf(ofile, "\t  while (((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat & 0xffff000f); //EXRING_BUSY\n");
    fprintf(ofile, "\t}\n");
    fprintf(ofile, "\telse {\n");
    fprintf(ofile, "\t  emax6.lastdist = 0;\n");
    fprintf(ofile, "\t}\n");
  }

  fprintf(ofile, "\tget_nanosec(NANOS_CONF);\n");/*=================================*/

  /* breg */
  fprintf(ofile, "\temax6.status = STATUS_REGV;\n");
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      for (k=0; k<UNIT_WIDTH; k++) {
	if (regv[i][j].br[k].v) {
	  if (id[regv[i][j].br[k].h].chip) { /* CHIP */
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].breg[%d][%d].br[%d] = %d;\n", c, i, j, k, c);
	  }
	  else if (id[regv[i][j].br[k].h].cidx) { /* xxx[CHIP] */
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].breg[%d][%d].br[%d] = %s[%d];\n", c, i, j, k, id[regv[i][j].br[k].h].name, c);
	  }
	  else if (regv[i][j].br[k].s < 0)
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].breg[%d][%d].br[%d] = %s;\n", i, j, k, id[regv[i][j].br[k].h].name);
	  else
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].breg[%d][%d].br[%d] = %s[%d];\n", i, j, k, id[regv[i][j].br[k].h].name, regv[i][j].br[k].s);

	}
      }
    }
  }

  int statistics_br_tot = 0;
  int statistics_br_min = 99;
  int statistics_br_max = 0;
  int statistics_br_ave = 0;
  for (i=0; i<EMAX_DEPTH; i++) {
    int statistics_br_row = 0;
    for (j=0; j<EMAX_WIDTH; j++) {
      for (k=0; k<UNIT_WIDTH; k++) {
	if (bus[i][j].br[k].v)
	  statistics_br_row++;
      }
    }
    if (i < last_row || i == EMAX_DEPTH-1) {
      statistics_br_tot += statistics_br_row;
      if (statistics_br_row < statistics_br_min)
	statistics_br_min = statistics_br_row;
      if (statistics_br_row > statistics_br_max)
	statistics_br_max = statistics_br_row;
    }
  }
  statistics_br_ave = statistics_br_tot/(last_row<EMAX_DEPTH-1?last_row+2:last_row+1);

  int statistics_ap_tot = 0; /* emergency AR pass through */
  int statistics_ap_max = 0;
  for (i=0; i<EMAX_DEPTH; i++) {
    int statistics_ap_row = 0;
    for (j=0; j<EMAX_WIDTH; j++) {
      if (dec[i][j].dexu.op1  == OP_NOP && dec[i][j].dexu.op2  == OP_OR && dec[i][j].dexu.op3 == OP_NOP
	&&dec[i][j].dexu.ex2v == T_NONE && dec[i][j].dexu.ex3v == T_NONE
        &&dec[i][j].dexu.e2iv == T_IMMEDIATE && dec[i][j].dexu.e2ih == hash_reg_immediate(0LL)
        &&dec[i][j].dexu.e2is == 0 && dec[i][j].dexu.e2is == 0)
	statistics_ap_row++;
    }
    if (i <= last_row) {
      statistics_ap_tot += statistics_ap_row;
      if (statistics_ap_row > statistics_ap_max)
	statistics_ap_max = statistics_ap_row;
    }
  }

  /* eag */
#if 1
  fprintf(ofile, "\t{ union { Dll dll; struct {Uint ea0b; Uint ea0o; Uint ea1b; Uint ea1o;} ea4;} ea128;\n");
  for (c=0; c<current_nchip; c++) {
    for (i=0; i<EMAX_DEPTH; i++) {
      for (j=0; j<EMAX_WIDTH; j++) {
	if (c == 0) {
	  if (regv[i][j].ea0b_v) {
	    if (id[regv[i][j].ea0b_h].cidx)
	      fprintf(ofile, "\tea128.ea4.ea0b = (Ull)%s[%d];\n", id[regv[i][j].ea0b_h].name, c);
	    else if (regv[i][j].ea0b_s < 0)
	      fprintf(ofile, "\tea128.ea4.ea0b = (Ull)%s;\n", id[regv[i][j].ea0b_h].name);
	    else
	      fprintf(ofile, "\tea128.ea4.ea0b = (Ull)%s[%d];\n", id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
	  }
	  if (regv[i][j].ea0o_v) {
	    if (id[regv[i][j].ea0o_h].cidx)
	      fprintf(ofile, "\tea128.ea4.ea0o = (Ull)%s[%d];\n", id[regv[i][j].ea0o_h].name, c);
	    else if (regv[i][j].ea0o_s < 0)
	      fprintf(ofile, "\tea128.ea4.ea0o = (Ull)%s;\n", id[regv[i][j].ea0o_h].name);
	    else
	      fprintf(ofile, "\tea128.ea4.ea0o = (Ull)%s[%d];\n", id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
	  }
	  if (regv[i][j].ea1b_v) {
	    if (id[regv[i][j].ea1b_h].cidx)
	      fprintf(ofile, "\tea128.ea4.ea1b = (Ull)%s[%d];\n", id[regv[i][j].ea1b_h].name, c);
	    else if (regv[i][j].ea1b_s < 0)
	      fprintf(ofile, "\tea128.ea4.ea1b = (Ull)%s;\n", id[regv[i][j].ea1b_h].name);
	    else
	      fprintf(ofile, "\tea128.ea4.ea1b = (Ull)%s[%d];\n", id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
	  }
	  if (regv[i][j].ea1o_v) {
	    if (id[regv[i][j].ea1o_h].cidx)
	      fprintf(ofile, "\tea128.ea4.ea1o = (Ull)%s[%d];\n", id[regv[i][j].ea1o_h].name, c);
	    else if (regv[i][j].ea1o_s < 0)
	      fprintf(ofile, "\tea128.ea4.ea1o = (Ull)%s;\n", id[regv[i][j].ea1o_h].name);
	    else
	      fprintf(ofile, "\tea128.ea4.ea1o = (Ull)%s[%d];\n", id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
	  }
	  if (regv[i][j].ea0b_v || regv[i][j].ea0o_v || regv[i][j].ea1b_v || regv[i][j].ea1o_v)
	    fprintf(ofile, "\t*(Dll*)&(((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d]) = ea128.dll;\n", c, i, j);
	}
	else {
	  if (regv[i][j].ea0b_v) {
	    if (id[regv[i][j].ea0b_h].cidx)
	      fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0b = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea0b_h].name, c);
	  }
	  if (regv[i][j].ea0o_v) {
	    if (id[regv[i][j].ea0o_h].cidx)
	      fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0o = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea0o_h].name, c);
	  }
	  if (regv[i][j].ea1b_v) {
	    if (id[regv[i][j].ea1b_h].cidx)
	      fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1b = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea1b_h].name, c);
	  }
	  if (regv[i][j].ea1o_v) {
	    if (id[regv[i][j].ea1o_h].cidx)
	      fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1o = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea1o_h].name, c);
	  }
	}
      }
    }
  }
  fprintf(ofile, "\t}\n");
#else
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (regv[i][j].ea0b_v) {
	if (id[regv[i][j].ea0b_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0b = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea0b_h].name, c);
	}
	else if (regv[i][j].ea0b_s < 0)
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = (Ull)%s;\n", i, j, id[regv[i][j].ea0b_h].name);
	else
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
      }
      if (regv[i][j].ea0o_v) {
	if (id[regv[i][j].ea0o_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0o = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea0o_h].name, c);
	}
	else if (regv[i][j].ea0o_s < 0)
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = (Ull)%s;\n", i, j, id[regv[i][j].ea0o_h].name);
	else
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
      }
      if (regv[i][j].ea1b_v) {
	if (id[regv[i][j].ea1b_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1b = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea1b_h].name, c);
	}
	else if (regv[i][j].ea1b_s < 0)
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = (Ull)%s;\n", i, j, id[regv[i][j].ea1b_h].name);
	else
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
      }
      if (regv[i][j].ea1o_v) {
	if (id[regv[i][j].ea1o_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1o = (Ull)%s[%d];\n", c, i, j, id[regv[i][j].ea1o_h].name, c);
	}
	else if (regv[i][j].ea1o_s < 0)
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = (Ull)%s;\n", i, j, id[regv[i][j].ea1o_h].name);
	else
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = (Ull)%s[%d];\n", i, j, id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
      }
    }
  }
#endif

  int statistics_ea_tot = 0;
  int statistics_ea_min = 99;
  int statistics_ea_max = 0;
  int statistics_ea_ave = 0;
  for (i=0; i<EMAX_DEPTH; i++) {
    int statistics_ea_row = 0;
    for (j=0; j<EMAX_WIDTH; j++) {
      if (bus[i][j].ea0brv)
	statistics_ea_row++;
      if (bus[i][j].ea0orv)
	statistics_ea_row++;
      if (bus[i][j].ea1brv)
	statistics_ea_row++;
      if (bus[i][j].ea1orv)
	statistics_ea_row++;
    }
    if (i <= last_row) {
      statistics_ea_tot += statistics_ea_row;
      if (statistics_ea_row < statistics_ea_min)
	statistics_ea_min = statistics_ea_row;
      if (statistics_ea_row > statistics_ea_max)
	statistics_ea_max = statistics_ea_row;
    }
  }
  statistics_ea_ave = statistics_ea_tot/(last_row+1);

  fprintf(ofile, "\tget_nanosec(NANOS_REGV);\n");/*=================================*/

  /* EXEC前●lmmi指示ルール (copy from conv-c2c/emac5.c)                                                            lmmi-loc  v  top  blk  len  rw  f  p */
  /* LD with force-read=0 and ptop==NULL generates current(lmr) and reuse LMM. same as lmr in EMAX4                     curr  1  top  blk  len   0  0  0 *//* ★EXEC前にcheckし,なければDMA */
  /* LD with force-read=1 and ptop==NULL generates current(lmf) and !reuse LMM. same as lmf in EMAX4                    curr  1  top  blk  len   0  1  0 *//* ★EXEC前に,必ずDMA */
  /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist!=0                               curr  1  top  blk  len   0  0  0 *//* ★EXEC前にcheckし,なければDMA */
  /*                                                                                                                  c+dist  1 ptop  blk  len   0  0  1 *//* EXEC中に,必ずDMA(先頭はlmmi.top) */
  /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   0  0  1 *//* ★EXEC前にcheckし,なければDMA */
  /*                                                                                                               p=1の場合,pref-addrは常にlmmi.top+ofs *//* EXEC中に,必ずDMA(先頭はlmmi.top+ofs) */
  /*******************************************************************************************************************************************************/
  /* ST with force-read=0 and ptop==NULL generates current(lmw) and reuse+wback LMM. same as lmw in EMAX4               curr  1  top  blk  len   1  0  0 *//* ★EXEC前にcheckし,なければDMA */
  /* ST with force-read=1 and ptop==NULL generates current(lmx) and !reuse+wback LMM. same as lmx in EMAX4              curr  1  top  blk  len   1  1  0 *//* ★EXEC前に,必ずDMA */
  /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist!=0                               curr  1  top  blk  len   1  0  0 *//* ★EXEC前にcheckし,なければDMA */
  /*                                                                                                                  c-dist  1 ptop  blk  len   1  0  1 *//* EXEC中に,必ずDMA(先頭はlmmi.top) */
  /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   1  0  1 *//* ★EXEC前にcheckし,なければDMA */
  /*                                                                                                              p=1の場合,drain-addrは常にlmmi.top+ofs *//* EXEC中に,必ずDMA(先頭はlmmi.top+ofs) */
  fprintf(ofile, "\temax6.status = STATUS_RANGE;\n");
  fprintf(ofile, "\t{struct reg_ctrl *reg_ctrl = emax6.reg_ctrl;\n");
  fprintf(ofile, "\t Uint            lmmic     = emax6.lmmic;\n");
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (range_bitmap[j] & (1LL<<i)) {
	int source_i;
	if (lmmi_bitmap[j] & (1LL<<i))
	  source_i = i;
	else
	  source_i = range_link[i][j];
	if (lmmi[i][j].cidx) { /* NCHIP間でlmm_topが異なる場合 */
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+*((Ushort*)&emax6.lmmi[%d][%d][%d][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)(Uint)emax6.lmmi[%d][%d][%d][lmmic].top;\n", c, i, j, c, source_i, j, c, source_i, j, c, source_i, j);
	}
	else /* NCHIP間でlmm_topが共通の場合 */
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[0][%d][%d][lmmic].top+*((Ushort*)&emax6.lmmi[0][%d][%d][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)(Uint)emax6.lmmi[0][%d][%d][lmmic].top;\n", i, j, source_i, j, source_i, j, source_i, j);
      }
    }
  }
  fprintf(ofile, "\t}\n");

  fprintf(ofile, "\tget_nanosec(NANOS_RANGE);\n");/*=================================*/

  /* ■■■dma(load) */
  /*        phase=2     (load)  :lmwa=lmmic.top     */
  fprintf(ofile, "\temax6.status = STATUS_LOAD;\n");
  for (j=0; j<EMAX_WIDTH; j++) {
    for (i=0; i<EMAX_DEPTH; i++) {
      if (lmmi_bitmap[j] & (1LL<<i) && ((!lmmi[i][j].rw&&(!lmmi[i][j].p||lmmi[i][j].ofs))||(lmmi[i][j].rw&&lmmi[i][j].f))) { /* lmr,lmf,lmx */
	if (lmmi[i][j].cidx) { /* NCHIP間でlmm_topが異なる場合 */
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 2, emax6.lastdist, %d, %d, %d);/*load*/\n", mode, c, i, j); /* phase=2 load */
	}
	else /* NCHIP間でlmm_topが共通の場合 */
	  fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 2, emax6.lastdist, 0, %d, %d);/*load*/\n", mode, i, j); /* phase=2 load */
      }
    }
  }

  fprintf(ofile, "\tget_nanosec(NANOS_LOAD);\n");/*=================================*/

  /* confは1wayあたり,32B*16行=0.5KB,32B*64行=2KB(最大). 4way分連続にするには,16行で2KB,64行で8KBアラインが必要. ZYNQのpage-sizeが8KB以上であればOK */

  /* EXEC中●lmmi指示ルール (copy from conv-c2c/emac5.c)                                                            lmmi-loc  v  top  blk  len  rw  f  p */
  /* LD with force-read=0 and ptop==NULL generates current(lmr) and reuse LMM. same as lmr in EMAX4                     curr  1  top  blk  len   0  0  0 *//* EXEC前にcheckし,なければDMA */
  /* LD with force-read=1 and ptop==NULL generates current(lmf) and !reuse LMM. same as lmf in EMAX4                    curr  1  top  blk  len   0  1  0 *//* EXEC前に,必ずDMA */
  /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist!=0                               curr  1  top  blk  len   0  0  0 *//* EXEC前にcheckし,なければDMA */
  /*                                                                                                                  c+dist  1 ptop  blk  len   0  0  1 *//* ★EXEC中に,必ずDMA(先頭はlmmi.top) */
  /* LD with force-read=0 and ptop!=NULL generates current(lmr) and next(lmp). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   0  0  1 *//* EXEC前にcheckし,なければDMA */
  /*                                                                                                               p=1の場合,pref-addrは常にlmmi.top+ofs *//* ★EXEC中に,必ずDMA(先頭はlmmi.top+ofs) */
  /*******************************************************************************************************************************************************/
  /* ST with force-read=0 and ptop==NULL generates current(lmw) and reuse+wback LMM. same as lmw in EMAX4               curr  1  top  blk  len   1  0  0 *//* EXEC前にcheckし,なければDMA */
  /* ST with force-read=1 and ptop==NULL generates current(lmx) and !reuse+wback LMM. same as lmx in EMAX4              curr  1  top  blk  len   1  1  0 *//* EXEC前に,必ずDMA */
  /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist!=0                               curr  1  top  blk  len   1  0  0 *//* EXEC前にcheckし,なければDMA */
  /*                                                                                                                  c-dist  1 ptop  blk  len   1  0  1 *//* ★EXEC中に,必ずDMA(先頭はlmmi.top) */
  /* ST with force-read=0 and ptop!=NULL generates current(lmw) and prev(lmd). mapdist==0                  ofs=ptop-top curr  1  top  blk  len   1  0  1 *//* EXEC前にcheckし,なければDMA */
  /*                                                                                                              p=1の場合,drain-addrは常にlmmi.top+ofs *//* ★EXEC中に,必ずDMA(先頭はlmmi.top+ofs) */
  fprintf(ofile, "\t{struct reg_ctrl *reg_ctrl = emax6.reg_ctrl;\n");
  fprintf(ofile, "\t Uint            lmmic     = emax6.lmmic;\n");
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (range_bitmap[j] & (1LL<<i) && lmmi[i][j].ofs) {
	int source_i;
	if (lmmi_bitmap[j] & (1LL<<i))
	  source_i = i;
	else
	  source_i = range_link[i][j];
	if (lmmi[i][j].cidx) { /* NCHIP間でlmm_topが異なる場合 */
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+emax6.lmmi[%d][%d][%d][lmmic].ofs+*((Ushort*)&emax6.lmmi[%d][%d][%d][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)(Uint)(emax6.lmmi[%d][%d][%d][lmmic].top+emax6.lmmi[%d][%d][%d][lmmic].ofs);\n", c, i, j, c, source_i, j, c, source_i, j, c, source_i, j, c, source_i, j, c, source_i, j);
	}
	else /* NCHIP間でlmm_topが共通の場合 */
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[0][%d][%d][lmmic].top+emax6.lmmi[0][%d][%d][lmmic].ofs+*((Ushort*)&emax6.lmmi[0][%d][%d][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)(Uint)(emax6.lmmi[0][%d][%d][lmmic].top+emax6.lmmi[0][%d][%d][lmmic].ofs);\n", i, j, source_i, j, source_i, j, source_i, j, source_i, j, source_i, j);
      }
    }
  }
  fprintf(ofile, "\t}\n");

  /* exec */
  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].cmd = 3LL; // EXEC\n");

  /* ■■■dma(pdrain) */
  /* ■■■dma(pload) */
  /*        phase=3,rw=1(pdrain):lmra=lmmic.top+ofs */
  /*        phase=3,rw=0(pload) :lmwa=lmmic.top+ofs */
  for (j=0; j<EMAX_WIDTH; j++) {
    for (i=0; i<EMAX_DEPTH; i++) {
      if (lmmi_bitmap[j] & (1LL<<i) && lmmi[i][j].p) {
	if (lmmi[i][j].cidx) { /* NCHIP間でlmm_topが異なる場合 */
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, %d, %d, %d);/*pdrain,pload*/\n", mode, current_mapdist, c, i, j); /* phase=3 exec */
	}
	else /* NCHIP間でlmm_topが共通の場合 */
	  fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, 0, %d, %d);/*pdrain,pload*/\n", mode, current_mapdist, i, j); /* phase=3 exec */
      }
    }
  }

  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (lmmi_bitmap[j] & (1LL<<i) && lmmi[i][j].rw && !lmmi[i][j].p) /* ●6 lmw/lmx */
	fprintf(ofile, "\temax6.lmmd[%d][%d] = 0xff>>%d;\n", i, j, sizeof(Uchar)*8-current_nchip); /* set dirty */
    }
  }

  fprintf(ofile, "\twhile (((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat & 0xffff00ff); //LMRING_BUSY|EXRING_BUSY\n");

  fprintf(ofile, "\tget_nanosec(NANOS_EXEC);\n");/*=================================*/

  /* term */
  fprintf(ofile, "asm volatile(\"b emax6_conf_end_%s\\n\"\n\".align 5\\n\"\n\".global emax6_conf_%s\\n\"\n\"emax6_conf_%s:\\n\"\n", id[current_prefix].name, id[current_prefix].name, id[current_prefix].name, id[current_prefix].name);
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      fprintf(ofile, "\"\t.word\t0x%08.8x, 0x%08.8x\\n\"\n", *(Ull*)&conf[i][j].cdw0, (Uint)((*(Ull*)&conf[i][j].cdw0)>>32));
      fprintf(ofile, "\"\t.word\t0x%08.8x, 0x%08.8x\\n\"\n", *(Ull*)&conf[i][j].cdw1, (Uint)((*(Ull*)&conf[i][j].cdw1)>>32));
      fprintf(ofile, "\"\t.word\t0x%08.8x, 0x%08.8x\\n\"\n", *(Ull*)&conf[i][j].cdw2, (Uint)((*(Ull*)&conf[i][j].cdw2)>>32));
      fprintf(ofile, "\"\t.word\t0x%08.8x, 0x%08.8x\\n\"\n", *(Ull*)&conf[i][j].cdw3, (Uint)((*(Ull*)&conf[i][j].cdw3)>>32));
    }
  }
  fprintf(ofile, "\".global emax6_conf_end_%s\\n\"\n\"emax6_conf_end_%s:\\n\"\n", id[current_prefix].name, id[current_prefix].name);
  fprintf(ofile, ");\n");
  fprintf(ofile, "#endif\n");
  /**********************************************************************************************************/
  /* Step 9 ... emit tgif                                                                                   */
  /**********************************************************************************************************/
  strncpy(figfile = (char*)malloc(strlen(srcprog)+1+strlen(id[current_prefix].name)+strlen(FIGSUFX)+1), srcprog, strlen(srcprog)+1); /* xxx.x -> xxx-func.obj */
  for (i=0; i<strlen(srcprog); i++) {
    if (figfile[i] == '.' || figfile[i] == '\0' ) {
      strncpy(figfile+i, "-", 2);
      strncat(figfile, id[current_prefix].name, strlen(id[current_prefix].name)+1);
      strncat(figfile, FIGSUFX, strlen(FIGSUFX)+1);
      break;
    }
  }

  /* open fig-file */
  if ((ffile = fopen(figfile, "w")) == NULL) {
    fprintf(stderr, "can't open object:\"%s\"\n", figfile);
    exit(1);
  }

  /* generate fig-file */
  fprintf(ffile, "%%TGIF 4.1.45-QPL\n");
  fprintf(ffile, "state(0,37,100.000,0,0,1,16,1,9,1,1,0,0,1,0,1,0,'Ryumin-Light-EUC-H',0,80640,0,0,1,5,0,0,1,1,0,16,0,0,1,1,1,1,8100,9500,1,0,19000,0).\n");
  fprintf(ffile, "%%\n");
  fprintf(ffile, "unit(\"1 pixel/pixel\").\n");
  fprintf(ffile, "color_info(11,65535,0,[\n");
  fprintf(ffile, "  \"magenta\", 65535, 0, 65535, 65535, 0, 65535, 1,\n");
  fprintf(ffile, "  \"red\", 65535, 0, 0, 65535, 0, 0, 1,\n");
  fprintf(ffile, "  \"green\", 0, 65535, 0, 0, 65535, 0, 1,\n");
  fprintf(ffile, "  \"blue\", 0, 0, 65535, 0, 0, 65535, 1,\n");
  fprintf(ffile, "  \"yellow\", 65535, 65535, 0, 65535, 65535, 0, 1,\n");
  fprintf(ffile, "  \"pink\", 65535, 49344, 52171, 65535, 49344, 52171, 1,\n");
  fprintf(ffile, "  \"cyan\", 0, 65535, 65535, 0, 65535, 65535, 1,\n");
  fprintf(ffile, "  \"CadetBlue\", 24415, 40606, 41120, 24415, 40606, 41120, 1,\n");
  fprintf(ffile, "  \"white\", 65535, 65535, 65535, 65535, 65535, 65535, 1,\n");
  fprintf(ffile, "  \"black\", 0, 0, 0, 0, 0, 0, 1,\n");
  fprintf(ffile, "  \"DarkSlateGray\", 12079, 20303, 20303, 12079, 20303, 20303, 1\n");
  fprintf(ffile, "]).\n");
  fprintf(ffile, "script_frac(\"0.6\").\n");
  fprintf(ffile, "fg_bg_colors('black','white').\n");
  fprintf(ffile, "dont_reencode(\"FFDingbests:ZapfDingbats\").\n");
  fprintf(ffile, "objshadow_info('#c0c0c0',2,2).\n");
  fprintf(ffile, "page(1,\"\",1,'').\n");
  draw_text(100, 100, figfile, 5, 0);

  char statistics[1024];
  snprintf(statistics, 1024, "BR/row: max=%d min=%d ave=%d", statistics_br_max, statistics_br_min, statistics_br_ave);
  draw_text(100, 200, statistics, 4, 0);
  snprintf(statistics, 1024, "EA/row: max=%d min=%d ave=%d", statistics_ea_max, statistics_ea_min, statistics_ea_ave);
  draw_text(1200, 200, statistics, 4, 0);
  snprintf(statistics, 1024, "ARpass/row: max=%d", statistics_ap_max);
  draw_text(2300, 200, statistics, 4, 0);

  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      emit_tgif(i, j);
    }
  }

  /* close fig-file */
  fclose(ffile);
  free(figfile);

  return (0);
}

/*****************************************************************************************/
/*****************************************************************************************/
/*****************************************************************************************/

get_mop_type(int op)
{
  int retval;
  switch (op) {
  case OP_LDR:
  case OP_LDWR:
//case OP_LDHR:
  case OP_LDBR:
  case OP_LDRQ:
    retval = MTYPE_RLOAD; /* random_load on mop1->BR (+implicit AXI->mop0->MW) */
    break;
  case OP_STR:
  case OP_STWR:
//case OP_STHR:
  case OP_STBR:
  case OP_STRQ:
    retval = MTYPE_RSTORE; /* random_store on mop0->MW (+implicit mop1->MR->AXI) */
    break;
  case OP_LDDMQ:
    retval = MTYPE_DLOAD; /* direct_load on mop0->MW,MR->AXI->TR->BR (+implicit mop1->MR->AXI) */
    break;
  case OP_TR:
    retval = MTYPE_TRANS; /* transaction on mop0->MW,MR->AXI (+implicit mop1->MR->AXI) */
    break;
  }

  return (retval);
}

get_valid_row(int insn_type, int mid, int src_type, int src_hash, char *rdep)
{
  /* mid:0 ... refer at the top    of UNIT (                 EXE->store_addr) */
  /* mid:1 ... refer at the middle of UNIT (CEX->store_cond, EXE->store_data) */
  int i, j;

  switch (src_type) {
  case T_NONE:
  case T_IMMEDIATE:
    /* do nothing */
    break;
  case T_EXRNO: /* for cex in same unit */
  case T_ALRNO:
  case T_BDRNO:    /* for boundary reg */
  case T_VARIABLE: /* for any variable */
    switch (id[src_hash].itype) { /* 当該srcを生成する先行命令タイプ */
    case ITYPE_CEX:
      if (*rdep < id[src_hash].row) /* loc of new_insn < loc of dst_reg */
        *rdep = id[src_hash].row; /* same row ★CEX+CMOV/MOP */
      break;
    case ITYPE_WHILE:
    case ITYPE_FOR:
    case ITYPE_EX4:
    case ITYPE_EXE:
      if (insn_type == ITYPE_MO4 ||  insn_type == ITYPE_MOP) { /* 後続命令タイプ MO4 || MOP */
        if (mid==0) { /* EXE->store_addr */
          if (id[src_hash].row >= 0) { /* if defined as dst in EMAX */
            if (*rdep <= id[src_hash].row) /* loc of new_insn < loc of dst_reg */
              *rdep = id[src_hash].row+1; /* next row */
          }
        }
        else { /* EXE->store_data */
          if (*rdep < id[src_hash].row) /* loc of new_insn < loc of dst_reg */
            *rdep = id[src_hash].row; /* same row ★EXE+MOPの組合せは同一UNIT収容可能 */
        }
      }
      else { /* 後続命令タイプ ITYPE_WHILE || ITYPE_FOR || ITYPE_CEX || ITYPE_EX4 || ITYPE_EXE */
        if (id[src_hash].row >= 0) { /* if defined as dst in EMAX */
          if (*rdep <= id[src_hash].row) /* loc of new_insn < loc of dst_reg */
            *rdep = id[src_hash].row+1; /* next row */
        }
      }
      break;
    case ITYPE_MEX:
      if (insn_type == ITYPE_MO4 ||  insn_type == ITYPE_MOP) { /* 後続命令タイプ MO4 || MOP */
	if (*rdep < id[src_hash].row) /* loc of new_insn < loc of dst_reg */
	  *rdep = id[src_hash].row; /* same row ★EXE+MOPの組合せは同一UNIT収容可能 */
      }
      else {
        if (id[src_hash].row >= 0) { /* if defined as dst in EMAX */
          if (*rdep <= id[src_hash].row) /* loc of new_insn < loc of dst_reg */
            *rdep = id[src_hash].row+1; /* next row */
        }
      }
      break;
    case ITYPE_MO4:
    case ITYPE_MOP:
      if (id[src_hash].row >= 0) { /* if defined as dst in EMAX */
        if (*rdep <= id[src_hash].row) /* loc of new_insn < loc of dst_reg */
          *rdep = id[src_hash].row+1; /* next row */
      }
      break;
    }
    break;
  }
  /* printf("in get_valid: rdep=%d\n", *rdep); */
}

set_reg_path(int last_row, int last_col, int folding, int insn_type, int reg_type, int reg_loc, int src_type, int src_hash, int src_sidx)
     /* last_row:  配置先行位置 */
     /* last_col:  配置先列位置 */
     /* insn_type: 命令種別     ITYPE_WHILE, ITYPE_FOR, ITYPE_CEX, ITYPE_EX4, ITYPE_EXE, ITYPE_MEX, ITYPE_MO4, ITYPE_MOP */
     /* reg_type:  ITYPE_MEX/ITYPE_MO4/ITYPE_MOPの場合のみ有効: レジスタ種別 RTYPE_DATA, RTYPE_BASE, RTYPE_OFFS */
     /* reg_loc:   ITYPE_MEX/ITYPE_MO4/ITYPE_MOPの場合のみ有効: MO4/MOPのbase/offsの位置 0:mop0, 1:mop1 */
     /* src_type:  T_NONE, T_IMMEDIATE, T_EXRNO, T_ALRNO, T_BDRNO, T_INITNO, T_LOOPNO, T_VARIABLE */
     /* src_hash:  id[src_hash] */
     /* src_sidx:  subindex of VAR[]/AR[]/BR[] */
     /* 固定値設定用ARMコード生成,および,busmap設定 */
{
  int i, j, k, h, w;

  if (src_type == T_NONE) /* T_NONE */
    return 0;
  if (src_type == T_EXRNO) /* T_EXRNOは同一UNITにて消費するため，busmap不要 */
    return 0;
  if (id[src_hash].row < 0) { /* initialized by ARM (T_IMMEDIATE, T_VARIABLE) */
    if (insn_type == ITYPE_MEX || insn_type == ITYPE_MO4 || insn_type == ITYPE_MOP) { /* store4/store1 */
      switch (reg_type) {
      case RTYPE_DATA:
        printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot store constant variable %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
        exit(1);
      case RTYPE_BASE:
        if (reg_loc==0) {
          if (bus[last_row][last_col].ea0brv) {
            printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
            exit(1);
          }
          bus[last_row][last_col].ea0brv = src_type;
          bus[last_row][last_col].ea0brh = src_hash;
          bus[last_row][last_col].ea0drv = src_type;
          bus[last_row][last_col].ea0drh = src_hash;
	  regv[last_row][last_col].ea0b_v = src_type;
	  regv[last_row][last_col].ea0b_h = src_hash;
	  regv[last_row][last_col].ea0b_s = src_sidx;
        }
        else {
          if (bus[last_row][last_col].ea1brv) {
            printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
            exit(1);
          }
          bus[last_row][last_col].ea1brv = src_type;
          bus[last_row][last_col].ea1brh = src_hash;
          bus[last_row][last_col].ea1drv = src_type;
          bus[last_row][last_col].ea1drh = src_hash;
	  regv[last_row][last_col].ea1b_v = src_type;
	  regv[last_row][last_col].ea1b_h = src_hash;
	  regv[last_row][last_col].ea1b_s = src_sidx;
        }
        break;
      case RTYPE_OFFS: /* prefetch/drainの設定にも使用（値は,バイトアドレスで64bit*4が1単位,即ち32. N+1回参照し,alignされていない場合でもFSMが調整）*/
        if (reg_loc==0) {
          if (bus[last_row][last_col].ea0orv) {
            printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
            exit(1);
          }
          bus[last_row][last_col].ea0orv = src_type;
          bus[last_row][last_col].ea0orh = src_hash;
	  regv[last_row][last_col].ea0o_v = src_type;
	  regv[last_row][last_col].ea0o_h = src_hash;
	  regv[last_row][last_col].ea0o_s = src_sidx;
        }
        else {
          if (bus[last_row][last_col].ea1orv) {
            printf("in %s: [%d][%d] ITYPE_MEX/ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
            exit(1);
          }
          bus[last_row][last_col].ea1orv = src_type;
          bus[last_row][last_col].ea1orh = src_hash;
	  regv[last_row][last_col].ea1o_v = src_type;
	  regv[last_row][last_col].ea1o_h = src_hash;
	  regv[last_row][last_col].ea1o_s = src_sidx;
        }
        break;
      }
    }
    else { /* (insn_type == ITYPE_WHILE || insn_type == ITYPE_FOR || insn_type == ITYPE_CEX || insn_type == ITYPE_EX4 || insn_type == ITYPE_EXE) */
      if (folding)
	h = last_row;
      else
	h = (last_row+EMAX_DEPTH-1)%EMAX_DEPTH; /* 直前段出力BR[][][0-3]の空きを探し,ARMが直接セット */
      /* find same BR1 */
      for (j=0; j<EMAX_WIDTH; j++) {
        for (k=0; k<UNIT_WIDTH; k++) {
          if (bus[h][j].br[k].v==src_type && bus[h][j].br[k].h==src_hash && bus[h][j].br[k].s==src_sidx) /* already set */
            return 0; /* found & do nothing */
        }
      }
      /* find empty BR1 */
      for (j=0; j<EMAX_WIDTH; j++) {
        for (k=0; k<UNIT_WIDTH; k++) {
          if (k==2 && bus[h][j].exdrv && (bus[h][j].exdrh != src_hash))
            continue; /* ★★★ AR->EXDR->BR伝搬にBR[2]を使用する可能性があるので当面避ける ★★★ */
          if (!bus[h][j].br[k].v) { /* empty BR1 found */
            bus[h][j].br[k].v = src_type;
            bus[h][j].br[k].h = src_hash;
            bus[h][j].br[k].s = src_sidx;
            /* generate C-code to copy C-var to emax6_xx_regv[x][y].xxx before all EMAX6 code */
	    regv[h][j].br[k].v = src_type;
	    regv[h][j].br[k].h = src_hash;
	    regv[h][j].br[k].s = src_sidx;
            return 0; /* generate ARM->BR */
          }
        }
      }
      printf("in %s: [%d][%d] cannot find BR1 for %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
      exit(1);
    }
  }
  else { /* initialized by previous row (T_ALRNO, T_BDRNO, T_VARIABLE) */
    h = id[src_hash].row; /* 開始段のみ対象 */
    /* 開始段 < last_row かつ src=ARなら開始段のBRまで持ってくる */
    if (h < last_row) {
      if (id[src_hash].itype == ITYPE_EX4) { /* 同一UNITのTRに集約し直下のBRへ */
        /* find same TR4+BR4 */
        for (j=0; j<EMAX_WIDTH; j++) {
          for (k=0; k<UNIT_WIDTH; k++) {
            if (!(bus[h][j].tr[k].v==src_type && bus[h][j].tr[k].h==src_hash && bus[h][j].tr[k].s==k
               && bus[h][j].br[k].v==src_type && bus[h][j].br[k].h==src_hash && bus[h][j].br[k].s==k)) /* miss */
              break;
          }
          if (k >= UNIT_WIDTH)
            goto srp_ar_br_ready; /* found & proceed */
        }
        /* find empty TR4+BR4 */
        for (j=0; j<EMAX_WIDTH; j++) {
#if 1
          /* LMM-bufferingのためには，伝搬REGがLMP対象UNITに混在してはダメ */
          if (lmmi[h][j].v && !lmmi[h][j].rw && lmmi[h][j].p) /* conflict with lmm pload */
            continue;
#endif
          for (k=0; k<UNIT_WIDTH; k++) {
            if (bus[h][j].tr[k].v || bus[h][j].br[k].v) /* inuse */
              break;
          }
          if (k >= UNIT_WIDTH) { /* empty TR4+BR4 found */
            for (k=0; k<UNIT_WIDTH; k++) {
              bus[h][j].tr[k].v = src_type;
              bus[h][j].tr[k].h = src_hash;
              bus[h][j].tr[k].s = k;
              bus[h][j].br[k].v = src_type;
              bus[h][j].br[k].h = src_hash;
              bus[h][j].br[k].s = k;
            }
            conf[h][j].cdw2.brs0 = 2; /* 2:tr0 */
            conf[h][j].cdw2.brs1 = 2; /* 2:tr1 */
            conf[h][j].cdw2.brs2 = 2; /* 2:tr2 */
            conf[h][j].cdw2.brs3 = 2; /* 2:tr3 */
            goto srp_ar_br_ready; /* found & proceed */
          }
        }
        printf("in %s: [%d][%d] cannot find TR4+BR4 for %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
        exit(1);
      }
      else if (id[src_hash].itype == ITYPE_EXE) { /* 変数が個別EXE演算結果の場合，各EXEのEXDRを経由しBR[2]に接続 */
        /* find same BR[2] */
        j = id[src_hash].col; /* ★★★ id[src_hash].colの参照箇所はここのみ．ITYPE_EXEの場合,VAR[c],AR[r][c]に対して,j=-1 (同一行に複数) */
        if (j<0)        /* exe->&VARの場合,j=last_colがセットされている */
          j = src_sidx; /* exe->VAR[c],AR[r][c]をバラで使う場合,j=-1がセットされている */
        /* printf("h=%d j=%d name=%s | v=%d srctype=%d h=%d srchash=%d s=%d srcidx=%d\n", h, j, id[src_hash].name, bus[h][j].br[2].v, src_type, bus[h][j].br[2].h, src_hash, bus[h][j].br[2].s, src_sidx);*/
        if (bus[h][j].br[2].v==src_type && bus[h][j].br[2].h==src_hash && bus[h][j].br[2].s==src_sidx) /* already set */
          goto srp_ar_br_ready; /* found & proceed */
        /* find empty BR[2] */
        if (!bus[h][j].br[2].v) { /* empty BR[2] found */
          bus[h][j].br[2].v = src_type;
          bus[h][j].br[2].h = src_hash;
          bus[h][j].br[2].s = src_sidx;
          conf[h][j].cdw2.brs2 = 3; /* 3:exdr */
          goto srp_ar_br_ready; /* found & proceed */
        }
        printf("in %s: [%d][%d] cannot find BR[2] for %s (BR[2] is occupied by %s)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name, id[bus[h][j].br[2].h].name);
        exit(1);
      }
      else if (id[src_hash].itype == ITYPE_MEX) { /* 変数がMEXのea0woofs/ea1woofs出力の場合，各々BR[3],BR[2]に接続 */
        j = id[src_hash].col;
        if (j<0)        /* exe->&VARの場合,j=last_colがセットされている */
          j = src_sidx; /* exe->VAR[c],AR[r][c]をバラで使う場合,j=-1がセットされている */
        if (bus[h][j].ea0woofsv==src_type && bus[h][j].ea0woofsh==src_hash) {
	  //printf("------ea0woofs h=%d j=%d name=%s | v=%d srctype=%d h=%d srchash=%d s=%d srcidx=%d\n", h, j, id[src_hash].name, bus[h][j].br[2].v, src_type, bus[h][j].br[2].h, src_hash, bus[h][j].br[2].s, src_sidx);
	  if (bus[h][j].br[2].v==src_type && bus[h][j].br[2].h==src_hash && bus[h][j].br[2].s==src_sidx) /* already set */
	    goto srp_ar_br_ready; /* found & proceed */
	  /* find empty BR[2] */
	  if (!bus[h][j].br[2].v) { /* empty BR[2] found */
	    bus[h][j].br[2].v = src_type;
	    bus[h][j].br[2].h = src_hash;
	    bus[h][j].br[2].s = src_sidx;
	    conf[h][j].cdw2.brs2 = 3; /* 3:exdr(brs3=3の場合,ea0woofsに接続) */
	    goto srp_ar_br_ready; /* found & proceed */
	  }
	  printf("in %s: [%d][%d] cannot find BR[2] for %s (BR[2] is occupied by %s)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name, id[bus[h][j].br[2].h].name);
	  exit(1);
	}
        else if (bus[h][j].ea1woofsv==src_type && bus[h][j].ea1woofsh==src_hash) {
	  //printf("------ea1woofs h=%d j=%d name=%s | v=%d srctype=%d h=%d srchash=%d s=%d srcidx=%d\n", h, j, id[src_hash].name, bus[h][j].br[3].v, src_type, bus[h][j].br[3].h, src_hash, bus[h][j].br[3].s, src_sidx);
	  if (bus[h][j].br[3].v==src_type && bus[h][j].br[3].h==src_hash && bus[h][j].br[3].s==src_sidx) /* already set */
	    goto srp_ar_br_ready; /* found & proceed */
	  /* find empty BR[3] */
	  if (!bus[h][j].br[3].v) { /* empty BR[3] found */
	    bus[h][j].br[3].v = src_type;
	    bus[h][j].br[3].h = src_hash;
	    bus[h][j].br[3].s = src_sidx;
	    conf[h][j].cdw2.brs3 = 3; /* 3:ea1woofs */
	    goto srp_ar_br_ready; /* found & proceed */
	  }
	  printf("in %s: [%d][%d] cannot find BR[3] for %s (BR[3] is occupied by %s)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name, id[bus[h][j].br[3].h].name);
	  exit(1);
	}
	else {
	  printf("in %s: [%d][%d] cannot find MEX ea0woofs/ea1woofs for %s)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
	  exit(1);
	}
      }
    }
srp_ar_br_ready:

    /* その後,last_row前段まで必要なら,開始段BRをTR+BRにより伝搬 */
    for (h=id[src_hash].row+1; h<(folding?last_row+1:last_row); h++) { /* 途中まで,伝搬レジスタtr[][]とbr[][]を使用 */
      if ((insn_type == ITYPE_EX4 || insn_type == ITYPE_MO4) && reg_type == RTYPE_DATA) { /* multiple use (ex4/store4) */
	/* find same TR4+BR4 */
	for (j=0; j<EMAX_WIDTH; j++) {
	  for (k=0; k<UNIT_WIDTH; k++) {
	    if (!(bus[h][j].tr[k].v==src_type && bus[h][j].tr[k].h==src_hash && bus[h][j].tr[k].s==k
               && bus[h][j].br[k].v==src_type && bus[h][j].br[k].h==src_hash && bus[h][j].br[k].s==k)) /* miss */
	      break;
	  }
	  if (k >= UNIT_WIDTH)
	    goto srp_tr_br_ready; /* found & proceed */
	}
	/* find empty TR4+BR4 */
	for (j=0; j<EMAX_WIDTH; j++) {
#if 1
	  /* LMM-bufferingのためには，伝搬REGがLMP対象UNITに混在してはダメ */
	  if (lmmi[h][j].v && !lmmi[h][j].rw && lmmi[h][j].p) /* conflict with lmm pload */
	    continue;
#endif
	  for (k=0; k<UNIT_WIDTH; k++) {
	    if (bus[h][j].tr[k].v || bus[h][j].br[k].v) /* inuse */
	      break;
	  }
	  if (k >= UNIT_WIDTH) { /* empty TR4+BR4 found */
            for (k=0; k<UNIT_WIDTH; k++) {
	      bus[h][j].tr[k].v = src_type;
	      bus[h][j].tr[k].h = src_hash;
	      bus[h][j].tr[k].s = k;
	      bus[h][j].br[k].v = src_type;
	      bus[h][j].br[k].h = src_hash;
	      bus[h][j].br[k].s = k;
	    }
            conf[h][j].cdw2.brs0 = 2; /* 2:tr0 */
	    conf[h][j].cdw2.brs1 = 2; /* 2:tr1 */
	    conf[h][j].cdw2.brs2 = 2; /* 2:tr2 */
	    conf[h][j].cdw2.brs3 = 2; /* 2:tr3 */
	    goto srp_tr_br_ready; /* found & proceed */
	  }
	}
	printf("in %s: [%d][%d] cannot find TR4+BR4 for %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
	exit(1);
      }
      else { /* (insn_type == ITYPE_WHILE || insn_type == ITYPE_FOR || insn_type == ITYPE_CEX || insn_type == ITYPE_EXE || insn_type == ITYPE_MOP) *//* single use */
        /* find same TR1+BR1 */
        for (j=0; j<EMAX_WIDTH; j++) {
          for (k=0; k<UNIT_WIDTH; k++) {
            if (bus[h][j].tr[k].v==src_type && bus[h][j].tr[k].h==src_hash && bus[h][j].tr[k].s==src_sidx
             && bus[h][j].br[k].v==src_type && bus[h][j].br[k].h==src_hash && bus[h][j].br[k].s==src_sidx) /* hit */
              goto srp_tr_br_ready; /* found & proceed */
          }
        }
        /* find empty TR1+BR1 */
        for (j=0; j<EMAX_WIDTH; j++) {
#if 1
          /* LMM-bufferingのためには，伝搬REGがLMP対象UNITに混在してはダメ */
          if (lmmi[h][j].v && !lmmi[h][j].rw && lmmi[h][j].p) /* conflict with lmm pload */
            continue;
#endif
          for (k=0; k<UNIT_WIDTH; k++) {
            if (k==2 && bus[h][j].exdrv && (bus[h][j].exdrh != src_hash))
              continue; /* ★★★ AR->EXDR->BR伝搬にBR[2]を使用する可能性があるので当面避ける ★★★ */
            if (!bus[h][j].tr[k].v && !bus[h][j].br[k].v) { /* empty */
	      if (!bus[h][j].mw[k].v || search_prev_ar0_mw(h, j, k, bus[h][j].mw[k].v, bus[h][j].mw[k].h, bus[h][j].mw[k].s) >= 0) { /* 自unit内にsrcの場合はtr競合無し */
		bus[h][j].tr[k].v = src_type;
		bus[h][j].tr[k].h = src_hash;
		bus[h][j].tr[k].s = src_sidx;
		bus[h][j].br[k].v = src_type;
		bus[h][j].br[k].h = src_hash;
		bus[h][j].br[k].s = src_sidx;
		switch (k) {
		case 0: conf[h][j].cdw2.brs0 = 2; /* 2:tr0 */ break;
		case 1: conf[h][j].cdw2.brs1 = 2; /* 2:tr1 */ break;
		case 2: conf[h][j].cdw2.brs2 = 2; /* 2:tr2 */ break;
		case 3: conf[h][j].cdw2.brs3 = 2; /* 2:tr3 */ break;
		}
		goto srp_tr_br_ready; /* found & proceed */
	      }
	      else { /* 前unitにsrcがあると，tr競合有りのため回避必要 */
		continue;
	      }
            }
          }
        }
        /* find same emergency bypass through EXE+EXDR+BR[2] */
        for (j=0; j<EMAX_WIDTH; j++) {
          if (!dec[h][j].dexu.op1 && dec[h][j].dexu.op2 == OP_OR && !dec[h][j].dexu.op3
           && bus[h][j].exdrv   == src_type && bus[h][j].exdrh   == src_hash && bus[h][j].exdrs   == src_sidx
           && bus[h][j].br[2].v == src_type && bus[h][j].br[2].h == src_hash && bus[h][j].br[2].s == src_sidx) {
            goto srp_tr_br_ready;
          }
        }
        /* find empty emergency bypass through EXE+EXDR+BR[2] */
        for (j=0; j<EMAX_WIDTH; j++) {
          if (!dec[h][j].dexu.op1 && !dec[h][j].dexu.op2 && !dec[h][j].dexu.op3
           && !bus[h][j].exdrv && !bus[h][j].br[2].v) {
            dec[h][j].dexu.op1  = OP_NOP;
            dec[h][j].dexu.op2  = OP_OR;
            dec[h][j].dexu.op3  = OP_NOP;
            dec[h][j].dexu.updt = 0;
            dec[h][j].dexu.init = 0;
            dec[h][j].dexu.ex1v = src_type;
            dec[h][j].dexu.ex1h = src_hash;
            dec[h][j].dexu.ex1s = src_sidx;
            dec[h][j].dexu.ex1e = EXP_H3210;
            dec[h][j].dexu.ex2v = T_NONE;
            dec[h][j].dexu.ex2h = -1;
            dec[h][j].dexu.ex2s = -1;
            dec[h][j].dexu.ex2e = 0;
            dec[h][j].dexu.ex3v = T_NONE;
            dec[h][j].dexu.ex3h = -1;
            dec[h][j].dexu.ex3s = -1;
            dec[h][j].dexu.ex3e = 0;
            dec[h][j].dexu.e2iv = T_IMMEDIATE;
            dec[h][j].dexu.e2ih = hash_reg_immediate(0LL);
            dec[h][j].dexu.e2is = 0; /* e2imm */
            dec[h][j].dexu.e3iv = T_NONE;
            dec[h][j].dexu.e3ih = -1;
            dec[h][j].dexu.e3is = 0; /* e3imm */
            dec[h][j].dexu.exdv = src_type;
            dec[h][j].dexu.exdh = src_hash;
            dec[h][j].dexu.exds = src_sidx;
            bus[h][j].exdrv     = src_type;
            bus[h][j].exdrh     = src_hash;
            bus[h][j].exdrs     = src_sidx;
            bus[h][j].br[2].v   = src_type;
            bus[h][j].br[2].h   = src_hash;
            bus[h][j].br[2].s   = src_sidx;
            conf[h][j].cdw2.brs2 = 3; /* 3:exdr */
            goto srp_tr_br_ready;
          }
        }
        /* find empty TR1+BR1 */
	/* ★★★ どうしてもない場合,BR[2]を使用 ★★★ */
        for (j=0; j<EMAX_WIDTH; j++) {
#if 1
          /* LMM-bufferingのためには，伝搬REGがLMP対象UNITに混在してはダメ */
          if (lmmi[h][j].v && !lmmi[h][j].rw && lmmi[h][j].p) /* conflict with lmm pload */
            continue;
#endif
          for (k=0; k<UNIT_WIDTH; k++) {
            if (!bus[h][j].tr[k].v && !bus[h][j].br[k].v) { /* empty */
	      if (!bus[h][j].mw[k].v || search_prev_ar0_mw(h, j, k, bus[h][j].mw[k].v, bus[h][j].mw[k].h, bus[h][j].mw[k].s) >= 0) { /* 自unit内にsrcの場合はtr競合無し */
		bus[h][j].tr[k].v = src_type;
		bus[h][j].tr[k].h = src_hash;
		bus[h][j].tr[k].s = src_sidx;
		bus[h][j].br[k].v = src_type;
		bus[h][j].br[k].h = src_hash;
		bus[h][j].br[k].s = src_sidx;
		switch (k) {
		case 0: conf[h][j].cdw2.brs0 = 2; /* 2:tr0 */ break;
		case 1: conf[h][j].cdw2.brs1 = 2; /* 2:tr1 */ break;
		case 2: conf[h][j].cdw2.brs2 = 2; /* 2:tr2 */ break;
		case 3: conf[h][j].cdw2.brs3 = 2; /* 2:tr3 */ break;
		}
		goto srp_tr_br_ready; /* found & proceed */
	      }
	      else { /* 前unitにsrcがあると，tr競合有りのため回避必要 */
		continue;
	      }
            }
          }
        }
        printf("in %s: [%d][%d] cannot find TR1+BR1 for %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
        exit(1);
      }
srp_tr_br_ready:
      continue;
    }
  }
}

search_prev_br0(int row, int folding, int src_type, int src_hash, int src_sidx)
{
  /* return 0-3:br[][0].br[0-3], 4-7:br[][1].br[0-3], 8-11:br[][2].br[0-3], 12-15:br[][3].br[0-3] */
  /* return 0 and warn if not found */
  int i, j;

  if (!folding)
    row = (row+EMAX_DEPTH-1)%EMAX_DEPTH;
  if (src_type) {
    for (i=0; i<EMAX_WIDTH; i++) {
      for (j=0; j<UNIT_WIDTH; j++) {
        if (bus[row][i].br[j].v == src_type && bus[row][i].br[j].h == src_hash && bus[row][i].br[j].s == src_sidx)
          return (i*UNIT_WIDTH + j);
      }
    }
    printf("in %s: [%d][] (folding=%d) cannot find source bus[%d][].br[] for %s sidx=%d (malfunction)\n", id[current_prefix].name, row, folding, row, id[src_hash].name, src_sidx);
    exit(1);
  }
  return (0);
}

search_prev_ar0_tr(int row, int col, int pos, int src_type, int src_hash, int src_sidx)
{
  /* col=0 ... return 0:lmwd0, 1:exdr, 2:ts0 */
  /* col=1 ... return 0:lmwd1, 1:exdr, 2:ts1 */
  /* col=2 ... return 0:lmwd2. 1:exdr, 2:ts2 */
  /* col=3 ... return 0:lmwd3, 1:exdr, 2:ts3 */
  /* return -1 if not found */
  int i, j;

  /* tsX使用の伝搬設定(retval=2)はsearch_prev_br0の後に設定 */
  if (src_type) {
    if (bus[row][pos].exdrv       == src_type && bus[row][pos].exdrh       == src_hash && bus[row][pos].exdrs       == src_sidx) return (1); /* EX4->TR4->BR4 */
    if (bus[row][col].lmwd[pos].v == src_type && bus[row][col].lmwd[pos].h == src_hash && bus[row][col].lmwd[pos].s == src_sidx) return (0); /* LDDMQ */
    return (-1);
  }
  else
    return (0);
}

search_prev_ar0_mw(int row, int col, int pos, int src_type, int src_hash, int src_sidx)
{
  /* col=0 ... return 0:lmwd0, 1:exdr, 2:ts0 */
  /* col=1 ... return 0:lmwd1, 1:exdr, 2:ts1 */
  /* col=2 ... return 0:lmwd2, 1:exdr, 2:ts2 */
  /* col=3 ... return 0:lmwd3, 1:exdr, 2:ts3 */
  /* return -1 if not found */
  int i, j;

  /* tsX使用の伝搬設定(retval=2)はsearch_prev_br0の後に設定 */
  if (src_type) {
    if (bus[row][col].exdrv       == src_type && bus[row][col].exdrh       == src_hash && bus[row][col].exdrs       == src_sidx) return (1);
    if (bus[row][pos].exdrv       == src_type && bus[row][pos].exdrh       == src_hash && bus[row][pos].exdrs       == src_sidx) return (1);
    if (bus[row][col].lmwd[pos].v == src_type && bus[row][col].lmwd[pos].h == src_hash && bus[row][col].lmwd[pos].s == src_sidx) return (0);
    return (-1);
  }
  else
    return (0);
}

emit_emax6t(int type) /* 0:transaction */
{
  int i, j, l;

  for (i=0; i<=trans_pc; i++) {
    tconf[i].rw            = trans[i].rw;
    tconf[i].base_type     = trans[i].base_type;
    tconf[i].offset_type   = trans[i].offset_type;
    tconf[i].offset        = trans[i].offset;
    tconf[i].offset_suffix = trans[i].offset_suffix;
    tconf[i].offset_sll    = trans[i].offset_sll;
    tconf[i].op_type       = trans[i].op_type;
    tconf[i].op_val_type   = trans[i].op_val_type > 0;
    tconf[i].t_action_type = trans[i].t_action_type;
    tconf[i].t_action      = trans[i].t_action;
    tconf[i].f_action_type = trans[i].f_action_type;
    tconf[i].f_action      = trans[i].f_action;
    tconf[i].reg_type      = trans[i].reg_type;
    fprintf(ofile, "\t.word\t0x%08.8x /* tconf[%d].word0 */\n", *(Uint*)&tconf[i], i);
    if (trans[i].base_type == 2)
      fprintf(ofile, "%s\t.word\t0x%08.8x /* tconf[%d].base */\n", trans[i].base_symbol, trans[i].base_num, i);
    else
      fprintf(ofile, "\t.word\t0x%08.8x /* tconf[%d].base */\n", trans[i].base_num, i);
    if (trans[i].op_val_type == 2)
      fprintf(ofile, "%s\t.word\t0x%08.8x /* tconf[%d].op_val */\n", trans[i].op_val_symbol, trans[i].op_val_num, i);
    else
      fprintf(ofile, "\t.word\t0x%08.8x /* tconf[%d].op_val */\n", trans[i].op_val_num, i);
    if (trans[i].reg_type == 1)
      fprintf(ofile, "%s\t.word\t0x%08.8x /* tconf[%d].reg */\n", trans[i].reg_symbol, trans[i].reg_num, i);
    else
      fprintf(ofile, "\t.word\t0x%08.8x /* tconf[%d].reg */\n", trans[i].reg_num, i);
  }
}

emit_tgif(int i, int j)
{
  int k;
  int base_row = (i%16) * 540  + 300;
  int base_col = (i/16) * 2020 + ((EMAX_WIDTH-1)-j) * 500;
  int bro_x = base_col,     bro_y = base_row+10;
  int aro_x = base_col,     aro_y = base_row+210;
  int lmi_x = base_col,     lmi_y = base_row+280;
  int exb_x = base_col+70,  exb_y = base_row+160;
  int cxb_x = base_col+20,  cxb_y = base_row+160;
  int e0b_x = base_col+320, e0b_y = base_row+170;
  int e1b_x = base_col+200, e1b_y = base_row+170;
  int trb_x = base_col+60,  trb_y = base_row+350;
  int lmb_x = base_col+40,  lmb_y = base_row+380;
  int bri_x = base_col+40,  bri_y = base_row+530;

  for (k=0; k<EMAX_WIDTH*UNIT_WIDTH; k++)
    draw_bro(i, j, bro_x, bro_y, k);

  draw_aro(i, j, aro_x, aro_y);

  for (k=0; k<UNIT_WIDTH+1; k++)
    draw_lmi(i, j, lmi_x, lmi_y, k);

  draw_exe(exb_x, exb_y,
           conf[i][j].cdw0.op1,    /*:  6; alu_opcd */
           conf[i][j].cdw0.op2,    /*:  3; logical_opcd */
           conf[i][j].cdw0.op3,    /*:  3; sft_opcd */
           conf[i][j].cdw0.init,   /*:  2; conditional exec on INIT1/INI10 */
           conf[i][j].cdw0.fold,   /*:  1; 0:normal, 1:load-exe-store folding */
           conf[i][j].cdw0.ex1brs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
           conf[i][j].cdw0.ex1s,   /*:  1; 0:ex1brs, 1:exdr(self-loop) */
           conf[i][j].cdw0.ex1exp, /*:  3; 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
           conf[i][j].cdw0.ex2brs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
           conf[i][j].cdw0.ex2exp, /*:  3; 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
           conf[i][j].cdw0.ex3brs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
           conf[i][j].cdw0.ex3exp, /*:  3; 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
           conf[i][j].cdw3.e2imm,  /*: 64; */
           conf[i][j].cdw0.e2is,   /*:  2; 0:e2imm, 1:ex2, 2:ex3 */
           conf[i][j].cdw0.e3imm,  /*:  E3IMMBITS; */
           conf[i][j].cdw0.e3is    /*:  1; 0:e3imm, 1:ex3 */
           );

  draw_cex(cxb_x, cxb_y,
           conf[i][j].cdw1.cs0,    /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
           conf[i][j].cdw1.cs1,    /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
           conf[i][j].cdw1.cs2,    /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
           conf[i][j].cdw1.cs3,    /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
           conf[i][j].cdw1.cex_tab /*: 16; c3.c2.c1.c0の組合せ (cop=NOPの場合,ffff) */
                                   /* 1111,1110,1101,1100,....,0001,0000 の各々に0/1を割り当てた16bitを指定 */
           );

  draw_ea0(e0b_x, e0b_y,
           conf[i][j].cdw1.ea0op,   /*:  5; mem_opcd */
           conf[i][j].cdw1.ea0bs,   /*:  2; 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
           conf[i][j].cdw1.ea0os,   /*:  1; 0:ea0or, 1:eaobrs */
           conf[i][j].cdw1.ea0msk,  /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
           conf[i][j].cdw1.eabbrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
           conf[i][j].cdw1.eaobrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
	   conf[i][j].cdw0.mex0op,  /* mex(sparse matrix) conditional 0:NOP, 1:AL, 2:OP_CMPA_LE, 3:OP_CMPA_GE */
	   conf[i][j].cdw0.mex0init,/* mex(sparse matrix) 0:none, 1:INIT0? */
	   conf[i][j].cdw0.mex0dist,/* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
	   conf[i][j].cdw0.mexlimit /* limit 0:0, 1:8, 2:16, .... 10:4096, 11:8192, 12:16384, 13:32768 */
           );

  draw_ea1(e1b_x, e1b_y,
           conf[i][j].cdw1.ea1op,   /*:  5; mem_opcd */
           conf[i][j].cdw1.ea1bs,   /*:  2; 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
           conf[i][j].cdw1.ea1os,   /*:  1; 0:ea1or, 1:eaobrs */
           conf[i][j].cdw1.ea1msk,  /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
           conf[i][j].cdw1.eabbrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
           conf[i][j].cdw1.eaobrs,  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
	   conf[i][j].cdw0.mex1op,  /* mex(sparse matrix) conditional 0:NOP, 1:AL, 2:OP_CMPA_LE, 3:OP_CMPA_GE */
	   conf[i][j].cdw0.mex1init,/* mex(sparse matrix) 0:none, 1:INIT0? */
	   conf[i][j].cdw0.mex1dist,/* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
	   conf[i][j].cdw0.mexlimit /* limit 0:0, 1:8, 2:16, .... 10:4096, 11:8192, 12:16384, 13:32768 */
           );

  draw_trx(trb_x, trb_y,
           bus[i][j].tr[0].v,
           bus[i][j].tr[1].v,
           bus[i][j].tr[2].v,
           bus[i][j].tr[3].v,
           conf[i][j].cdw2.ts0,    /*:  4; 0:br0_0, 1:br0_1, ... 15:br3_3 */
           conf[i][j].cdw2.ts1,    /*:  4; 0:br0_0, 1:br0_1, ... 15:br3_3 */
           conf[i][j].cdw2.ts2,    /*:  4; 0:br0_0, 1:br0_1, ... 15:br3_3 */
           conf[i][j].cdw2.ts3,    /*:  4; 0:br0_0, 1:br0_1, ... 15:br3_3 */
           conf[i][j].cdw2.trs0,   /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
           conf[i][j].cdw2.trs1,   /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
           conf[i][j].cdw2.trs2,   /*:  2; 0:lmwd2. 1:exdr, 2:ts2 */
           conf[i][j].cdw2.trs3    /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
           );

  draw_lmx(lmb_x, lmb_y,
	   lmmi[i][j].v,           /*:  1; valid */
           conf[i][j].cdw1.ea0op,  /*:  5; mem_opcd */
           conf[i][j].cdw2.mwsa,   /*:  1; 0:lmwa,  1:ea0d        */
           conf[i][j].cdw2.mws0,   /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
           conf[i][j].cdw2.mws1,   /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
           conf[i][j].cdw2.mws2,   /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
           conf[i][j].cdw2.mws3,   /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
           conf[i][j].cdw2.ts0,
           conf[i][j].cdw2.ts1,
           conf[i][j].cdw2.ts2,
           conf[i][j].cdw2.ts3,
           conf[i][j].cdw2.lmm_mode,/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
           lmmi[i][j].top
           );

  draw_bri(bri_x, bri_y,
           conf[i][j].cdw1.ea0op,  /*:  5; mem_opcd */
           conf[i][j].cdw1.ea1op,  /*:  5; mem_opcd */
           conf[i][j].cdw2.brs0,   /*:  2; 0:off, 1:mr10, 2:tr0, 3:mr0  */
           conf[i][j].cdw2.brs1,   /*:  2; 0:off, 1:mr11, 2:tr1, 3:mr1  */
           conf[i][j].cdw2.brs2,   /*:  2; 0:off, 1:mr12, 2:tr2, 3:exdr */
           conf[i][j].cdw2.brs3,   /*:  2; 0:off, 1:mr13, 2:tr3         */
           bus[i][j].br[0].v,
           bus[i][j].br[0].h,
           bus[i][j].br[0].s,
           bus[i][j].br[1].v,
           bus[i][j].br[1].h,
           bus[i][j].br[1].s,
           bus[i][j].br[2].v,
           bus[i][j].br[2].h,
           bus[i][j].br[2].s,
           bus[i][j].br[3].v,
           bus[i][j].br[3].h,
           bus[i][j].br[3].s
           );

  draw_lmr(bri_x, bri_y,
           bus[i][j].lmrd[0].v,
           bus[i][j].lmrd[1].v,
           bus[i][j].lmrd[2].v,
           bus[i][j].lmrd[3].v
           );
}

/*    0   50   100  150  200  250  300  350  400  450  500 */
/*   0+----+----+----+----+----+----+----+----+----+----+  */
/*  10  |||| :  |  |  |  :---------| :         | :   BOBASE*/
/*  15  |||| :  |  |  |  :---------| :         | :         */
/*  20  |||| :  |  |  |  :---------| :         | :         */
/*  25  |||| :  |  |  |  :---------| :         | :         */
/*  30  |||| :  |  |  |  :---------| :         | :         */
/*  35  |||| :  |  |  |  :---------| :         | :         */
/*  40  |||| :  |  |  |  :---------| :         | :         */
/*  45  |||| :  |  |  |  :---------| :         | :         */
/*  50  |||| :  |  |  |  :---------| :         | :         */
/*  55  |||| :  |  |  |  :---------| :         | :         */
/*  60  |||| :  |  |  |  :---------| :         | :         */
/*  65  |||| :  |  |  |  :---------| :         | :         */
/*  70  |||| :  |  |  |  :---------| :         | :         */
/*  75  |||| :  |  |  |  :---------| :         | :         */
/*  80  |||| :  |  |  |  :---------| :         | :         */
/*  85  |||| :  |  |  |  :---------| :         | :         */
/*  90  |||| :  |  |  |  :         | :         | :         */
/* 100  |||| :  |  |  |  :   +-----*-----+     | :         */
/* 110  |||| :  |  |  |  :   |     +-----------+ :         */
/* 120  |||| :  |  |  |  :   |     | :   |     | :         */
/* 130  |||| :  |  |  |  :+---+ +---+:+---+ +---+:         */
/* 140  |||| :  |  |  |  :+-*-+ +-*-+:+---+ +---+:         */
/* 150  |||| :  -  -  -  :  ||    || :  ||    || :         */
/* 160  +--+ +-----------+  --    -- :  --    -- :   EXBASE*/
/* 170  |  | :\ A       /:+---------+:+---------+:         */
/* 180  |  | : \|      / : \A      / : \A      / :         */
/* 190  +--+ |  +--*--+  |  +--*--+  |  +--*--+  |         */
/* 200       |  |  |     |  |  |     |  |  |     |         */
/* 210       |  |  |     |  |  |     |  |  |    *|-  AOBASE*/
/* 215       |  |  |     |  |  |    *|  |  |    ||-        */
/* 220       |  |  |    *|  |  |    ||  |  |    ||-        */
/* 225      *|  |  |    ||  |  |    ||  |  |    ||-        */
/* 230   --*||--|--*---*||---------*||---------*||-        */
/* 260     |||  |  |   |||  |  |   |||  |  |   |||         */
/* 270     |||+<|  |   |||+<|  |+  |||+<|  |+  |||+<       */
/* 280   --||||--------||||--------||||------**|||*  LIBASE*/
/* 285   --||||--------||||------**|||*------||||||        */
/* 290   --||||------**|||*------||||||------||||||        */
/* 295   **|||*------||||||------||||||------||||||        */
/* 300   ||||||------||||||------||||||-----*||||||        */
/* 310   |||||| |  | |||||| |  |||||||| |  ||||||||        */
/* 320   ****** |  | ****** |  ||****** |  ||******        */
/* 330     | || |  |   | || |  ||  | || |  ||  | ||        */
/* 340     | ** |  |   | ** |  ||  | ** |  ||  | **        */
/* 350     |+*+ | +*+  |+*+ | +*+  |+*+ | +*+  |+*+  TRBASE*/
/* 360     |+*+ | +*+  |+*+ | +*+  |+*+ | +*+  |+*+        */
/* 370     | |  +--*   | |  +--*   | |  +--*   | |         */
/* 380  : +*----+  |  +*----+ +*+ +*----+ +*+ +*----+LMBASE*/
/* 390  : +-----+  |  +-----+ +-+ +-----+ +-+ +-----+      */
/* 400       |     |     |     |     |     |     |         */
/* 410    +-----+  |  +-----+  |  +-----+  |  +-----+      */
/* 420    |-----|  |  |-----|  |  |-----|  |  |-----|      */
/* 430    |-----|  |  |-----|  |  |-----|  |  |-----|      */
/* 440    +---**+  |  +---**+  |  +---**+  |  +---**+      */
/* 450       |||   +-+   |||   |     ||+-------++||+       */
/* 460       |||     |   ||+---------||-------+||||        */
/* 470       ||+-----|-- ||----------||------+|||||        */
/* 480       ||      |   |*-------++-|*    | ||||||        */
/* 500       |*------|---||------+||+||------|||||*        */
/* 510       ||      *--*||    +>*--*||    +>*--*||        */
/* 520       |+>        ||+>        ||+>   |    ||+>       */
/* 530    +--**-+     +-***-+     +-***-+  V  +-***-+BIBASE*/
/* 540    +-----+     +-----+     +-----+     +-----+      */

draw_bro(int i, int j, int bro_x, int bro_y, int num)
{
  int col, thi;
  i = (i+EMAX_DEPTH-1)%EMAX_DEPTH;

  /* BR0-0..3-3 */
  switch (bus[i][num/UNIT_WIDTH].br[num%UNIT_WIDTH].v) {
  case 0: /* T_NONE */
    col=0; /*black*/
    thi=1;
    break;
  case 1: /* T_IMMEDIATE */
    col=4; /*blue*/
    thi=3;
    break;
  case 2: /* T_EXRNO */
    col=5; /*magenta*/
    thi=3;
    break;
  case 3: /* T_ALRNO */
    col=3; /*yellow*/
    thi=3;
    break;
  case 4: /* T_BDRNO */
    col=1; /*red*/
    thi=3;
    break;
  case 7: /* T_VARIABLE */
    col=2; /*green*/
    thi=3;
    break;
  default:
    col=6; /*cyan*/
    thi=3;
    break;
  }
  draw_line(bro_x,  bro_y+num*5, bro_x+500,  bro_y+num*5, thi, col);
}

draw_aro(int i, int j, int aro_x, int aro_y)
{
  int col, thi;

  /* AR0..EXD */
  switch (bus[i][j].exdrv) {
  case 0: /* T_NONE */
    col=0; /*black*/
    thi=1;
    break;
  case 1: /* T_IMMEDIATE */
    col=4; /*blue*/
    thi=3;
    break;
  case 2: /* T_EXRNO */
    col=5; /*magenta*/
    thi=3;
    break;
  case 3: /* T_ALRNO */
    col=3; /*yellow*/
    thi=3;
    break;
  case 4: /* T_BDRNO */
    col=1; /*red*/
    thi=3;
    break;
  case 7: /* T_VARIABLE */
    col=2; /*green*/
    thi=3;
    break;
  default:
    col=6; /*cyan*/
    thi=3;
    break;
  }
  draw_line(aro_x,  aro_y+20, aro_x+500,  aro_y+20, thi, col);
}

draw_lmi(int i, int j, int lmi_x, int lmi_y, int num)
{
  int col, thi;
  int lmiall;

  /* LMI */
  if (num < UNIT_WIDTH) { /* lmwd */
    lmiall = bus[i][j].lmwd[num].v;
    switch (lmiall) {
    case 0: /* T_NONE */
      col=0; /*black*/
      thi=1;
      break;
    case 1: /* T_IMMEDIATE */
      col=4; /*blue*/
      thi=3;
      break;
    case 2: /* T_EXRNO */
      col=5; /*magenta*/
      thi=3;
      break;
    case 3: /* T_ALRNO */
      col=3; /*yellow*/
      thi=3;
      break;
    case 4: /* T_BDRNO */
      col=1; /*red*/
      thi=3;
      break;
    case 7: /* T_VARIABLE */
      col=2; /*green*/
      thi=3;
      break;
    default:
      col=6; /*cyan*/
      thi=3;
      break;
    }
    draw_line(lmi_x,  lmi_y+num*5, lmi_x+500,  lmi_y+num*5, thi, col);
  }
  else { /* lmwa */
    lmiall = bus[i][j].lmwd[0].v;
    switch (lmiall) {
    case 0: /* T_NONE */
      col=0; /*black*/
      thi=1;
      break;
    case 1: /* T_IMMEDIATE */
      col=4; /*blue*/
      thi=3;
      break;
    case 2: /* T_EXRNO */
      col=5; /*magenta*/
      thi=3;
      break;
    case 3: /* T_ALRNO */
      col=3; /*yellow*/
      thi=3;
      break;
    case 4: /* T_BDRNO */
      col=1; /*red*/
      thi=3;
      break;
    case 7: /* T_VARIABLE */
      col=2; /*green*/
      thi=3;
      break;
    default:
      col=6; /*cyan*/
      thi=3;
      break;
    }
    draw_line(lmi_x,  lmi_y+num*5, lmi_x+500,  lmi_y+num*5, thi, col);
  }
}

draw_exe(int exb_x, int exb_y,
         int op1,    /*:  6; alu_opcd */
         int op2,    /*:  3; logical_opcd */
         int op3,    /*:  3; sft_opcd */
	 int init,   /*:  2; conditional exec on INIT1/INI10 */
         int fold,   /*:  1; 0:normal, 1:load-exe-store folding */
         int ex1brs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
         int ex1s,   /*:  1; 0:ex1brs, 1:exdr(self-loop) */
         int ex1exp, /*:  3; 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
         int ex2brs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
         int ex2exp, /*:  3; 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
         int ex3brs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
         int ex3exp, /*:  3; 0:H3210, 1:H1010, 2:H3232, 3:B5410, 4:B7632 */
         Ull e2imm,  /*: 64; */
         int e2is,   /*:  2; 0:e2imm, 1:ex2, 2:ex3 */
         int e3imm,  /*:  E3IMMBITS; */
         int e3is    /*:  1; 0:e3imm, 1:ex3 */
         )
{
#define EXLABELMAX 30
  char opcd[EXLABELMAX];
  int col, thi;

  /* ALU */
  if (op1 || op2 || op3) {
    col=5; /*magenta*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line(exb_x+20,  exb_y-10, exb_x+40,  exb_y-10, thi, col);
  draw_line(exb_x+50,  exb_y-10, exb_x+70,  exb_y-10, thi, col);
  draw_line(exb_x+80,  exb_y-10, exb_x+100, exb_y-10, thi, col);
  draw_line(exb_x,     exb_y,    exb_x+120, exb_y,    thi, col);
  draw_line(exb_x+120, exb_y,    exb_x+90,  exb_y+30, thi, col);
  draw_line(exb_x+90,  exb_y+30, exb_x+30,  exb_y+30, thi, col);
  draw_line(exb_x+30,  exb_y+30, exb_x,     exb_y,    thi, col);
  snprintf(opcd, EXLABELMAX, "%02.2x%01.1x%01.1x-%01.1x-%01.1x", op1, op2, op3, init, fold);
  draw_text(exb_x+35, exb_y+15, opcd, 1, col);
  if (e2is == 0) {
    snprintf(opcd, EXLABELMAX, "%08.8x", (Uint)(e2imm>>32));
    draw_text(exb_x-50, exb_y+45, opcd, 1, col);
    snprintf(opcd, EXLABELMAX, "%08.8x", (Uint)e2imm);
    draw_text(exb_x+35, exb_y+45, opcd, 1, col);
  }
  if (e3is == 0) {
    snprintf(opcd, EXLABELMAX, "%08.8x", e3imm);
    draw_text(exb_x+35, exb_y+30, opcd, 1, col);
  }
  draw_line (exb_x+60, exb_y+30,              exb_x+60, exb_y+190,     thi, col);
  draw_box  (exb_x+50, exb_y+190,             exb_x+70, exb_y+200,     thi, col);

  /* SRC1 */
  if (op1 || op2 || op3) {
    col=5; /*magenta*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_arrow(exb_x+30, exb_y-160+ex1brs*5+10, exb_x+30, exb_y-160+150, thi, col);
  if (ex1s) { /* feedback-loop */
    col=5; /*magenta*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line (exb_x+60, exb_y+200,             exb_x+60, exb_y+210,     thi, col);
  draw_line (exb_x+60, exb_y+210,             exb_x+30, exb_y+210,     thi, col);
  draw_arrow(exb_x+30, exb_y+210,             exb_x+30, exb_y-10,      thi, col);
  /* SRC2 */
  if (op1 || op2 || op3) {
    col=5; /*magenta*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_arrow(exb_x+60, exb_y-160+ex2brs*5+10, exb_x+60, exb_y-160+150, thi, col);
  /* SRC3 */
  if (op1 || op2 || op3) {
    col=5; /*magenta*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_arrow(exb_x+90, exb_y-160+ex3brs*5+10, exb_x+90, exb_y-160+150, thi, col);
}

draw_cex(int cxb_x, int cxb_y,
         int cs0,    /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
         int cs1,    /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
         int cs2,    /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
         int cs3,    /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
         int cex_tab /*: 16; c3.c2.c1.c0の組合せ (cop=NOPの場合,ffff) */
                     /* 1111,1110,1101,1100,....,0001,0000 の各々に0/1を割り当てた16bitを指定 */
         )
{
#define CXLABELMAX 30
  char opcd[CXLABELMAX];
  int col, thi;

  /* CEX */
  if (cex_tab != 0xffff) {
    col=2; /*green*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (cxb_x-10, cxb_y, cxb_x+40, cxb_y+30, thi, col);
  snprintf(opcd, CXLABELMAX, "%04.4x", cex_tab);
  draw_text(cxb_x, cxb_y+20, opcd, 1, 0);

  /* SRC1 */
  if (cex_tab != 0xffff) {
    col=2; /*green*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_arrow(cxb_x+30, cxb_y-160+cs0*5+10, cxb_x+30, cxb_y-5,  thi, col);
  /* SRC2 */
  if (cex_tab != 0xffff) {
    col=2; /*green*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_arrow(cxb_x+20, cxb_y-160+cs1*5+10, cxb_x+20, cxb_y-5, thi, col);
  /* SRC3 */
  if (cex_tab != 0xffff) {
    col=2; /*green*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_arrow(cxb_x+10, cxb_y-160+cs2*5+10, cxb_x+10, cxb_y-5, thi, col);
  /* SRC4 */
  if (cex_tab != 0xffff) {
    col=2; /*green*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_arrow(cxb_x+0,  cxb_y-160+cs3*5+10, cxb_x+0,  cxb_y-5, thi, col);
}

draw_ea0(int e0b_x, int e0b_y,
         int ea0op,  /*:  5; mem_opcd */
         int ea0bs,  /*:  2; 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
         int ea0os,  /*:  1; 0:ea0or, 1:eaobrs */
         int ea0msk, /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
         int eabbrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
         int eaobrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
	 int mex0op,
	 int mex0init,
	 int mex0dist,
	 int mexlimit
         )
{
#define E0LABELMAX 80
  char opcd[E0LABELMAX];
  int col, thi;
  int ea0singleload = (ea0op && (ea0op <= OP_LDBR));

  /* EA0 */
  if (ea0op&0x10) {
    col=1; /*red*/
    thi=3;
  }
  else if (ea0op) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line(e0b_x+10,  e0b_y-10, e0b_x+30,  e0b_y-10, thi, col);
  draw_line(e0b_x+70,  e0b_y-10, e0b_x+90,  e0b_y-10, thi, col);
  draw_line(e0b_x,     e0b_y,    e0b_x+100, e0b_y,    thi, col);
  draw_line(e0b_x+100, e0b_y,    e0b_x+80,  e0b_y+20, thi, col);
  draw_line(e0b_x+80,  e0b_y+20, e0b_x+20,  e0b_y+20, thi, col);
  draw_line(e0b_x+20,  e0b_y+20, e0b_x,     e0b_y,    thi, col);
  snprintf(opcd, E0LABELMAX, "%02.2x", ea0op);
  draw_text(e0b_x+35, e0b_y+15, opcd, 1, col);
  draw_line (e0b_x+50, e0b_y+20,              e0b_x+50, e0b_y+180,     thi, col);
  draw_box  (e0b_x+40, e0b_y+180,             e0b_x+60, e0b_y+190,     thi, col);
  draw_line (e0b_x+50, e0b_y+190,             e0b_x+50, e0b_y+210,     thi, col);
  draw_box  (e0b_x+40, e0b_y+210,             e0b_x+60, e0b_y+220,     thi, col);
  if (ea0singleload) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line (e0b_x+55, e0b_y+190,             e0b_x+55, e0b_y+340,     thi, col);
  draw_arrow(e0b_x+55, e0b_y+340,             e0b_x+65, e0b_y+340,     thi, col);
  draw_line (e0b_x+65, e0b_y+340,             e0b_x+100,e0b_y+340,     thi, col);

  /* SRC1 */
  if (ea0op && !(ea0bs & 2)) { /* ea0br */
    col=1; /*red*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (e0b_x,    e0b_y-40, e0b_x+40, e0b_y-30, thi, col);
  draw_arrow(e0b_x+20, e0b_y-30, e0b_x+20, e0b_y-10, thi, col);
  if (ea0op && (ea0bs & 2)) { /* eabbrs */
    col=1; /*red*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line (e0b_x-30, e0b_y-170+eabbrs*5+10, e0b_x-30, e0b_y-70, thi, col);
  draw_line (e0b_x-30, e0b_y-70,              e0b_x+30, e0b_y-70, thi, col);
  draw_arrow(e0b_x+30, e0b_y-70,              e0b_x+30, e0b_y-10, thi, col);

  /* feedback-loop */
  if (ea0bs & 1) {
    col=1; /*red*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line (e0b_x+50, e0b_y+190,             e0b_x+50, e0b_y+200,     thi, col);
  draw_line (e0b_x+50, e0b_y+200,             e0b_x+20, e0b_y+200,     thi, col);
  draw_arrow(e0b_x+20, e0b_y+200,             e0b_x+20, e0b_y-10,      thi, col);

  /* mex-loop */
  if (mex0op==OP_CMPA_LE || mex0op==OP_CMPA_GE) {
    col=2; /*green*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line (e0b_x+65, e0b_y+360,             e0b_x+80, e0b_y+360,     thi, col);
  draw_arrow(e0b_x+65, e0b_y+360,             e0b_x+65, e0b_y-40,      thi, col);
  snprintf(opcd, E0LABELMAX, "%s-%d-%d-%d", mex0op==OP_ALWAYS?"AL":mex0op==OP_CMPA_LE?"LE":mex0op==OP_CMPA_GE?"GE":"NA", mex0init, mex0dist, mexlimit);
  draw_text(e0b_x+30, e0b_y-40, opcd, 1, 0);

  /* SRC2 */
  if (ea0op && !(ea0os & 1)) { /* ea0or */
    col=1; /*red*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (e0b_x+60, e0b_y-40, e0b_x+100, e0b_y-30, thi, col);
  draw_arrow(e0b_x+80, e0b_y-30, e0b_x+80,  e0b_y-10, thi, col);
  if (ea0op && (ea0os & 1)) { /* eaobrs */
    col=1; /*red*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line (e0b_x+90, e0b_y-170+eaobrs*5+10, e0b_x+90, e0b_y-70, thi, col);
  draw_arrow(e0b_x+90, e0b_y-70,              e0b_x+90, e0b_y-10, thi, col);
}

draw_ea1(int e1b_x, int e1b_y,
         int ea1op,  /*:  5; mem_opcd */
         int ea1bs,  /*:  2; 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(self-loop) */
         int ea1os,  /*:  1; 0:ea1or, 1:eaobrs */
         int ea1msk, /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
         int eabbrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
         int eaobrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
	 int mex1op,
	 int mex1init,
	 int mex1dist,
	 int mexlimit
         )
{
#define E1LABELMAX 80
  char opcd[E1LABELMAX];
  int col, thi;
  int ea1singleload = (ea1op && (ea1op <= OP_LDBR));

  /* EA1 */
  if (ea1op) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line(e1b_x+10,  e1b_y-10, e1b_x+30,  e1b_y-10, thi, col);
  draw_line(e1b_x+70,  e1b_y-10, e1b_x+90,  e1b_y-10, thi, col);
  draw_line(e1b_x,     e1b_y,    e1b_x+100, e1b_y,    thi, col);
  draw_line(e1b_x+100, e1b_y,    e1b_x+80,  e1b_y+20, thi, col);
  draw_line(e1b_x+80,  e1b_y+20, e1b_x+20,  e1b_y+20, thi, col);
  draw_line(e1b_x+20,  e1b_y+20, e1b_x,     e1b_y,    thi, col);
  snprintf(opcd, E1LABELMAX, "%02.2x", ea1op);
  draw_text(e1b_x+35, e1b_y+15, opcd, 1, col);
  draw_line (e1b_x+50, e1b_y+20,              e1b_x+50, e1b_y+180,     thi, col);
  draw_box  (e1b_x+40, e1b_y+180,             e1b_x+60, e1b_y+190,     thi, col);
  draw_line (e1b_x+50, e1b_y+190,             e1b_x+50, e1b_y+210,     thi, col);
  draw_box  (e1b_x+40, e1b_y+210,             e1b_x+60, e1b_y+220,     thi, col);
  if (ea1singleload) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line (e1b_x+55, e1b_y+190,             e1b_x+55, e1b_y+340,     thi, col);
  draw_arrow(e1b_x+55, e1b_y+340,             e1b_x+65, e1b_y+340,     thi, col);
  draw_line (e1b_x+65, e1b_y+340,             e1b_x+100,e1b_y+340,     thi, col);

  /* SRC1 */
  if (ea1op && !(ea1bs & 2)) { /* ea1br */
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (e1b_x,    e1b_y-40, e1b_x+40, e1b_y-30, thi, col);
  draw_arrow(e1b_x+20, e1b_y-30, e1b_x+20, e1b_y-10, thi, col);
  if (ea1op && (ea1bs & 2)) { /* eabbrs */
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line (e1b_x+90, e1b_y-170+eabbrs*5+10, e1b_x+90, e1b_y-70, thi, col);
  draw_line (e1b_x+90, e1b_y-70,              e1b_x+30, e1b_y-70, thi, col);
  draw_arrow(e1b_x+30, e1b_y-70,              e1b_x+30, e1b_y-10, thi, col);

  /* feedback-loop */
  if (ea1bs & 1) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line (e1b_x+50, e1b_y+190,             e1b_x+50, e1b_y+200,     thi, col);
  draw_line (e1b_x+50, e1b_y+200,             e1b_x+20, e1b_y+200,     thi, col);
  draw_arrow(e1b_x+20, e1b_y+200,             e1b_x+20, e1b_y-10,      thi, col);

  /* mex-loop */
  if (mex1op==OP_CMPA_LE || mex1op==OP_CMPA_GE) {
    col=2; /*green*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line (e1b_x+65, e1b_y+360,             e1b_x+80, e1b_y+360,     thi, col);
  draw_arrow(e1b_x+65, e1b_y+360,             e1b_x+65, e1b_y-40,      thi, col);
  snprintf(opcd, E1LABELMAX, "%s-%d-%d-%d", mex1op==OP_ALWAYS?"AL":mex1op==OP_CMPA_LE?"LE":mex1op==OP_CMPA_GE?"GE":"NA", mex1init, mex1dist, mexlimit);
  draw_text(e1b_x+30, e1b_y-40, opcd, 1, 0);

  /* SRC2 */
  if (ea1op && !(ea1os & 1)) { /* ea1or */
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (e1b_x+60, e1b_y-40, e1b_x+100, e1b_y-30, thi, col);
  draw_arrow(e1b_x+80, e1b_y-30, e1b_x+80,  e1b_y-10, thi, col);
  if (ea1op && (ea1os & 1)) { /* eaobrs */
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_line (e1b_x+210, e1b_y-170+eaobrs*5+10, e1b_x+210, e1b_y-60, thi, col);
  draw_line (e1b_x+210, e1b_y-60,              e1b_x+90,  e1b_y-60, thi, col);
  draw_arrow(e1b_x+90,  e1b_y-60,              e1b_x+90,  e1b_y-10, thi, col);
}

draw_trx(int trb_x, int trb_y,
         int tr0v,
         int tr1v,
         int tr2v,
         int tr3v,
         int ts0,    /*:  4; 0:br0_0, 1:br0_1, ... 15:br3_3 */
         int ts1,    /*:  4; 0:br0_0, 1:br0_1, ... 15:br3_3 */
         int ts2,    /*:  4; 0:br0_0, 1:br0_1, ... 15:br3_3 */
         int ts3,    /*:  4; 0:br0_0, 1:br0_1, ... 15:br3_3 */
         int trs0,   /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
         int trs1,   /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
         int trs2,   /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
         int trs3    /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
         )
{
#define TRLABELMAX 30
  char opcd[TRLABELMAX];
  int col, thi;

  /* TR0 */
  if (tr0v) { col=2; /*green*/ thi=3; }
  else      { col=0; /*black*/ thi=1; }
  draw_box  (trb_x+360,   trb_y,              trb_x+380, trb_y+10,  thi, col);
  if (tr0v && trs0==0) { col=2; /*green*/ thi=3; } /* lmwd */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x+380,   trb_y-80,           trb_x+380, trb_y,     thi, col);
  if (tr0v && trs0==1) { col=2; /*green*/ thi=3; } /* exdr */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x+360,   trb_y-120,          trb_x+360, trb_y,     thi, col);
  if (tr0v && trs0==2) { col=2; /*green*/ thi=3; } /* ts */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x+370,   trb_y-350+ts0*5+10, trb_x+370, trb_y,     thi, col);

  /* TR1 */
  if (tr1v) { col=2; /*green*/ thi=3; }
  else      { col=0; /*black*/ thi=1; }
  draw_box  (trb_x+240,   trb_y,              trb_x+260, trb_y+10,  thi, col);
  if (tr1v && trs1==0) { col=2; /*green*/ thi=3; } /* lmwd */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x+260,   trb_y-80,           trb_x+260, trb_y,     thi, col);
  if (tr1v && trs1==1) { col=2; /*green*/ thi=3; } /* exdr */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x+240,   trb_y-120,          trb_x+240, trb_y,     thi, col);
  if (tr1v && trs1==2) { col=2; /*green*/ thi=3; } /* ts */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x+250,   trb_y-350+ts1*5+10, trb_x+250, trb_y,     thi, col);

  /* TR2 */
  if (tr2v) { col=2; /*green*/ thi=3; }
  else      { col=0; /*black*/ thi=1; }
  draw_box  (trb_x+120,   trb_y,              trb_x+140, trb_y+10,  thi, col);
  if (tr2v && trs2==0) { col=2; /*green*/ thi=3; } /* lmwd */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x+140,   trb_y-80,           trb_x+140, trb_y,     thi, col);
  if (tr2v && trs2==1) { col=2; /*green*/ thi=3; } /* exdr */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x+120,   trb_y-120,          trb_x+120, trb_y,     thi, col);
  if (tr2v && trs2==2) { col=2; /*green*/ thi=3; } /* ts */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x+130,   trb_y-350+ts2*5+10, trb_x+130, trb_y,     thi, col);

  /* TR3 */
  if (tr3v) { col=2; /*green*/ thi=3; }
  else      { col=0; /*black*/ thi=1; }
  draw_box  (trb_x,       trb_y,              trb_x+20,  trb_y+10,  thi, col);
  if (tr3v && trs3==0) { col=2; /*green*/ thi=3; } /* lmwd */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x+20,    trb_y-80,           trb_x+20,  trb_y,     thi, col);
  if (tr3v && trs3==1) { col=2; /*green*/ thi=3; } /* exdr */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x,       trb_y-120,          trb_x,     trb_y,     thi, col);
  if (tr3v && trs3==2) { col=2; /*green*/ thi=3; } /* ts */
  else                 { col=0; /*black*/ thi=1; }
  draw_arrow(trb_x+10,    trb_y-350+ts3*5+10, trb_x+10,  trb_y,     thi, col);
}

draw_lmx(int lmb_x, int lmb_y,
	 int lmmi_v,
         int ea0op,   /* MWSAに加え,LDDMQおよびSTOREの場合にもMW有効 */
         int mwsa,    /*:  1; 0:lmwa,  1:ea0d        */
         int mws0,    /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
         int mws1,    /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
         int mws2,    /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
         int mws3,    /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
	 int ts0,
	 int ts1,
	 int ts2,
	 int ts3,
	 int lmm_mode,/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
	 Ull top
         )
{
#define LMLABELMAX 30
  char opcd[LMLABELMAX];
  int col, thi;
  int ea0store = lmmi_v && ((ea0op&0x10)||mwsa==0);

  /* MWA */
  if (ea0store) {
    col=1; /*red*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_arrow(lmb_x+340,   lmb_y-110, lmb_x+340, lmb_y-30,  thi, col);

  /* MW0 */
  if (ea0store) {
    col=1; /*red*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (lmb_x+360,   lmb_y,     lmb_x+420, lmb_y+10,  thi, col);
  draw_box  (lmb_x+360,   lmb_y+20,  lmb_x+420, lmb_y+30,  thi, col);
  draw_box  (lmb_x+360,   lmb_y+30,  lmb_x+420, lmb_y+40,  thi, col);
  draw_box  (lmb_x+360,   lmb_y+40,  lmb_x+420, lmb_y+50,  1, 0);
  draw_box  (lmb_x+360,   lmb_y+50,  lmb_x+420, lmb_y+60,  1, 0);
  draw_line (lmb_x+365,   lmb_y-60,  lmb_x+405, lmb_y-60,  thi, col);
  draw_line (lmb_x+370,   lmb_y-60,  lmb_x+370, lmb_y,     thi, col);
  if (ea0store && mws0==0) { col=1; /*red*/   thi=3; } /* lmwd0 */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+400,   lmb_y-110, lmb_x+400, lmb_y-60,  thi, col);
  if (ea0store && mws0==1) { col=1; /*red*/   thi=3; } /* exdr */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+380,   lmb_y-150, lmb_x+380, lmb_y-60,  thi, col);
  if (ea0store && mws0==2) { col=1; /*red*/   thi=3; } /* ts0 */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+390,   lmb_y-370+ts0*5, lmb_x+390, lmb_y-60,  thi, col);

  /* MW1 */
  if (ea0store) {
    col=1; /*red*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (lmb_x+240,   lmb_y,     lmb_x+300, lmb_y+10,  thi, col);
  draw_box  (lmb_x+240,   lmb_y+20,  lmb_x+300, lmb_y+30,  thi, col);
  draw_box  (lmb_x+240,   lmb_y+30,  lmb_x+300, lmb_y+40,  thi, col);
  draw_box  (lmb_x+240,   lmb_y+40,  lmb_x+300, lmb_y+50,  1, 0);
  draw_box  (lmb_x+240,   lmb_y+50,  lmb_x+300, lmb_y+60,  1, 0);
  draw_line (lmb_x+245,   lmb_y-60,  lmb_x+285, lmb_y-60,  thi, col);
  draw_line (lmb_x+250,   lmb_y-60,  lmb_x+250, lmb_y,     thi, col);
  if (ea0store && mws1==0) { col=1; /*red*/   thi=3; } /* lmwd1 */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+280,   lmb_y-110, lmb_x+280, lmb_y-60,  thi, col);
  if (ea0store && mws1==1) { col=1; /*red*/   thi=3; } /* exdr */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+260,   lmb_y-150, lmb_x+260, lmb_y-60,  thi, col);
  if (ea0store && mws1==2) { col=1; /*red*/   thi=3; } /* ts1 */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+270,   lmb_y-370+ts1*5, lmb_x+270, lmb_y-60,  thi, col);

  /* MW2 */
  if (ea0store) {
    col=1; /*red*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (lmb_x+120,   lmb_y,     lmb_x+180, lmb_y+10,  thi, col);
  draw_box  (lmb_x+120,   lmb_y+20,  lmb_x+180, lmb_y+30,  thi, col);
  draw_box  (lmb_x+120,   lmb_y+30,  lmb_x+180, lmb_y+40,  thi, col);
  draw_box  (lmb_x+120,   lmb_y+40,  lmb_x+180, lmb_y+50,  1, 0);
  draw_box  (lmb_x+120,   lmb_y+50,  lmb_x+180, lmb_y+60,  1, 0);
  draw_line (lmb_x+125,   lmb_y-60,  lmb_x+165, lmb_y-60,  thi, col);
  draw_line (lmb_x+130,   lmb_y-60,  lmb_x+130, lmb_y,     thi, col);
  if (ea0store && mws2==0) { col=1; /*red*/   thi=3; } /* lmwd2 */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+160,   lmb_y-110, lmb_x+160, lmb_y-60,  thi, col);
  if (ea0store && mws2==1) { col=1; /*red*/   thi=3; } /* exdr */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+140,   lmb_y-150, lmb_x+140, lmb_y-60,  thi, col);
  if (ea0store && mws2==2) { col=1; /*red*/   thi=3; } /* ts2 */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+150,   lmb_y-370+ts2*5, lmb_x+150, lmb_y-60,  thi, col);

  /* MW3 */
  if (ea0store) {
    col=1; /*red*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (lmb_x,       lmb_y,     lmb_x+60,  lmb_y+10,  thi, col);
  draw_box  (lmb_x,       lmb_y+20,  lmb_x+60,  lmb_y+30,  thi, col);
  draw_box  (lmb_x,       lmb_y+30,  lmb_x+60,  lmb_y+40,  thi, col);
  draw_box  (lmb_x,       lmb_y+40,  lmb_x+60,  lmb_y+50,  1, 0);
  draw_box  (lmb_x,       lmb_y+50,  lmb_x+60,  lmb_y+60,  1, 0);
  draw_line (lmb_x+5,     lmb_y-60,  lmb_x+45,  lmb_y-60,  thi, col);
  draw_line (lmb_x+10,    lmb_y-60,  lmb_x+10,  lmb_y,     thi, col);
  if (ea0store && mws3==0) { col=1; /*red*/   thi=3; } /* lmwd3 */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+40,    lmb_y-110, lmb_x+40 , lmb_y-60,  thi, col);
  if (ea0store && mws3==1) { col=1; /*red*/   thi=3; } /* exdr */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+20,    lmb_y-150, lmb_x+20,  lmb_y-60,  thi, col);
  if (ea0store && mws3==2) { col=1; /*red*/   thi=3; } /* ts3 */
  else                     { col=0; /*black*/ thi=1; }
  draw_arrow(lmb_x+30,    lmb_y-370+ts3*5, lmb_x+30,  lmb_y-60,  thi, col);

  switch (lmm_mode) {
  case 0:
    draw_text(lmb_x+405, lmb_y-25, "M0(N/A)", 1, 0);
    break;
  case 1:
    draw_text(lmb_x+405, lmb_y-25, "M1(64KB)", 1, 0);
    break;
  case 2:
    draw_text(lmb_x+405, lmb_y-25, "M2(32KB)", 1, 0);
    break;
  case 3:
    draw_text(lmb_x+405, lmb_y-25, "M3(16KB)", 1, 0);
    break;
  }
  draw_text(lmb_x+405, lmb_y-5, (char*)top, 1, 0);
}

draw_bri(int bri_x, int bri_y,
         int ea0op,  /*:  5; mem_opcd */
         int ea1op,  /*:  5; mem_opcd */
         int brs0,   /*:  2; 0:off, 1:mr10, 2:tr0, 3:mr0  */
         int brs1,   /*:  2; 0:off, 1:mr11, 2:tr1, 3:mr1  */
         int brs2,   /*:  2; 0:off, 1:mr12, 2:tr2, 3:exd(brs3=3の場合,ea0woofsに接続) */
         int brs3,   /*:  2; 0:off, 1:mr13, 2:tr3  3:ea1woofs */
         int br0v,
         int br0h,
         int br0s,
         int br1v,
         int br1h,
         int br1s,
         int br2v,
         int br2h,
         int br2s,
         int br3v,
         int br3h,
         int br3s
         )
{
#define BRLABELMAX 30
  char opcd[BRLABELMAX];
  int col, thi;
  int ea0singleload = (ea0op && (ea0op <= OP_LDBR));
  int ea1singleload = (ea1op && (ea1op <= OP_LDBR));

  /* BR0 */
  if (brs0) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (bri_x+360,   bri_y,     bri_x+420, bri_y+15,  thi, col);
  if (brs0==1) { col=4; thi=3; } /* mr10 */
  else         { col=0; thi=1; }
  if (col) {
    draw_box(bri_x+360,   bri_y-110, bri_x+420, bri_y-100, thi, col);
    draw_box(bri_x+360,   bri_y-100, bri_x+420, bri_y-90,  thi, col);
  }
  draw_arrow(bri_x+400,   bri_y-90,  bri_x+400, bri_y,     thi, col);
  if (brs0==2) { col=4; thi=3; } /* tr0 */
  else         { col=0; thi=1; }
  draw_arrow(bri_x+390,   bri_y-170, bri_x+390, bri_y,     thi, col);
  if (brs0==3) { col=4; thi=3; } /* mr0 */
  else         { col=0; thi=1; }
  if (col) {
    draw_box(bri_x+360,   bri_y-110, bri_x+420, bri_y-100, thi, col);
    draw_box(bri_x+360,   bri_y-100, bri_x+420, bri_y-90,  thi, col);
    draw_box(bri_x+240,   bri_y-110, bri_x+300, bri_y-100, thi, col);
    draw_box(bri_x+240,   bri_y-100, bri_x+300, bri_y-90,  thi, col);
    draw_box(bri_x+120,   bri_y-110, bri_x+180, bri_y-100, thi, col);
    draw_box(bri_x+120,   bri_y-100, bri_x+180, bri_y-90,  thi, col);
    draw_box(bri_x,       bri_y-110, bri_x+60,  bri_y-100, thi, col);
    draw_box(bri_x,       bri_y-100, bri_x+60,  bri_y-90,  thi, col);
  }
  draw_line (bri_x+410,   bri_y-90,  bri_x+410, bri_y-80,  thi, col);
  draw_line (bri_x+410,   bri_y-80,  bri_x+380, bri_y-80,  thi, col);
  draw_arrow(bri_x+380,   bri_y-80,  bri_x+380, bri_y-20,  thi, col);
  draw_line (bri_x+290,   bri_y-90,  bri_x+290, bri_y-80,  thi, col);
  draw_line (bri_x+290,   bri_y-80,  bri_x+370, bri_y-80,  thi, col);
  draw_arrow(bri_x+370,   bri_y-80,  bri_x+370, bri_y-20,  thi, col);
  draw_line (bri_x+170,   bri_y-90,  bri_x+170, bri_y-70,  thi, col);
  draw_line (bri_x+170,   bri_y-70,  bri_x+360, bri_y-70,  thi, col);
  draw_arrow(bri_x+360,   bri_y-70,  bri_x+360, bri_y-20,  thi, col);
  draw_line (bri_x+50,    bri_y-90,  bri_x+50,  bri_y-60,  thi, col);
  draw_line (bri_x+50,    bri_y-60,  bri_x+350, bri_y-60,  thi, col);
  draw_arrow(bri_x+350,   bri_y-60,  bri_x+350, bri_y-20,  thi, col);
  draw_arrow(bri_x+380,   bri_y-20,  bri_x+380, bri_y,     thi, col);
  switch (br0v) {
  case 0: /* T_NONE */
    col=0; /*black*/
    thi=1;
    break;
  case 1: /* T_IMMEDIATE */
    col=4; /*blue*/
    thi=3;
    break;
  case 2: /* T_EXRNO */
    col=5; /*magenta*/
    thi=3;
    break;
  case 3: /* T_ALRNO */
    col=3; /*yellow*/
    thi=3;
    break;
  case 4: /* T_BDRNO */
    col=1; /*red*/
    thi=3;
    break;
  case 7: /* T_VARIABLE */
    col=2; /*green*/
    thi=3;
    break;
  default:
    col=6; /*cyan*/
    thi=3;
    break;
  }
  if (col) {
    draw_box (bri_x+360,   bri_y,    bri_x+420, bri_y+15,  thi, col);
    if (br0s == -1)
      snprintf(opcd, BRLABELMAX, "%s", id[br0h].name);
    else
      snprintf(opcd, BRLABELMAX, "%s[%d]", id[br0h].name, br0s);
    draw_text(bri_x+365,   bri_y+14, opcd, 1, 0);
  }

  /* BR1 */
  if (brs1) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (bri_x+240,   bri_y,     bri_x+300, bri_y+15,  thi, col);
  if (brs1==1) { col=4; thi=3; } /* mr11 */
  else         { col=0; thi=1; }
  if (col) {
    draw_box(bri_x+240,   bri_y-110, bri_x+300, bri_y-100, thi, col);
    draw_box(bri_x+240,   bri_y-100, bri_x+300, bri_y-90,  thi, col);
  }
  draw_arrow(bri_x+280,   bri_y-90,  bri_x+280, bri_y,     thi, col);
  if (brs1==2) { col=4; thi=3; } /* tr1 */
  else         { col=0; thi=1; }
  draw_arrow(bri_x+270,   bri_y-170, bri_x+270, bri_y,     thi, col);
  if (brs1==3) { col=4; thi=3; } /* mr1 */
  else         { col=0; thi=1; }
  if (col) {
    draw_box(bri_x+360,   bri_y-110, bri_x+420, bri_y-100, thi, col);
    draw_box(bri_x+360,   bri_y-100, bri_x+420, bri_y-90,  thi, col);
    draw_box(bri_x+240,   bri_y-110, bri_x+300, bri_y-100, thi, col);
    draw_box(bri_x+240,   bri_y-100, bri_x+300, bri_y-90,  thi, col);
    draw_box(bri_x+120,   bri_y-110, bri_x+180, bri_y-100, thi, col);
    draw_box(bri_x+120,   bri_y-100, bri_x+180, bri_y-90,  thi, col);
    draw_box(bri_x,       bri_y-110, bri_x+60,  bri_y-100, thi, col);
    draw_box(bri_x,       bri_y-100, bri_x+60,  bri_y-90,  thi, col);
  }
  draw_line (bri_x+400,   bri_y-40,  bri_x+260, bri_y-40,  thi, col);
  draw_arrow(bri_x+260,   bri_y-40,  bri_x+260, bri_y-20,  thi, col);
  draw_line (bri_x+280,   bri_y-50,  bri_x+250, bri_y-50,  thi, col);
  draw_arrow(bri_x+250,   bri_y-50,  bri_x+250, bri_y-20,  thi, col);
  draw_line (bri_x+160,   bri_y-50,  bri_x+240, bri_y-50,  thi, col);
  draw_arrow(bri_x+240,   bri_y-50,  bri_x+240, bri_y-20,  thi, col);
  draw_line (bri_x+40,    bri_y-40,  bri_x+230, bri_y-40,  thi, col);
  draw_arrow(bri_x+230,   bri_y-40,  bri_x+230, bri_y-20,  thi, col);
  draw_arrow(bri_x+260,   bri_y-20,  bri_x+260, bri_y,     thi, col);
  switch (br1v) {
  case 0: /* T_NONE */
    col=0; /*black*/
    thi=1;
    break;
  case 1: /* T_IMMEDIATE */
    col=4; /*blue*/
    thi=3;
    break;
  case 2: /* T_EXRNO */
    col=5; /*magenta*/
    thi=3;
    break;
  case 3: /* T_ALRNO */
    col=3; /*yellow*/
    thi=3;
    break;
  case 4: /* T_BDRNO */
    col=1; /*red*/
    thi=3;
    break;
  case 7: /* T_VARIABLE */
    col=2; /*green*/
    thi=3;
    break;
  default:
    col=6; /*cyan*/
    thi=3;
    break;
  }
  if (col) {
    draw_box (bri_x+240,   bri_y,    bri_x+300, bri_y+15,  thi, col);
    if (br1s == -1)
      snprintf(opcd, BRLABELMAX, "%s", id[br1h].name);
    else
      snprintf(opcd, BRLABELMAX, "%s[%d]", id[br1h].name, br1s);
    draw_text(bri_x+245,   bri_y+14, opcd, 1, 0);
  }

  /* BR2 */
  if (brs2) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (bri_x+120,   bri_y,     bri_x+180, bri_y+15,  thi, col);
  if (brs2==1) { col=4; thi=3; } /* mr12 */
  else         { col=0; thi=1; }
  if (col) {
    draw_box(bri_x+120,   bri_y-110, bri_x+180, bri_y-100, thi, col);
    draw_box(bri_x+120,   bri_y-100, bri_x+180, bri_y-90,  thi, col);
  }
  draw_arrow(bri_x+160,   bri_y-90,  bri_x+160, bri_y,     thi, col);
  if (brs2==2) { col=4; thi=3; } /* tr2 */
  else         { col=0; thi=1; }
  draw_arrow(bri_x+150,   bri_y-170, bri_x+150, bri_y,     thi, col);
  if (brs2==3 && brs3!=3) { col=5; thi=3; } /* exdr */
  else                    { col=0; thi=1; }
  draw_line (bri_x+90,    bri_y-170, bri_x+90,  bri_y-20,  thi, col);
  draw_line (bri_x+90,    bri_y-20,  bri_x+140, bri_y-20,  thi, col);
  draw_arrow(bri_x+140,   bri_y-20,  bri_x+140, bri_y,     thi, col);
  if (brs2==3 && brs3==3) { col=2; thi=3; /* ea0woofs */
  draw_arrow(bri_x+330,   bri_y-140,  bri_x+170, bri_y,     thi, col);
  }
  switch (br2v) {
  case 0: /* T_NONE */
    col=0; /*black*/
    thi=1;
    break;
  case 1: /* T_IMMEDIATE */
    col=4; /*blue*/
    thi=3;
    break;
  case 2: /* T_EXRNO */
    col=5; /*magenta*/
    thi=3;
    break;
  case 3: /* T_ALRNO */
    col=3; /*yellow*/
    thi=3;
    break;
  case 4: /* T_BDRNO */
    col=1; /*red*/
    thi=3;
    break;
  case 7: /* T_VARIABLE */
    col=2; /*green*/
    thi=3;
    break;
  default:
    col=6; /*cyan*/
    thi=3;
    break;
  }
  if (col) {
    draw_box (bri_x+120,   bri_y,    bri_x+180, bri_y+15,  thi, col);
    if (br2s == -1)
      snprintf(opcd, BRLABELMAX, "%s", id[br2h].name);
    else
      snprintf(opcd, BRLABELMAX, "%s[%d]", id[br2h].name, br2s);
    draw_text(bri_x+125,   bri_y+14, opcd, 1, 0);
  }

  /* BR3 */
  if (brs3) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (bri_x,       bri_y,     bri_x+60,  bri_y+15,  thi, col);
  if (brs3==1) { col=4; thi=3; } /* mr13 */
  else         { col=0; thi=1; }
  if (col) {
    draw_box(bri_x,       bri_y-110, bri_x+60,  bri_y-100, thi, col);
    draw_box(bri_x,       bri_y-100, bri_x+60,  bri_y-90,  thi, col);
  }
  draw_arrow(bri_x+40,    bri_y-90,  bri_x+40,  bri_y,     thi, col);
  if (brs3==2) { col=4; thi=3; } /* tr3 */
  else         { col=0; thi=1; }
  draw_arrow(bri_x+30,    bri_y-170, bri_x+30,  bri_y,     thi, col);
  if (brs3==3) { col=2; thi=3; /* ea1woofs */
  draw_arrow(bri_x+210,   bri_y-140, bri_x+50,  bri_y,     thi, col);
  }
  switch (br3v) {
  case 0: /* T_NONE */
    col=0; /*black*/
    thi=1;
    break;
  case 1: /* T_IMMEDIATE */
    col=4; /*blue*/
    thi=3;
    break;
  case 2: /* T_EXRNO */
    col=5; /*magenta*/
    thi=3;
    break;
  case 3: /* T_ALRNO */
    col=3; /*yellow*/
    thi=3;
    break;
  case 4: /* T_BDRNO */
    col=1; /*red*/
    thi=3;
    break;
  case 7: /* T_VARIABLE */
    col=2; /*green*/
    thi=3;
    break;
  default:
    col=6; /*cyan*/
    thi=3;
    break;
  }
  if (col) {
    draw_box (bri_x,       bri_y,    bri_x+60,  bri_y+15,  thi, col);
    if (br3s == -1)
      snprintf(opcd, BRLABELMAX, "%s", id[br3h].name);
    else
      snprintf(opcd, BRLABELMAX, "%s[%d]", id[br3h].name, br3s);
    draw_text(bri_x+5,     bri_y+14, opcd, 1, 0);
  }
}

draw_lmr(int bri_x, int bri_y,
         int lmrd0,
         int lmrd1,
         int lmrd2,
         int lmrd3
         )
{
  int col, thi;

  /* LMRA */
  if (lmrd0 || lmrd1 || lmrd2 || lmrd3) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_arrow(bri_x+220,  bri_y-260, bri_x+220, bri_y-180,  thi, col);
  draw_box  (bri_x+200,  bri_y-180, bri_x+220, bri_y-170,  thi, col);
  draw_line (bri_x+210,  bri_y-170, bri_x+210, bri_y-150,  thi, col);
  draw_box  (bri_x+200,  bri_y-150, bri_x+220, bri_y-140,  thi, col);

  /* LMRD0 */
  if (lmrd0) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (bri_x+360,   bri_y-110, bri_x+420, bri_y-100, thi, col);
  draw_box  (bri_x+360,   bri_y-100, bri_x+420, bri_y-90,  thi, col);
  draw_line (bri_x+400,   bri_y-90,  bri_x+400, bri_y-20,  thi, col);
  draw_arrow(bri_x+400,   bri_y-20,  bri_x+420, bri_y-20,  thi, col);

  /* LMRD1 */
  if (lmrd1) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (bri_x+240,   bri_y-110, bri_x+300, bri_y-100, thi, col);
  draw_box  (bri_x+240,   bri_y-100, bri_x+300, bri_y-90,  thi, col);
  draw_line (bri_x+280,   bri_y-90,  bri_x+280, bri_y-20,  thi, col);
  draw_arrow(bri_x+280,   bri_y-20,  bri_x+300, bri_y-20,  thi, col);

  /* LMRD2 */
  if (lmrd2) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (bri_x+120,   bri_y-110, bri_x+180, bri_y-100, thi, col);
  draw_box  (bri_x+120,   bri_y-100, bri_x+180, bri_y-90,  thi, col);
  draw_line (bri_x+160,   bri_y-90,  bri_x+160, bri_y-20,  thi, col);
  draw_arrow(bri_x+160,   bri_y-20,  bri_x+180, bri_y-20,  thi, col);

  /* LMRD3 */
  if (lmrd3) {
    col=4; /*blue*/
    thi=3;
  }
  else {
    col=0; /*black*/
    thi=1;
  }
  draw_box  (bri_x,       bri_y-110, bri_x+60,  bri_y-100, thi, col);
  draw_box  (bri_x,       bri_y-100, bri_x+60,  bri_y-90,  thi, col);
  draw_line (bri_x+40,    bri_y-90,  bri_x+40,  bri_y-20,  thi, col);
  draw_arrow(bri_x+40,    bri_y-20,  bri_x+60,  bri_y-20,  thi, col);
}

draw_box(int x0, int y0, int x1, int y1, int thick, int color)
{
  char *cstr[] = { "'black'", "'red'", "'green'", "'yellow'", "'blue'", "'magenta'", "'cyan'", "'white'"};

  if (thick>7) thick=7;
  if (color>7) color=7;

  fprintf(ffile, "box(%s,'',%d,%d,%d,%d,0,%d,1,0,0,0,0,0,0,'%d',0,[\n", cstr[color], x0, y0, x1, y1, thick, thick);
  fprintf(ffile, "]).\n");
}

draw_line(int x0, int y0, int x1, int y1, int thick, int color)
{
  char *cstr[] = { "'black'", "'red'", "'green'", "'yellow'", "'blue'", "'magenta'", "'cyan'", "'white'"};

  if (thick>7) thick=7;
  if (color>7) color=7;

  fprintf(ffile, "poly(%s,'',2,[\n", cstr[color]);
  fprintf(ffile, "%d,%d,%d,%d],0,%d,1,1,0,0,0,0,0,0,0,'%d',0,0,\n", x0, y0, x1, y1, thick, thick);
  fprintf(ffile, "\"0\",\"\",[\n");
  fprintf(ffile, "0,12,5,0,'12','5','0'],[0,12,5,0,'12','5','0'],[\n");
  fprintf(ffile, "]).\n");
}

draw_arrow(int x0, int y0, int x1, int y1, int thick, int color)
{
  char *cstr[] = { "'black'", "'red'", "'green'", "'yellow'", "'blue'", "'magenta'", "'cyan'", "'white'"};

  if (thick>7) thick=7;
  if (color>7) color=7;

  fprintf(ffile, "poly(%s,'',2,[\n", cstr[color]);
  fprintf(ffile, "%d,%d,%d,%d],1,%d,1,1,0,0,0,0,0,0,0,'%d',0,0,\n", x0, y0, x1, y1, thick, thick);
  fprintf(ffile, "\"0\",\"\",[\n");
  fprintf(ffile, "0,12,5,0,'12','5','0'],[0,12,5,0,'12','5','0'],[\n");
  fprintf(ffile, "]).\n");
}

draw_text(int x0, int y0, char *str, int size, int color)
{
  char *cstr[] = { "'black'", "'red'", "'green'", "'yellow'", "'blue'", "'magenta'", "'cyan'", "'white'"};

  if (color>7) color=7;

  fprintf(ffile, "text(%s,%d,%d,1,0,1,40,20,10,10,5,0,0,0,0,2,40,20,0,0,\"\",0,0,0,0,%d,'',[\n", cstr[color], x0, y0, y0);
  fprintf(ffile, "minilines(40,20,0,0,0,0,0,[\n");
  fprintf(ffile, "mini_line(40,20,10,0,0,0,[\n");
  fprintf(ffile, "str_block(0,40,20,10,0,0,0,0,0,[\n");
  fprintf(ffile, "str_seg(%s,'Times-Roman',0,%d,40,20,10,0,0,0,0,1,0,0,\n", cstr[color], size*115200);
  fprintf(ffile, "        \"%s\")])\n", str);
  fprintf(ffile, "])\n");
  fprintf(ffile, "])]).\n");
}
@


1.150
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.149 2022/10/29 10:50:42 nakashim Exp nakashim $";
a3799 3
  /* exec */
  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].cmd = 3LL; // EXEC\n");

d3837 3
@


1.149
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.148 2022/10/29 09:30:20 nakashim Exp nakashim $";
d5064 1
a5064 1
#define E0LABELMAX 30
d5153 1
a5153 1
  snprintf(opcd, E0LABELMAX, "%s-%d-%d-%d-%d", mex0op==OP_ALWAYS?"AL":mex0op==OP_CMPA_LE?"LE":mex0op==OP_CMPA_GE?"GE":"NA", mex0init, mex0dist, mexlimit);
d5192 1
a5192 1
#define E1LABELMAX 30
d5277 1
a5277 1
  snprintf(opcd, E1LABELMAX, "%s-%d-%d-%d-%d", mex1op==OP_ALWAYS?"AL":mex1op==OP_CMPA_LE?"LE":mex1op==OP_CMPA_GE?"GE":"NA", mex1init, mex1dist, mexlimit);
@


1.148
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.147 2022/10/29 05:08:58 nakashim Exp nakashim $";
d5153 1
a5153 1
  snprintf(opcd, E0LABELMAX, "%s-%d-%d-%d", mex0op==OP_ALWAYS?"AL":mex0op==OP_CMPA_LE?"LE":mex0op==OP_CMPA_GE?"GE":"NA", mex0init, mex0dist, mexlimit);
d5277 1
a5277 1
  snprintf(opcd, E1LABELMAX, "%s-%d-%d-%d", mex1op==OP_ALWAYS?"AL":mex1op==OP_CMPA_LE?"LE":mex1op==OP_CMPA_GE?"GE":"NA", mex1init, mex1dist, mexlimit);
@


1.147
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.146 2022/10/28 22:19:47 nakashim Exp nakashim $";
d1535 5
a1539 2
	else if (insn[i].imex.op1)
	  *dmex = insn[i].imex;
d1547 1
a1547 1
	else if (insn[i].imex.op0)
d1549 4
@


1.146
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.145 2022/10/28 12:57:14 nakashim Exp nakashim $";
d3388 1
a3388 1
      if (lmmi[i][j].v && !(lmmx[i][j].lenv == T_IMMEDIATE && lmmi[i][j].len==0xffff) && ~lmmi[i][j].hcopy && ~lmmi[i][j].vcopy) {
d3390 1
a3390 1
	if (lmmi_first_loc == -1 && ~lmmi[i][j].rw && !lmmi[i][j].p) /* lmrとlmfの場合,DYNAMIC_SCONの基準位置として記憶 */
d3419 1
a3419 1
      if (lmmi[i][j].v && !(lmmx[i][j].lenv == T_IMMEDIATE && lmmi[i][j].len==0xffff) && ~lmmi[i][j].hcopy) {
@


1.145
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.144 2022/10/28 09:11:09 nakashim Exp nakashim $";
d832 2
a833 2
      /* new mex(OP_CMPA_LE, &b0[h][0], INIT0?b[0]:b0[h][0], OP_CMPA_GE, &a0[h][0][CHIP], INIT0?a[h][CHIP]:a0[h][0][CHIP], 0LL, INIT0?0:8,     BR[r][2][1], BR[r][2][0]);*/
      /* new mex(OP_CMPA_LE, &J[x],     INIT0?0LL:J[x],      OP_CMPA_GE, &K[x],           INIT0?0LL:K[x],                  BE8, INIT0?0LL:8LL, BR[r][2][1], BR[r][2][0]);*/
@


1.144
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.143 2022/10/28 08:41:47 nakashim Exp nakashim $";
d911 7
a917 4
      bus[last_row][last_col].ea0woofsv = dmex->mexd1v;
      bus[last_row][last_col].ea0woofsh = dmex->mexd1h;
      bus[last_row][last_col].ea1woofsv = dmex->mexd2v;
      bus[last_row][last_col].ea1woofsh = dmex->mexd2h;
a920 3
      id[insn[i].imex.mexd2h].itype = ITYPE_MEX;
      id[insn[i].imex.mexd2h].row   = last_row;
      id[insn[i].imex.mexd2h].col   = last_col;
d1556 1
a1556 1
	if (!(dmex->op1 && dmex->mexd2h == dmop1->baseh))
d1645 1
a1645 1
	if (!(dmex->op0 && dmex->mexd1h == dmop0->baseh))
d1902 1
a1902 1
      if (dec[i][j].dmex.op0 && dec[i][j].dmex.mexd1h == dec[i][j].dmop0.baseh) {
d1908 1
a1908 1
	printf(" mop0 renamed from %s to %s\n", id[dec[i][j].dmex.mexd1h].name, id[dec[i][j].dmop0.baseh].name);
d1952 1
a1952 1
      if (dec[i][j].dmex.op1 && dec[i][j].dmex.mexd2h == dec[i][j].dmop1.baseh) {
d1958 1
a1958 1
	printf(" mop1 renamed from %s to %s\n", id[dec[i][j].dmex.mexd2h].name, id[dec[i][j].dmop1.baseh].name);
@


1.143
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.142 2022/10/28 04:45:01 nakashim Exp nakashim $";
d1871 1
a1871 1
      switch (id[dec[i][j].dmex.disth].val) { /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
d1921 1
a1921 1
      switch (id[dec[i][j].dmex.disth].val) { /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
@


1.142
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.141 2022/10/27 09:55:53 nakashim Exp nakashim $";
d24 1
a24 1
  struct mex *dmex0, *dmex1;
d829 5
a833 4
      /* old mex(OP_CMPA_LE,  &b0[h],       INIT0?b:b0[h],                INIT0?0:8, BR[r][2][1], BR[r][2][0]);*/
      /* old mex(OP_CMPA_GE,  &a0[h][CHIP], INIT0?a[h][CHIP]:a0[h][CHIP], INIT0?0:8, BR[r][2][1], BR[r][2][0]);*/
      /* new mex(OP_CMPA_LEGE,&b0[h][0], INIT0?b[0]:b0[h][0], &a0[h][0][CHIP], INIT0?a[h][CHIP]:a0[h][0][CHIP], 0LL, INIT0?0:8,     BR[r][2][1], BR[r][2][0]);*/
      /* new mex(OP_CMPA_LEGE,&J[x],     INIT0?0LL:J[x],      &K[x],           INIT0?0LL:K[x],                  BE8, INIT0?0LL:8LL, BR[r][2][1], BR[r][2][0]);*/
d836 1
a836 1
      switch (insn[i].imex.op) {
d840 11
d854 2
a855 3
      case OP_CMPA_LEGE:
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.adr1v, insn[i].imex.adr1h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.adr2v, insn[i].imex.adr2h, rdep);
d901 2
a902 4
      dmex0 = &dec[last_row][last_col].dmex0;
      dmex1 = &dec[last_row][last_col].dmex1;
      *dmex1 = insn[i].imex; /* new mex()は1つで2つ分指定 */
      *dmex0 = insn[i].imex; /* new mex()は1つで2つ分指定 */
d906 2
a907 2
      set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmex1->adr3v, dmex1->adr3h, dmex1->adr3s);
      set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 0, dmex0->adr1v, dmex0->adr1h, dmex0->adr1s);
d911 4
a914 4
      bus[last_row][last_col].ea0woofsv = dmex0->mexd1v;
      bus[last_row][last_col].ea0woofsh = dmex0->mexd1h;
      bus[last_row][last_col].ea1woofsv = dmex1->mexd2v;
      bus[last_row][last_col].ea1woofsh = dmex1->mexd2h;
d1498 2
a1499 2
	                           && (dec[last_row][last_col].dmex0.op)
	                           && (dec[last_row][last_col].dmex1.op);
d1526 1
a1526 2
      dmex0 = &dec[last_row][last_col].dmex0;
      dmex1 = &dec[last_row][last_col].dmex1;
d1531 1
a1531 1
	if (dmex1->op && insn[i].imex.op) {
d1535 2
a1536 2
	else if (insn[i].imex.op)
	  *dmex1 = insn[i].imex;
d1540 1
a1540 1
	if (dmex0->op && insn[i].imex.op) {
d1544 2
a1545 2
	else if (insn[i].imex.op)
	  *dmex0 = insn[i].imex;
d1556 1
a1556 1
	if (!(dmex1->op && dmex1->mexd2h == dmop1->baseh))
d1564 1
a1564 1
          if (dmop1->mtype == MTYPE_RLOAD && dmex1->op == OP_CMPA_LEGE) {
d1567 1
a1567 1
	  else if (last_col == 1 && dmop1->mtype == MTYPE_RLOAD && dec[last_row][2].dmex0.op == OP_CMPA_LEGE) { /* load in load-cfma-store */
d1645 1
a1645 1
	if (!(dmex0->op && dmex0->mexd1h == dmop0->baseh))
d1653 1
a1653 1
          if (dmop0->mtype == MTYPE_RLOAD && !(dmex0->op == OP_CMPA_LEGE)) {
d1657 1
a1657 1
	    if (dmex0->op == OP_CMPA_LEGE) { /* dmop0->mtype == MTYPE_RLOAD && dmex0->op == OP_CMPA_LEGE */
d1671 1
a1671 1
	    else if (last_col == 1 && dmop0->mtype == MTYPE_RSTORE && dec[last_row][2].dmex0.op == OP_CMPA_LEGE) { /* store in load-cfma-store */
d1869 3
a1871 3
      conf[i][j].cdw0.mex0op   = dec[i][j].dmex0.op;
      conf[i][j].cdw0.mex0init = dec[i][j].dmex0.init;
      switch (id[dec[i][j].dmex0.disth].val) { /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
d1881 2
a1882 2
      if (dec[i][j].dmex0.op) {
	switch (id[dec[i][j].dmex0.limith].val) { /* limit 0:0, 1:8, 2:16, .... 10:4096, 11:8192, 12:16384, 13:32768 */
d1902 1
a1902 1
      if (dec[i][j].dmex0.op && dec[i][j].dmex0.mexd1h == dec[i][j].dmop0.baseh) {
d1905 4
a1908 4
	regv[i][j].ea0b_v = dec[i][j].dmop0.basev = dec[i][j].dmex0.adr1v; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea0b_h = dec[i][j].dmop0.baseh = dec[i][j].dmex0.adr1h; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea0b_s = dec[i][j].dmop0.bases = dec[i][j].dmex0.adr1s; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
	printf(" mop0 renamed from %s to %s\n", id[dec[i][j].dmex0.mexd1h].name, id[dec[i][j].dmop0.baseh].name);
d1919 3
a1921 3
      conf[i][j].cdw0.mex1op   = dec[i][j].dmex1.op;
      conf[i][j].cdw0.mex1init = dec[i][j].dmex1.init;
      switch (id[dec[i][j].dmex1.disth].val) { /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
d1931 2
a1932 2
      if (dec[i][j].dmex1.op) {
	switch (id[dec[i][j].dmex1.limith].val) { /* limit 0:0, 1:8, 2:16, .... 10:4096, 11:8192, 12:16384, 13:32768 */
d1952 1
a1952 1
      if (dec[i][j].dmex1.op && dec[i][j].dmex1.mexd2h == dec[i][j].dmop1.baseh) {
d1955 4
a1958 4
	regv[i][j].ea1b_v = dec[i][j].dmop1.basev = dec[i][j].dmex1.adr3v; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea1b_h = dec[i][j].dmop1.baseh = dec[i][j].dmex1.adr3h; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea1b_s = dec[i][j].dmop1.bases = dec[i][j].dmex1.adr3s; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
	printf(" mop1 renamed from %s to %s\n", id[dec[i][j].dmex1.mexd2h].name, id[dec[i][j].dmop1.baseh].name);
d2780 1
a2780 1
	case OP_CMPA_LEGE:
d2783 3
d2854 4
a2857 1
	case OP_CMPA_LEGE:
d4581 1
a4581 1
	   conf[i][j].cdw0.mex0op,  /* mex(sparse matrix) conditional 0:NOP, 1:AL, 2:OP_CMPA_LEGE */
d4594 1
a4594 1
	   conf[i][j].cdw0.mex1op,  /* mex(sparse matrix) conditional 0:NOP, 1:AL, 2:OP_CMPA_LEGE */
d5136 1
a5136 1
  if (mex0op==OP_CMPA_LEGE) {
d5146 1
a5146 1
  snprintf(opcd, E0LABELMAX, "%s-%d-%d-%d", mex0op==OP_ALWAYS?"AL":mex0op==OP_CMPA_LEGE?"LG":"NA", mex0init, mex0dist, mexlimit);
d5260 1
a5260 1
  if (mex1op==OP_CMPA_LEGE) {
d5270 1
a5270 1
  snprintf(opcd, E1LABELMAX, "%s-%d-%d-%d", mex1op==OP_ALWAYS?"AL":mex1op==OP_CMPA_LEGE?"LG":"NA", mex1init, mex1dist, mexlimit);
@


1.141
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.140 2022/10/27 02:49:46 nakashim Exp nakashim $";
d4213 1
a4213 1
	    conf[h][j].cdw2.brs2 = 3; /* 3:exdr    (brs3=3の場合,ea0woofsに接続) */
d4228 1
a4228 1
	    conf[h][j].cdw2.brs3 = 3; /* 3:ea1woofs(brs2=3の場合,ea1woofsに接続) */
d5517 2
a5518 2
         int brs2,   /*:  2; 0:off, 1:mr12, 2:tr2, 3:exd     (brs3=3の場合,ea0woofsに接続) */
         int brs3,   /*:  2; 0:off, 1:mr13, 2:tr3  3:ea1woofs(brs2=3の場合,ea1woofsに接続) */
@


1.140
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.139 2022/10/27 00:43:27 nakashim Exp nakashim $";
d1655 7
a1661 2
	      last_col_mex = 1; //★★★ last_col=3,2の場合,mop0のlast_col_mexは1固定でよい
	      printf("dmex0.lmm moved from col%d to col%d ", last_col, last_col_mex);
@


1.139
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.138 2022/10/26 10:46:02 nakashim Exp nakashim $";
d5512 2
a5513 2
         int brs2,   /*:  2; 0:off, 1:mr12, 2:tr2, 3:exdr */
         int brs3,   /*:  2; 0:off, 1:mr13, 2:tr3         */
d5718 2
a5719 2
  if (brs2==3) { col=5; thi=3; } /* exdr */
  else         { col=0; thi=1; }
d5723 3
d5785 3
@


1.138
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.137 2022/10/26 09:40:59 nakashim Exp nakashim $";
d714 5
a718 3
        else if (row < last_row) {
          printf("in %s: exe found violation of sequence (row=%d < last_row=%d)\n", id[current_prefix].name, row, last_row);
          exit(1);
@


1.137
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.136 2022/10/25 23:18:57 nakashim Exp nakashim $";
d4022 1
a4022 1
     /* insn_type: 命令種別     ITYPE_WHILE, ITYPE_FOR, ITYPE_CEX, ITYPE_EX4, ITYPE_EXE, ITYPE_MO4, ITYPE_MOP */
d4197 2
a4198 2
printf("------h=%d j=%d name=%s | v=%d srctype=%d h=%d srchash=%d s=%d srcidx=%d\n", h, j, id[src_hash].name, bus[h][j].br[2].v, src_type, bus[h][j].br[2].h, src_hash, bus[h][j].br[2].s, src_sidx);
        if (reg_loc==0) {
d4212 2
a4213 1
	else {
d4227 4
@


1.136
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.135 2022/10/17 05:09:21 nakashim Exp nakashim $";
d900 4
d1898 3
a1900 3
      conf[i][j].cdw1.ea0op    = dec[i][j].dmop0.op;
      conf[i][j].cdw1.ea0bs    = ((!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0brv?0:2)|(dec[i][j].dmop0.updt?1:0); /* 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
      conf[i][j].cdw1.ea0os  = (!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0orv?0:1; /* 0:ea0or, 1:eaobrs */
d1953 1
a1953 1
      conf[i][j].cdw1.ea1os  = (!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1orv?0:1; /* 0:ea1or, 1:eaobrs */
d3994 12
d4193 34
@


1.135
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.134 2022/10/16 21:28:36 nakashim Exp nakashim $";
a19 1
  int last_mex = -1; /* 0:mex0, 1:mex1 */
d827 6
a832 4
      /* mex(OP_CMPA_LE, &b0[h],       INIT0?b:b0[h],                INIT0?0:8, BR[r][2][1], BR[r][2][0]); */
      /* mex(OP_CMPA_GE, &a0[h][CHIP], INIT0?a[h][CHIP]:a0[h][CHIP], INIT0?0:8, BR[r][2][1], BR[r][2][0]); */
      /* mop(OP_LDR, 3,  &BR[r][2][1], b0[h],       bofs, MSK_W1, b,          2*LP*RMGRP,  0, 0, NULL, 2*LP*RMGRP); */
      /* mop(OP_LDR, 3,  &BR[r][2][0], a0[h][CHIP], cofs, MSK_W1, a[h][CHIP], 2*LP,        0, 0, NULL, 2*LP); */
d835 4
a838 2
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.src1v, insn[i].imex.src1h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.src2v, insn[i].imex.src2h, rdep);
d840 5
a844 2
      case OP_CMPA_LE:
      case OP_CMPA_GE:
a846 2
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.src3v, insn[i].imex.src3h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.src4v, insn[i].imex.src4h, rdep);
a886 8
      if      (!dec[last_row][last_col].dmex1.op)
	last_mex = 1;
      else if (!dec[last_row][last_col].dmex0.op)
	last_mex = 0;
      else {
        printf("in %s: [%d][%d] mex conflicts\n", id[current_prefix].name, last_row, last_col);
        exit(1);
      }
d890 2
a891 4
      if (last_mex==1) /* load */
        *dmex1 = insn[i].imex;
      else /* store/load */
        *dmex0 = insn[i].imex;
d895 2
a896 6
      if (last_mex==1) { /* first */
        set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmex1->src1v, dmex1->src1h, dmex1->src1s);
      }
      else { /* second */
        set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 0, dmex0->src1v, dmex0->src1h, dmex0->src1s);
      }
d900 6
a905 9
      if (last_mex==1) { /* first */
	/* do nothing */
      }
      else { /* second */
	/* do nothing */
      }
      id[insn[i].imex.mexdh].itype = ITYPE_MEX;
      id[insn[i].imex.mexdh].row   = last_row;
      id[insn[i].imex.mexdh].col   = last_col;
d1542 1
a1542 1
	if (!(dmex1->op && dmex1->mexdh == dmop1->baseh))
d1550 1
a1550 1
          if (dmop1->mtype == MTYPE_RLOAD && (dmex1->op == OP_CMPA_LE || dmex1->op == OP_CMPA_GE)) {
d1553 1
a1553 1
	  else if (last_col == 1 && dmop1->mtype == MTYPE_RLOAD && (dec[last_row][2].dmex0.op == OP_CMPA_LE || dec[last_row][2].dmex0.op == OP_CMPA_GE)) { /* load in load-cfma-store */
d1631 1
a1631 1
	if (!(dmex0->op && dmex0->mexdh == dmop0->baseh))
d1639 1
a1639 1
          if (dmop0->mtype == MTYPE_RLOAD && !(dmex0->op == OP_CMPA_LE || dmex0->op == OP_CMPA_GE)) {
d1643 1
a1643 1
	    if (dmex0->op == OP_CMPA_LE || dmex0->op == OP_CMPA_GE) { /* dmop0->mtype == MTYPE_RLOAD && (dmex0->op == OP_CMPA_LE || dmex0->op == OP_CMPA_GE) */
d1652 1
a1652 1
	    else if (last_col == 1 && dmop0->mtype == MTYPE_RSTORE && (dec[last_row][2].dmex0.op == OP_CMPA_LE || dec[last_row][2].dmex0.op == OP_CMPA_GE)) { /* store in load-cfma-store */
d1862 20
d1883 1
a1883 1
      if (dec[i][j].dmex0.op && dec[i][j].dmex0.mexdh == dec[i][j].dmop0.baseh) {
d1886 4
a1889 4
	regv[i][j].ea0b_v = dec[i][j].dmop0.basev = dec[i][j].dmex0.src1v; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea0b_h = dec[i][j].dmop0.baseh = dec[i][j].dmex0.src1h; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea0b_s = dec[i][j].dmop0.bases = dec[i][j].dmex0.src1s; /* replace mop0.base to base in mex(&base0, INIT0?base:base0) */
	printf(" mop0 renamed from %s to %s\n", id[dec[i][j].dmex0.mexdh].name, id[dec[i][j].dmop0.baseh].name);
d1912 20
d1933 1
a1933 1
      if (dec[i][j].dmex1.op && dec[i][j].dmex1.mexdh == dec[i][j].dmop1.baseh) {
d1936 4
a1939 4
	regv[i][j].ea1b_v = dec[i][j].dmop1.basev = dec[i][j].dmex1.src1v; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea1b_h = dec[i][j].dmop1.baseh = dec[i][j].dmex1.src1h; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
	regv[i][j].ea1b_s = dec[i][j].dmop1.bases = dec[i][j].dmex1.src1s; /* replace mop1.base to base in mex(&base0, INIT0?base:base0) */
	printf(" mop1 renamed from %s to %s\n", id[dec[i][j].dmex1.mexdh].name, id[dec[i][j].dmop1.baseh].name);
d2734 1
a2734 1
      fprintf(s2fil, "{ Ull base, offs, adr, mexdist, load64;\n");
d2749 5
d2761 2
a2762 5
	case OP_CMPA_LE:
	  fprintf(s2fil, "awoo1[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo1[CHIP][%d])+(INIT0[CHIP]?0:((mexd0[CHIP][%d]>>32)!=0xffffffff && (mexd1[CHIP][%d]>>32)<=(mexd0[CHIP][%d]>>32))?mexdist:0);\n", j, j, j, j, j);
	  break;
	case OP_CMPA_GE:
	  fprintf(s2fil, "awoo1[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo1[CHIP][%d])+(INIT0[CHIP]?0:((mexd1[CHIP][%d]>>32)!=0xffffffff && (mexd1[CHIP][%d]>>32)>=(mexd0[CHIP][%d]>>32))?mexdist:0);\n", j, j, j, j, j);
d2820 5
d2832 2
a2833 5
	case OP_CMPA_LE:
	  fprintf(s2fil, "awoo0[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo0[CHIP][%d])+(INIT0[CHIP]?0:((mexd0[CHIP][%d]>>32)!=0xffffffff && (mexd1[CHIP][%d]>>32)<=(mexd0[CHIP][%d]>>32))?mexdist:0);\n", j, j, j, j, j);
	  break;
	case OP_CMPA_GE:
	  fprintf(s2fil, "awoo0[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo0[CHIP][%d])+(INIT0[CHIP]?0:((mexd1[CHIP][%d]>>32)!=0xffffffff && (mexd1[CHIP][%d]>>32)>=(mexd0[CHIP][%d]>>32))?mexdist:0);\n", j, j, j, j, j);
d4505 1
a4505 1
	   conf[i][j].cdw0.mex0op,  /* mex(sparse matrix) conditional 0:NOP, 1:AL, 2:OP_CMPA_LE, 3:GE */
d4507 2
a4508 2
	   conf[i][j].cdw0.mex0dist /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */

d4518 1
a4518 1
	   conf[i][j].cdw0.mex1op,  /* mex(sparse matrix) conditional 0:NOP, 1:AL, 2:OP_CMPA_LE, 3:GE */
d4520 2
a4521 1
	   conf[i][j].cdw0.mex1dist /* distance 0:0, 1:1, 2:2, 3:4, 4:8, 5:16, 6:32, 7:64byte */
d4977 2
a4978 1
	 int mex0dist
d5060 1
a5060 1
  if (mex0op==OP_CMPA_LE || mex0op==OP_CMPA_GE) {
d5070 1
a5070 1
  snprintf(opcd, E0LABELMAX, "%s-%d-%d", mex0op==OP_ALWAYS?"AL":mex0op==OP_CMPA_LE?"LE":mex0op==OP_CMPA_GE?"GE":"NA", mex0init, mex0dist);
d5105 2
a5106 1
	 int mex1dist
d5184 1
a5184 1
  if (mex1op==OP_CMPA_LE || mex1op==OP_CMPA_GE) {
d5194 1
a5194 1
  snprintf(opcd, E1LABELMAX, "%s-%d-%d", mex1op==OP_ALWAYS?"AL":mex1op==OP_CMPA_LE?"LE":mex1op==OP_CMPA_GE?"GE":"NA", mex1init, mex1dist);
@


1.134
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.133 2022/10/16 14:10:45 nakashim Exp nakashim $";
d1446 1
a1446 1
	  else if (op0 && insn[i].imop.mtype == MTYPE_RLOAD) { /* double buffering (st+ld) */
@


1.133
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.132 2022/10/11 08:05:12 nakashim Exp nakashim $";
a4509 1
           conf[i][j].cdw1.ea1op,  /*:  5; mem_opcd */
a5265 1
         int ea1op,   /* MWSAに加え,LDDMQおよびSTOREの場合にもMW有効 */
d5282 1
a5282 1
  int ea0store = (ea1op)||(ea0op&0x10);
@


1.132
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.131 2022/10/07 10:30:22 nakashim Exp nakashim $";
d1446 3
d3332 1
a3332 1
      if (lmmi[i][j].v & ~lmmi[i][j].hcopy & ~lmmi[i][j].vcopy) {
d3363 1
a3363 1
      if (lmmi[i][j].v & ~lmmi[i][j].hcopy) {
d4510 1
d4955 1
a4955 1
  if (ea0op) {
d4959 4
d5267 1
d5284 1
a5284 1
  int ea0store = lmmi_v && ((ea0op&0x10)||mwsa==0);
@


1.131
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.130 2022/09/08 09:28:14 nakashim Exp nakashim $";
d3757 6
a3762 1
      if (lmmi_bitmap[j] & (1LL<<i) && lmmi[i][j].ofs) {
d3765 1
a3765 1
	    fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+emax6.lmmi[%d][%d][%d][lmmic].ofs+*((Ushort*)&emax6.lmmi[%d][%d][%d][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)(Uint)(emax6.lmmi[%d][%d][%d][lmmic].top+emax6.lmmi[%d][%d][%d][lmmic].ofs);\n", c, i, j, c, i, j, c, i, j, c, i, j, c, i, j, c, i, j);
d3768 1
a3768 1
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[0][%d][%d][lmmic].top+emax6.lmmi[0][%d][%d][lmmic].ofs+*((Ushort*)&emax6.lmmi[0][%d][%d][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)(Uint)(emax6.lmmi[0][%d][%d][lmmic].top+emax6.lmmi[0][%d][%d][lmmic].ofs);\n", i, j, i, j, i, j, i, j, i, j, i, j);
@


1.130
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.129 2022/03/13 23:50:35 nakashim Exp nakashim $";
d620 2
d640 1
@


1.129
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.128 2022/03/04 04:05:31 nakashim Exp nakashim $";
d4497 11
a4507 7
	   lmmi[i][j].v,            /*:  1; valid */
           conf[i][j].cdw1.ea0op,   /*:  5; mem_opcd */
           conf[i][j].cdw2.mwsa,    /*:  1; 0:lmwa,  1:ea0d        */
           conf[i][j].cdw2.mws0,    /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
           conf[i][j].cdw2.mws1,    /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
           conf[i][j].cdw2.mws2,    /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
           conf[i][j].cdw2.mws3,    /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
d4892 1
a4892 1
  draw_arrow(cxb_x,    cxb_y-160+cs0*5+10, cxb_x,    cxb_y-5,  thi, col);
d4902 1
a4902 1
  draw_arrow(cxb_x+10, cxb_y-160+cs1*5+10, cxb_x+10, cxb_y-5, thi, col);
d4912 1
a4912 1
  draw_arrow(cxb_x+20, cxb_y-160+cs2*5+10, cxb_x+20, cxb_y-5, thi, col);
d4922 1
a4922 1
  draw_arrow(cxb_x+30, cxb_y-160+cs3*5+10, cxb_x+30, cxb_y-5, thi, col);
d5256 4
d5304 1
a5304 1
  draw_arrow(lmb_x+390,   lmb_y-370, lmb_x+390, lmb_y-60,  thi, col);
d5330 1
a5330 1
  draw_arrow(lmb_x+270,   lmb_y-370, lmb_x+270, lmb_y-60,  thi, col);
d5356 1
a5356 1
  draw_arrow(lmb_x+150,   lmb_y-370, lmb_x+150, lmb_y-60,  thi, col);
d5382 1
a5382 1
  draw_arrow(lmb_x+30,    lmb_y-370, lmb_x+30,  lmb_y-60,  thi, col);
@


1.128
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.127 2022/03/04 02:49:45 nakashim Exp nakashim $";
d3430 1
a3430 1
  fprintf(ofile, "\t  int i,j;\n");
d3432 8
@


1.127
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.126 2022/03/03 14:57:51 nakashim Exp nakashim $";
d3444 1
a3444 1
  fprintf(ofile, "\t  while (((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat & 0xf0); //LMRING_BUSY \n");
d3455 1
a3455 1
    fprintf(ofile, "\t  while (((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat & 0x0f); //EXRING_BUSY\n");
d3782 1
a3782 1
  fprintf(ofile, "\twhile (((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat & 0xff); //LMRING_BUSY|EXRING_BUSY\n");
@


1.126
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.125 2022/02/24 07:38:11 nakashim Exp nakashim $";
d3782 1
a3782 1
  fprintf(ofile, "\twhile (((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat); //LMRING_BUSY|EXRING_BUSY\n");
@


1.125
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.124 2022/02/19 00:49:30 nakashim Exp nakashim $";
d3436 1
a3436 1
  fprintf(ofile, "\t  for (i=0; i<sizeof(conf)/sizeof(Dll); i++)\n");
@


1.124
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.123 2022/02/17 03:43:18 nakashim Exp nakashim $";
d3529 64
d3637 1
@


1.123
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.122 2022/01/25 23:55:20 nakashim Exp nakashim $";
d830 4
a840 4
      case OP_ALWAYS:
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.src1v, insn[i].imex.src1h, rdep);
        get_valid_row(ITYPE_MEX, 0, insn[i].imex.src2v, insn[i].imex.src2h, rdep);
        break;
d2720 3
a2728 3
	case OP_ALWAYS: /* base++ 対応 */
	  fprintf(s2fil, "awoo1[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo1[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", j, j);
	  break;
d2789 3
a2797 3
	case OP_ALWAYS: /* base++ 対応 */
	  fprintf(s2fil, "awoo0[CHIP][%d] = (Ull)(INIT0[CHIP]?base:awoo0[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", j, j);
	  break;
d4390 1
a4390 1
	   conf[i][j].cdw0.mex0op,  /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
d4403 1
a4403 1
	   conf[i][j].cdw0.mex1op,  /* mex(sparse matrix) conditional 0:NOP, 1:OP_CMPA_LE, 2:GE, 3:AL */
d4945 1
a4945 1
  snprintf(opcd, E0LABELMAX, "%s-%d-%d", mex0op==OP_CMPA_LE?"LE":mex0op==OP_CMPA_GE?"GE":mex0op==OP_ALWAYS?"AL":"NA", mex0init, mex0dist);
d5068 1
a5068 1
  snprintf(opcd, E1LABELMAX, "%s-%d-%d", mex1op==OP_CMPA_LE?"LE":mex1op==OP_CMPA_GE?"GE":mex1op==OP_ALWAYS?"AL":"NA", mex1init, mex1dist);
@


1.122
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.121 2022/01/04 10:50:49 nakashim Exp nakashim $";
d1556 2
a1557 1
          if (dmop1->mtype == MTYPE_RLOAD && dmex1->op == OP_CMPA_LE || dmex1->op == OP_CMPA_GE) {
d1560 4
d1565 19
a1583 19
	  case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
	  case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
	  case 6: /* lmx */                                     conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
	  case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
	  }
	  conf[last_row][last_col].cdw2.lmm_mode = 3;
	  lmmi[last_row][last_col].v     = 1;
	  lmmi[last_row][last_col].rw    = rw;
	  lmmi[last_row][last_col].f     = f;
	  lmmi[last_row][last_col].p     = p;
	  lmmi[last_row][last_col].blk   = dmop1->blk;
	  lmmi[last_row][last_col].cidx  = id[dmop1->toph].cidx;
	  lmmi[last_row][last_col].len   = id[dmop1->lenh].val-1;
	  lmmi[last_row][last_col].ofs   = 0; /* initial value */
	  lmmi[last_row][last_col].top   = (Ull)id[dmop1->toph].name;
	  lmmx[last_row][last_col].forcev= dmop1->forcev;
	  lmmx[last_row][last_col].forceh= dmop1->forceh;
	  lmmx[last_row][last_col].lenv  = dmop1->lenv;
	  lmmx[last_row][last_col].lenh  = dmop1->lenh;
d1645 1
d1649 2
a1650 3
          else { /* includes dmop0->mtype == MTYPE_RLOAD && (dmex0->op == OP_CMPA_LE || dmex0->op == OP_CMPA_GE) */
	    int last_col_mex;
	    if (dmex0->op == OP_CMPA_LE || dmex0->op == OP_CMPA_GE) {
d1656 1
a1656 1
	      last_col_mex = last_col-1;
d1659 4
a1662 2
	    else /* normal mop w/o mex */
	      last_col_mex = last_col;
@


1.121
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.120 2022/01/04 10:47:19 nakashim Exp nakashim $";
d3376 2
a3377 2
    for (i=0; i<EMAX_DEPTH; i++) {
      for (j=0; j<EMAX_WIDTH; j++) {
d3399 2
a3400 2
    fprintf(ofile, "\t  for (i=0; i<%d; i++) {\n", EMAX_DEPTH);
    fprintf(ofile, "\t    for (j=0; j<%d; j++) {\n", EMAX_WIDTH);
d3636 2
a3637 2
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
d3690 2
a3691 2
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
@


1.120
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.119 2022/01/04 10:42:52 nakashim Exp nakashim $";
d2649 1
a2650 1
    fprintf(s2fil, "SCBR[%d].deq[CHIP] = 1-SCBR[%d].deq[CHIP];\n", (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH);
@


1.119
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.118 2022/01/04 10:36:31 nakashim Exp nakashim $";
d2633 1
a2633 1
    fprintf(s2fil, "Uint uLOOP[%d], enq0[%d], enq1[%d];\n", EMAX_NCHIP, EMAX_NCHIP, EMAX_NCHIP);
d2649 1
a2649 2
    fprintf(s2fil, "enq0[CHIP] = SCBR[%d].enq[CHIP];\n", (i+EMAX_DEPTH-1)%EMAX_DEPTH);
    fprintf(s2fil, "enq1[CHIP] = SCBR[%d].enq[CHIP];\n", i);
d2676 1
a2676 1
	fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", i, j*UNIT_WIDTH+0, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts0);
d2680 1
a2680 1
	fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", i, j*UNIT_WIDTH+1, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts1);
d2684 1
a2684 1
	fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", i, j*UNIT_WIDTH+2, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts2);
d2688 1
a2688 1
	fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", i, j*UNIT_WIDTH+3, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts3);
d2704 2
a2705 2
	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][enq1[CHIP]][%d]:SCM1[%d].b[CHIP][%d]) : awoo1[CHIP][%d];\n", ea1bs, ea1bs, (i+EMAX_DEPTH-1)%EMAX_DEPTH, eab, i, j, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "offs = eam(%d ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : SCM1[%d].o[CHIP][%d], %d);\n", ea1os, (i+EMAX_DEPTH-1)%EMAX_DEPTH, eao, i, j, (Uint)conf[i][j].cdw1.ea1msk);
d2737 1
a2737 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq1[CHIP]][%d] = load64;\n", i, j*UNIT_WIDTH+1);
d2741 1
a2741 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq1[CHIP]][%d] = load64 >> (adr&7)*8;\n", i, j*UNIT_WIDTH+1);
d2745 1
a2745 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq1[CHIP]][%d] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, j*UNIT_WIDTH+1);
d2749 1
a2749 1
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, j*UNIT_WIDTH+1);
d2752 1
a2752 1
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, j*UNIT_WIDTH+1);
d2755 4
a2758 4
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, j*UNIT_WIDTH+0);
          fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, j*UNIT_WIDTH+1);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, j*UNIT_WIDTH+2);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, j*UNIT_WIDTH+3);
d2773 2
a2774 2
	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][enq1[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : awoo0[CHIP][%d];\n", ea0bs, ea0bs, (i+EMAX_DEPTH-1)%EMAX_DEPTH, eab, i, j, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "offs = eam(%d ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", ea0os, (i+EMAX_DEPTH-1)%EMAX_DEPTH, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
d2806 1
a2806 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq1[CHIP]][%d] = load64;\n", i, j*UNIT_WIDTH+0);
d2810 1
a2810 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq1[CHIP]][%d] = load64 >> (adr&7)*8;\n", i, j*UNIT_WIDTH+0);
d2814 1
a2814 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][enq1[CHIP]][%d] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, j*UNIT_WIDTH+0);
d2818 1
a2818 1
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, j*UNIT_WIDTH+0);
d2821 1
a2821 1
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, j*UNIT_WIDTH+0);
d2824 4
a2827 4
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, j*UNIT_WIDTH+0);
          fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, j*UNIT_WIDTH+1);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, j*UNIT_WIDTH+2);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, j*UNIT_WIDTH+3);
d2836 1
a2836 1
	fprintf(s2fil, "mexd1[CHIP][%d] = SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", j, i, j*UNIT_WIDTH+1);
d2840 1
a2840 1
	fprintf(s2fil, "mexd0[CHIP][%d] = SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", j, i, j*UNIT_WIDTH+0);
d2867 1
a2867 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
d2874 3
a2876 3
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n",                                    !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs, ex3exp);
d2894 3
a2896 3
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n",                                    !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs, ex3exp);
d2911 2
a2912 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
d2925 2
a2926 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
d2938 3
a2940 3
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n",                                    !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs, ex3exp);
d2948 3
a2950 3
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n",                                    !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs, ex3exp);
d2958 2
a2959 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
d2967 2
a2968 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
d2976 2
a2977 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
d2983 2
a2984 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
d2990 2
a2991 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
d2997 2
a2998 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
d3004 2
a3005 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
d3011 2
a3012 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
d3018 3
a3020 3
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][enq1[CHIP]][%d], %d);\n",                                    !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs, ex3exp);
d3038 1
a3038 1
	  fprintf(s2fil, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs);
d3042 1
a3042 1
	  fprintf(s2fil, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs);
d3046 1
a3046 1
	  fprintf(s2fil, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs);
d3060 1
a3060 1
	  fprintf(s2fil, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs);
d3066 1
a3066 1
	  fprintf(s2fil, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ex3brs);
d3077 1
a3077 1
	  fprintf(s2fil, "SCBR[%d].r[CHIP][enq1[CHIP]][%d] = alud[CHIP][%d];\n", i, j*UNIT_WIDTH+2, j);
d3094 4
a3097 4
	fprintf(s2fil, "cs0 = SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, cs0);
	fprintf(s2fil, "cs1 = SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, cs1);
	fprintf(s2fil, "cs2 = SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, cs2);
	fprintf(s2fil, "cs3 = SCBR[%d].r[CHIP][enq1[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, cs3);
d3120 2
a3121 2
	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][enq1[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : awoo0[CHIP][%d];\n", ea0bs, ea0bs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, eab, i, j, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "offs = eam(%d ? SCBR[%d].r[CHIP][enq1[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", ea0os, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
d3145 2
a3146 2
	  fprintf(s2fil, "if (cex>>1&1) *((Uint*)(adr&~7LL)+1) = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][enq1[CHIP]][%d])>>32;\n", mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts0);
	  fprintf(s2fil, "if (cex   &1) *((Uint*)(adr&~7LL)  ) = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][enq1[CHIP]][%d]);\n",     mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts0);
d3149 1
a3149 1
	  fprintf(s2fil, "if (cex   &1) *(Uint*)(adr&~3LL) = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][enq1[CHIP]][%d]);\n", mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts0);
d3152 1
a3152 1
	  fprintf(s2fil, "if (cex   &1) *(Uchar*)adr = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][enq1[CHIP]][%d]);\n", mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts0);
d3155 4
a3158 4
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+0) = (%d==1? alud[CHIP][0] : SCBR[%d].r[CHIP][enq1[CHIP]][%d]);\n", mws0, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts0);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+1) = (%d==1? alud[CHIP][1] : SCBR[%d].r[CHIP][enq1[CHIP]][%d]);\n", mws1, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts1);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+2) = (%d==1? alud[CHIP][2] : SCBR[%d].r[CHIP][enq1[CHIP]][%d]);\n", mws2, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts2);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+3) = (%d==1? alud[CHIP][3] : SCBR[%d].r[CHIP][enq1[CHIP]][%d]);\n", mws3, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, ts3);
@


1.118
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.117 2022/01/04 09:27:54 nakashim Exp nakashim $";
d3039 1
a3039 1
	  fprintf(s2fil, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
d3043 1
a3043 1
	  fprintf(s2fil, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
d3047 1
a3047 1
	  fprintf(s2fil, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
d3061 1
a3061 1
	  fprintf(s2fil, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
d3067 1
a3067 1
	  fprintf(s2fil, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
d3078 1
a3078 1
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = alud[CHIP][%d];\n", i, i, j*UNIT_WIDTH+2, j);
d3095 4
a3098 4
	fprintf(s2fil, "cs0 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs0);
	fprintf(s2fil, "cs1 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs1);
	fprintf(s2fil, "cs2 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs2);
	fprintf(s2fil, "cs3 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs3);
d3121 2
a3122 2
	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : awoo0[CHIP][%d];\n", ea0bs, ea0bs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, eab, i, j, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "offs = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", ea0os, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
d3146 2
a3147 2
	  fprintf(s2fil, "if (cex>>1&1) *((Uint*)(adr&~7LL)+1) = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d])>>32;\n", mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
	  fprintf(s2fil, "if (cex   &1) *((Uint*)(adr&~7LL)  ) = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n",     mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3150 1
a3150 1
	  fprintf(s2fil, "if (cex   &1) *(Uint*)(adr&~3LL) = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3153 1
a3153 1
	  fprintf(s2fil, "if (cex   &1) *(Uchar*)adr = (%d==1? alud[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3156 4
a3159 4
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+0) = (%d==1? alud[CHIP][0] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+1) = (%d==1? alud[CHIP][1] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws1, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts1);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+2) = (%d==1? alud[CHIP][2] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws2, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts2);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+3) = (%d==1? alud[CHIP][3] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws3, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts3);
@


1.117
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.116 2022/01/04 08:36:13 nakashim Exp nakashim $";
d2868 1
a2868 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
d2875 3
a2877 3
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, ex3exp);
d2895 3
a2897 3
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, ex3exp);
d2912 2
a2913 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
d2926 2
a2927 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
d2939 3
a2941 3
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, ex3exp);
d2949 3
a2951 3
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, ex3exp);
d2959 2
a2960 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
d2968 2
a2969 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
d2977 2
a2978 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
d2984 2
a2985 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
d2991 2
a2992 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
d2998 2
a2999 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
d3005 2
a3006 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
d3012 2
a3013 2
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
d3019 3
a3021 3
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : alud[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, j, ex1exp);
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&!INIT0[CHIP]) ? 0 : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, ex3exp);
@


1.116
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.115 2022/01/04 07:02:45 nakashim Exp nakashim $";
d2807 1
a2807 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = load64;\n", i, i, j*UNIT_WIDTH+0);
d2811 1
a2811 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+0);
d2815 1
a2815 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+0);
d2819 1
a2819 1
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, i, j*UNIT_WIDTH+0);
d2822 1
a2822 1
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, i, j*UNIT_WIDTH+0);
d2825 4
a2828 4
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, i, j*UNIT_WIDTH+0);
          fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, i, j*UNIT_WIDTH+1);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, i, j*UNIT_WIDTH+2);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, i, j*UNIT_WIDTH+3);
d2837 1
a2837 1
	fprintf(s2fil, "mexd1[CHIP][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", j, i, i, j*UNIT_WIDTH+1);
d2841 1
a2841 1
	fprintf(s2fil, "mexd0[CHIP][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", j, i, i, j*UNIT_WIDTH+0);
@


1.115
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.114 2022/01/03 12:08:31 nakashim Exp nakashim $";
d2633 1
a2633 1
    fprintf(s2fil, "Uint uLOOP[%d], enq[%d];\n", EMAX_NCHIP, EMAX_NCHIP);
d2649 2
a2650 1
    fprintf(s2fil, "enq[CHIP] = SCBR[%d].enq[CHIP];\n", i);
d2677 1
a2677 1
	fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+0, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, ts0);
d2681 1
a2681 1
	fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+1, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, ts1);
d2685 1
a2685 1
	fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+2, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, ts2);
d2689 1
a2689 1
	fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+3, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, ts3);
d2705 2
a2706 2
	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM1[%d].b[CHIP][%d]) : awoo1[CHIP][%d];\n", ea1bs, ea1bs, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, eab, i, j, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "offs = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM1[%d].o[CHIP][%d], %d);\n", ea1os, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, eao, i, j, (Uint)conf[i][j].cdw1.ea1msk);
d2738 1
a2738 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = load64;\n", i, i, j*UNIT_WIDTH+1);
d2742 1
a2742 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+1);
d2746 1
a2746 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+1);
d2750 1
a2750 1
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, i, j*UNIT_WIDTH+1);
d2753 1
a2753 1
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, i, j*UNIT_WIDTH+1);
d2756 4
a2759 4
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, i, j*UNIT_WIDTH+0);
          fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, i, j*UNIT_WIDTH+1);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, i, j*UNIT_WIDTH+2);
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, i, j*UNIT_WIDTH+3);
d2774 2
a2775 2
	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : awoo0[CHIP][%d];\n", ea0bs, ea0bs, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, eab, i, j, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "offs = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", ea0os, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
@


1.114
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.113 2022/01/03 10:35:46 nakashim Exp nakashim $";
d2616 1
a2616 1
    fprintf(s1fil, "struct  sc_pth   {int dmy[4];}           sc_pth[%d];\n", EMAX_DEPTH);
d2618 2
a2619 3
    fprintf(s1fil, "struct  {unsigned long long b[%d][%d],o[%d][%d],awoo[%d][%d],d[%d][%d];} SCM0[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* eag0 */
    fprintf(s1fil, "struct  {unsigned long long b[%d][%d],o[%d][%d],awoo[%d][%d],d[%d][%d];} SCM1[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* eag1 */
    fprintf(s1fil, "struct  {unsigned long long r[%d][%d];}                                  SCAR[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* alu  */
d2633 2
a2634 1
    fprintf(s2fil, "Uint uLOOP[%d];\n", EMAX_NCHIP);
d2649 1
d2704 1
a2704 1
	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM1[%d].b[CHIP][%d]) : SCM1[%d].awoo[CHIP][%d];\n", ea1bs, ea1bs, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
d2711 1
a2711 1
	  fprintf(s2fil, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?base:SCM1[%d].awoo[CHIP][%d]);\n", i, j, i, j);
d2714 1
a2714 1
	  fprintf(s2fil, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?base:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM0[%d].d[CHIP][%d]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d]>>32)<=(SCM0[%d].d[CHIP][%d]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j);
d2717 1
a2717 1
	  fprintf(s2fil, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?base:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM1[%d].d[CHIP][%d]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d]>>32)>=(SCM0[%d].d[CHIP][%d]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j);
d2720 1
a2720 1
	  fprintf(s2fil, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?base:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j);
d2728 1
a2728 1
	fprintf(s2fil, "adr = (Uint)(SCM1[%d].awoo[CHIP][%d] + offs);\n", i, j, i, j);
d2730 1
a2730 1
	fprintf(s2fil, "adr = (Ull)(SCM1[%d].awoo[CHIP][%d] + offs);\n", i, j, i, j);
d2773 1
a2773 1
	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : SCM0[%d].awoo[CHIP][%d];\n", ea0bs, ea0bs, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
d2780 1
a2780 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?base:SCM0[%d].awoo[CHIP][%d]);\n", i, j, i, j);
d2783 1
a2783 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?base:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM0[%d].d[CHIP][%d]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d]>>32)<=(SCM0[%d].d[CHIP][%d]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j);
d2786 1
a2786 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?base:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM1[%d].d[CHIP][%d]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d]>>32)>=(SCM0[%d].d[CHIP][%d]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j);
d2789 1
a2789 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?base:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j);
d2797 1
a2797 1
	fprintf(s2fil, "adr = (Uint)(SCM0[%d].awoo[CHIP][%d] + offs);\n", i, j, i, j);
d2799 1
a2799 1
	fprintf(s2fil, "adr = (Ull)(SCM0[%d].awoo[CHIP][%d] + offs);\n", i, j, i, j);
d2836 1
a2836 1
	fprintf(s2fil, "SCM1[%d].d[CHIP][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, j, i, i, j*UNIT_WIDTH+1);
d2840 1
a2840 1
	fprintf(s2fil, "SCM0[%d].d[CHIP][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, j, i, i, j*UNIT_WIDTH+0);
d2867 1
a2867 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2874 1
a2874 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2894 1
a2894 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2911 1
a2911 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2925 1
a2925 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2938 1
a2938 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2948 1
a2948 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2958 1
a2958 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2967 1
a2967 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2976 1
a2976 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2983 1
a2983 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2990 1
a2990 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d2997 1
a2997 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d3004 1
a3004 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d3011 1
a3011 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d3018 1
a3018 1
	  fprintf(s2fil, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
d3057 1
a3057 1
	  fprintf(s2fil, "SCAR[%d].r[CHIP][%d] = ex2_outd;\n", i, j);
d3063 1
a3063 1
	  fprintf(s2fil, "SCAR[%d].r[CHIP][%d] = t1 | t0;\n", i, j);
d3069 1
a3069 1
	  fprintf(s2fil, "SCAR[%d].r[CHIP][%d] = t1 | t0;\n", i, j);
d3077 1
a3077 1
	  fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCAR[%d].r[CHIP][%d];\n", i, i, j*UNIT_WIDTH+2, i, j);
d3120 1
a3120 1
	fprintf(s2fil, "base = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : SCM0[%d].awoo[CHIP][%d];\n", ea0bs, ea0bs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
d3127 1
a3127 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?base:SCM0[%d].awoo[CHIP][%d]);\n", i, j, i, j);
d3130 1
a3130 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?base:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j);
d3138 1
a3138 1
	fprintf(s2fil, "adr = (Uint)(SCM0[%d].awoo[CHIP][%d] + offs);\n", i, j, i, j);
d3140 1
a3140 1
	fprintf(s2fil, "adr = (Ull)(SCM0[%d].awoo[CHIP][%d] + offs);\n", i, j, i, j);
d3145 2
a3146 2
	  fprintf(s2fil, "if (cex>>1&1) *((Uint*)(adr&~7LL)+1) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d])>>32;\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
	  fprintf(s2fil, "if (cex   &1) *((Uint*)(adr&~7LL)  ) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n",     mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3149 1
a3149 1
	  fprintf(s2fil, "if (cex   &1) *(Uint*)(adr&~3LL) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3152 1
a3152 1
	  fprintf(s2fil, "if (cex   &1) *(Uchar*)adr = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3155 4
a3158 4
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+0) = (%d==1? SCAR[%d].r[CHIP][0] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+1) = (%d==1? SCAR[%d].r[CHIP][1] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws1, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts1);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+2) = (%d==1? SCAR[%d].r[CHIP][2] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws2, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts2);
	  fprintf(s2fil, "*((Ull*)(adr&~31LL)+3) = (%d==1? SCAR[%d].r[CHIP][3] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws3, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts3);
@


1.113
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.112 2022/01/03 08:41:06 nakashim Exp nakashim $";
d2649 1
a2651 1
    fprintf(s2fil, "SCBR[%d].deq[CHIP] = 1-SCBR[%d].deq[CHIP];\n", (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH);
d3167 1
a3168 1
    fprintf(s2fil, "SCBR[%d].enq[CHIP] = 1-SCBR[%d].enq[CHIP];\n", i, i);
@


1.112
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.111 2021/12/25 23:56:03 nakashim Exp nakashim $";
d2648 1
a2648 3
    fprintf(s2fil, "if (uLOOP[CHIP]==0) continue;\n", i);
  //fprintf(s2fil, "printf(\"%d: uLOOP[%%d]=%%d\\n\", (Uint)CHIP, (Uint)uLOOP[CHIP]);\n", i);
    fprintf(s2fil, "if ((%d && SCBR[%d].enq[CHIP]==SCBR[%d].deq[CHIP]) || (%d<%d && SCBR[%d].enq[CHIP]!=SCBR[%d].deq[CHIP])) continue;\n", i, (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, last_row, i, i);
d2650 1
a2650 1
    fprintf(s2fil, "INIT0[CHIP]=(uLOOP[CHIP]-(uLOOP[CHIP]/LOOP0*LOOP0)==0);\n");
@


1.111
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.110 2021/12/25 10:59:45 nakashim Exp nakashim $";
d2621 1
a2621 1
    fprintf(s1fil, "volatile struct {unsigned long long r[%d][2][%d],enq[%d],d0[4],deq[%d],d1[4];}   SCBR[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH*UNIT_WIDTH, EMAX_NCHIP, EMAX_NCHIP, EMAX_DEPTH); /* br   */
@


1.110
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.109 2021/12/25 07:01:53 nakashim Exp nakashim $";
d3174 1
a3176 1
  fprintf(s2fil, "/* EMAXSC end */\n");
@


1.109
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.108 2021/12/25 06:01:16 nakashim Exp nakashim $";
d2621 1
a2621 1
    fprintf(s1fil, "struct  {unsigned long long r[%d][2][%d],enq[%d],d0[4],deq[%d],d1[4];}   SCBR[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH*UNIT_WIDTH, EMAX_NCHIP, EMAX_NCHIP, EMAX_DEPTH); /* br   */
@


1.108
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.107 2021/12/25 02:44:11 nakashim Exp nakashim $";
a3172 1
    fprintf(s2fil, "printf(\"while end %d\\n\");\n", i); /* while (1) */
@


1.107
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.106 2021/12/24 13:51:42 nakashim Exp nakashim $";
d2673 22
d3076 4
a3168 24
    for (j=0; j<EMAX_WIDTH; j++) {
      fprintf(s2fil, "{\n");
      /*********************************************************************************************************/
      if (conf[i][j].cdw2.brs0 == 2) { /* 0:off, 1:mr10, 2:tr0, 3:mr0  */
	int ts0   = conf[i][j].cdw2.ts0;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+0, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts0);
      }
      if (conf[i][j].cdw2.brs1 == 2) { /* 0:off, 1:mr10, 2:tr0, 3:mr0  */
	int ts1   = conf[i][j].cdw2.ts1;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+1, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts1);
      }
      if (conf[i][j].cdw2.brs2 == 2) { /* 0:off, 1:mr12, 2:tr2, 3:exdr */
	int ts2   = conf[i][j].cdw2.ts2;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+2, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts2);
      }
      if (conf[i][j].cdw2.brs2 == 3) { /* 0:off, 1:mr12, 2:tr2, 3:exdr */
	fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCAR[%d].r[CHIP][%d];\n", i, i, j*UNIT_WIDTH+2, i, j);
      }
      if (conf[i][j].cdw2.brs3 == 2) { /* 0:off, 1:mr13, 2:tr3         */
	int ts3   = conf[i][j].cdw2.ts3;    /* 0:br0_0, 1:br0_1, ... 15:br3_3 */
	fprintf(s2fil, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+3, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts3);
      }
      fprintf(s2fil, "}\n");
    }
@


1.106
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.105 2021/12/23 10:41:24 nakashim Exp nakashim $";
d2854 2
a2855 2
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
d2874 2
a2875 2
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
d2891 1
a2891 1
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
d2905 1
a2905 1
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
d2918 2
a2919 2
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
d2928 2
a2929 2
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
d2938 1
a2938 1
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
d2947 1
a2947 1
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
d2956 1
a2956 1
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
d2963 1
a2963 1
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
d2970 1
a2970 1
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
d2977 1
a2977 1
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
d2984 1
a2984 1
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
d2991 1
a2991 1
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
d2998 2
a2999 2
	  fprintf(s2fil, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(s2fil, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
@


1.105
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.104 2021/12/23 09:46:04 nakashim Exp nakashim $";
d2618 4
a2621 4
    fprintf(s1fil, "struct  {unsigned long long b[%d][%d],o[%d][%d],awoo[%d][%d],d[%d][%d][2];} SCM0[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* eag0 */
    fprintf(s1fil, "struct  {unsigned long long b[%d][%d],o[%d][%d],awoo[%d][%d],d[%d][%d][2];} SCM1[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* eag1 */
    fprintf(s1fil, "struct  {unsigned long long r[%d][%d];}                                     SCAR[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* alu  */
    fprintf(s1fil, "struct  {unsigned long long r[%d][2][%d],enq[%d],d0[4],deq[%d],d1[4];}      SCBR[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH*UNIT_WIDTH, EMAX_NCHIP, EMAX_NCHIP, EMAX_DEPTH); /* br   */
d2673 1
a2673 1
      fprintf(s2fil, "{ Ull adr, mexdist, load64;\n");
d2677 1
a2677 1
      if (conf[i][j].cdw1.ea1op && conf[i][j].cdw1.ea1op < OP_IM_BUFRD) { /* LOAD */
d2683 5
a2687 5
	fprintf(s2fil, "SCM1[%d].b[CHIP][%d] = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM1[%d].b[CHIP][%d]) : SCM1[%d].awoo[CHIP][%d];\n", i, j, ea1bs, ea1bs, i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "SCM1[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM1[%d].o[CHIP][%d], %d);\n", i, j, ea1os, i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea1msk);
	fprintf(s2fil, "mexdist = (%d || INIT0[CHIP]) ? 0 : %d;\n", conf[i][j].cdw0.mex1op, conf[i][j].cdw0.mex1dist==0? 0: conf[i][j].cdw0.mex1dist==1? 1: conf[i][j].cdw0.mex1dist==2? 2:
                                                                                      conf[i][j].cdw0.mex1dist==3? 4: conf[i][j].cdw0.mex1dist==4? 8: conf[i][j].cdw0.mex1dist==5?16:
                                                                                      conf[i][j].cdw0.mex1dist==6?32:64);
d2690 1
a2690 1
	  fprintf(s2fil, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d2693 1
a2693 1
	  fprintf(s2fil, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM1[%d].d[CHIP][%d][0]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d][1]>>32)<=(SCM1[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2696 1
a2696 1
	  fprintf(s2fil, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM1[%d].d[CHIP][%d][1]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d][1]>>32)>=(SCM1[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2699 1
a2699 1
	  fprintf(s2fil, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j, i, j);
d2707 1
a2707 1
	fprintf(s2fil, "adr = (Uint)(SCM1[%d].awoo[CHIP][%d] + SCM1[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2709 1
a2709 1
	fprintf(s2fil, "adr = (Ull)(SCM1[%d].awoo[CHIP][%d] + SCM1[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2716 1
a2716 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = load64;\n", i, i, j*UNIT_WIDTH+1, i, j);
d2720 1
a2720 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+1, i, j);
d2724 1
a2724 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+1, i, j);
d2746 1
a2746 1
      if (conf[i][j].cdw1.ea0op && conf[i][j].cdw1.ea0op < OP_IM_BUFRD) { /* LOAD */
d2752 5
a2756 5
	fprintf(s2fil, "SCM0[%d].b[CHIP][%d] = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : SCM0[%d].awoo[CHIP][%d];\n", i, j, ea0bs, ea0bs, i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "SCM0[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", i, j, ea0os, i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
	fprintf(s2fil, "mexdist = (%d || INIT0[CHIP]) ? 0 : %d;\n", conf[i][j].cdw0.mex0op, conf[i][j].cdw0.mex0dist==0? 0: conf[i][j].cdw0.mex0dist==1? 1: conf[i][j].cdw0.mex0dist==2? 2:
                                                                                      conf[i][j].cdw0.mex0dist==3? 4: conf[i][j].cdw0.mex0dist==4? 8: conf[i][j].cdw0.mex0dist==5?16:
                                                                                      conf[i][j].cdw0.mex0dist==6?32:64);
d2759 1
a2759 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d2762 1
a2762 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM0[%d].d[CHIP][%d][0]>>32)!=0xffffffff && (SCM0[%d].d[CHIP][%d][1]>>32)<=(SCM0[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2765 1
a2765 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM0[%d].d[CHIP][%d][1]>>32)!=0xffffffff && (SCM0[%d].d[CHIP][%d][1]>>32)>=(SCM0[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2768 1
a2768 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j, i, j);
d2776 1
a2776 1
	fprintf(s2fil, "adr = (Uint)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2778 1
a2778 1
	fprintf(s2fil, "adr = (Ull)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2785 1
a2785 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = load64;\n", i, i, j*UNIT_WIDTH+0, i, j);
d2789 1
a2789 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+0, i, j);
d2793 1
a2793 1
	  fprintf(s2fil, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+0, i, j);
d2813 9
d3059 1
a3059 1
      fprintf(s2fil, "{ Ull cs0, cs1, cs2, cs3, cex, adr, mexdist;\n");
d3095 5
a3099 5
	fprintf(s2fil, "SCM0[%d].b[CHIP][%d] = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : SCM0[%d].awoo[CHIP][%d];\n", i, j, ea0bs, ea0bs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(s2fil, "SCM0[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", i, j, ea0os, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
	fprintf(s2fil, "mexdist = (%d || INIT0[CHIP]) ? 0 : %d;\n", conf[i][j].cdw0.mex0op, conf[i][j].cdw0.mex0dist==0? 0: conf[i][j].cdw0.mex0dist==1? 1: conf[i][j].cdw0.mex0dist==2? 2:
                                                                                      conf[i][j].cdw0.mex0dist==3? 4: conf[i][j].cdw0.mex0dist==4? 8: conf[i][j].cdw0.mex0dist==5?16:
                                                                                      conf[i][j].cdw0.mex0dist==6?32:64);
d3102 1
a3102 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d3105 1
a3105 1
	  fprintf(s2fil, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j, i, j);
d3113 1
a3113 1
	fprintf(s2fil, "adr = (Uint)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d3115 1
a3115 1
	fprintf(s2fil, "adr = (Ull)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d3277 1
a3277 1
    fprintf(ofile, "sc_param[%d].LOOP0=LOOP0; sc_param[%d].LOOP1=LOOP1; pthread_create((pthread_t*)&sc_pth[%d], 0, emax6sc_pth_%s_%02.2d, &sc_param[%d]);\n", i, i, i, id[current_prefix].name, i);
@


1.104
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.103 2021/12/23 06:26:39 nakashim Exp nakashim $";
d2621 1
a2621 1
    fprintf(s1fil, "volatile struct  {unsigned long long r[%d][2][%d],enq[%d],d0[4],deq[%d],d1[4];}      SCBR[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH*UNIT_WIDTH, EMAX_NCHIP, EMAX_NCHIP, EMAX_DEPTH); /* br   */
d3162 1
@


1.103
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.102 2021/12/22 23:39:03 nakashim Exp nakashim $";
d2613 9
a2621 9
  fprintf(pfile1, "/* EMAXSC start */\n");
  if (!pfile1_header_ready) {
    pfile1_header_ready = 1;
    fprintf(pfile1, "struct  sc_pth   {int dmy[4];}           sc_pth[%d];\n", EMAX_DEPTH);
    fprintf(pfile1, "struct  sc_param {int LOOP0; int LOOP1;} sc_param[%d];\n", EMAX_DEPTH);
    fprintf(pfile1, "struct  {unsigned long long b[%d][%d],o[%d][%d],awoo[%d][%d],d[%d][%d][2];} SCM0[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* eag0 */
    fprintf(pfile1, "struct  {unsigned long long b[%d][%d],o[%d][%d],awoo[%d][%d],d[%d][%d][2];} SCM1[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* eag1 */
    fprintf(pfile1, "struct  {unsigned long long r[%d][%d];}                                     SCAR[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* alu  */
    fprintf(pfile1, "struct  {unsigned long long r[%d][2][%d],enq[%d],d0[4],deq[%d],d1[4];}      SCBR[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH*UNIT_WIDTH, EMAX_NCHIP, EMAX_NCHIP, EMAX_DEPTH); /* br   */
d2624 2
a2625 2
    fprintf(pfile1, "void emax6sc_pth_%s_%02.2d(struct sc_param *);\n", id[current_prefix].name, i);
  fprintf(pfile1, "/* EMAXSC end */\n");
d2630 6
a2635 6
    fprintf(pfile2, "/* EMAXSC start */\n");
    fprintf(pfile2, "void emax6sc_pth_%s_%02.2d(struct sc_param *param) {\n", id[current_prefix].name, i);
    fprintf(pfile2, "Ull  CHIP, LOOP0=param->LOOP0, LOOP1=param->LOOP1;\n");
    fprintf(pfile2, "Ull  INIT1[%d], INIT0[%d];\n", EMAX_NCHIP, EMAX_NCHIP);
    fprintf(pfile2, "Uint uLOOP[%d];\n", EMAX_NCHIP);
    fprintf(pfile2, "for (CHIP=0; CHIP<%d; CHIP++) { /* unit%d */\n", current_nchip, i);
d2637 1
a2637 1
      fprintf(pfile2, "LOOP1=1;uLOOP[CHIP]=LOOP0=%s;\n", id[dec[i][j].dexu.ex1h].name);
d2639 1
a2639 1
      fprintf(pfile2, "uLOOP[CHIP]=LOOP1*LOOP0;\n");
d2641 13
a2653 13
      fprintf(pfile2, "LOOP1=1;uLOOP[CHIP]=LOOP0;\n");
    fprintf(pfile2, "}\n");
    fprintf(pfile2, "while (1) {\n");
    fprintf(pfile2, "for (CHIP=0; CHIP<%d; CHIP++)\n", current_nchip);
    fprintf(pfile2, "if (uLOOP[CHIP]) break;\n");
    fprintf(pfile2, "if (CHIP==%d) break;\n", current_nchip);
    fprintf(pfile2, "for (CHIP=0; CHIP<%d; CHIP++) {\n", current_nchip); /* 各unit内でsoft-multithreading */
    fprintf(pfile2, "if (uLOOP[CHIP]==0) continue;\n", i);
  //fprintf(pfile2, "printf(\"%d: uLOOP[%%d]=%%d\\n\", (Uint)CHIP, (Uint)uLOOP[CHIP]);\n", i);
    fprintf(pfile2, "if ((%d && SCBR[%d].enq[CHIP]==SCBR[%d].deq[CHIP]) || (%d<%d && SCBR[%d].enq[CHIP]!=SCBR[%d].deq[CHIP])) continue;\n", i, (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, last_row, i, i);
    fprintf(pfile2, "INIT1[CHIP]=(uLOOP[CHIP]>LOOP1*LOOP0-LOOP0);\n");
    fprintf(pfile2, "INIT0[CHIP]=(uLOOP[CHIP]-(uLOOP[CHIP]/LOOP0*LOOP0)==0);\n");
    fprintf(pfile2, "SCBR[%d].deq[CHIP] = 1-SCBR[%d].deq[CHIP];\n", (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH);
d2673 3
a2675 3
      fprintf(pfile2, "{ Ull adr, mexdist, load64;\n");
      fprintf(pfile2, "  static int emax6_unaligned_load_valid;\n");
      fprintf(pfile2, "  static Ull emax6_unaligned_load_high;\n");
d2683 3
a2685 3
	fprintf(pfile2, "SCM1[%d].b[CHIP][%d] = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM1[%d].b[CHIP][%d]) : SCM1[%d].awoo[CHIP][%d];\n", i, j, ea1bs, ea1bs, i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(pfile2, "SCM1[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM1[%d].o[CHIP][%d], %d);\n", i, j, ea1os, i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea1msk);
	fprintf(pfile2, "mexdist = (%d || INIT0[CHIP]) ? 0 : %d;\n", conf[i][j].cdw0.mex1op, conf[i][j].cdw0.mex1dist==0? 0: conf[i][j].cdw0.mex1dist==1? 1: conf[i][j].cdw0.mex1dist==2? 2:
d2690 1
a2690 1
	  fprintf(pfile2, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d2693 1
a2693 1
	  fprintf(pfile2, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM1[%d].d[CHIP][%d][0]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d][1]>>32)<=(SCM1[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2696 1
a2696 1
	  fprintf(pfile2, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM1[%d].d[CHIP][%d][1]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d][1]>>32)>=(SCM1[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2699 1
a2699 1
	  fprintf(pfile2, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j, i, j);
d2707 1
a2707 1
	fprintf(pfile2, "adr = (Uint)(SCM1[%d].awoo[CHIP][%d] + SCM1[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2709 1
a2709 1
	fprintf(pfile2, "adr = (Ull)(SCM1[%d].awoo[CHIP][%d] + SCM1[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2714 12
a2725 12
	  fprintf(pfile2, "load64 = *(Ull*)(adr&~7LL);\n");
	  fprintf(pfile2, "if ((adr&7) == 0)\n");
	  fprintf(pfile2, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = load64;\n", i, i, j*UNIT_WIDTH+1, i, j);
	  fprintf(pfile2, "else if (!emax6_unaligned_load_valid) { /* BR[][][1] */\n");
	  fprintf(pfile2, "  emax6_unaligned_load_valid = 1;\n");
	  fprintf(pfile2, "  emax6_unaligned_load_high = load64;\n");
	  fprintf(pfile2, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+1, i, j);
	  fprintf(pfile2, "}\n");
	  fprintf(pfile2, "else { /* BR[][][0] */\n");
	  fprintf(pfile2, "  emax6_unaligned_load_valid = 0;\n");
	  fprintf(pfile2, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+1, i, j);
	  fprintf(pfile2, "}\n");
d2728 1
a2728 1
	  fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, i, j*UNIT_WIDTH+1);
d2731 1
a2731 1
	  fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, i, j*UNIT_WIDTH+1);
d2734 4
a2737 4
	  fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, i, j*UNIT_WIDTH+0);
          fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, i, j*UNIT_WIDTH+1);
	  fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, i, j*UNIT_WIDTH+2);
	  fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, i, j*UNIT_WIDTH+3);
d2752 3
a2754 3
	fprintf(pfile2, "SCM0[%d].b[CHIP][%d] = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : SCM0[%d].awoo[CHIP][%d];\n", i, j, ea0bs, ea0bs, i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(pfile2, "SCM0[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", i, j, ea0os, i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
	fprintf(pfile2, "mexdist = (%d || INIT0[CHIP]) ? 0 : %d;\n", conf[i][j].cdw0.mex0op, conf[i][j].cdw0.mex0dist==0? 0: conf[i][j].cdw0.mex0dist==1? 1: conf[i][j].cdw0.mex0dist==2? 2:
d2759 1
a2759 1
	  fprintf(pfile2, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d2762 1
a2762 1
	  fprintf(pfile2, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM0[%d].d[CHIP][%d][0]>>32)!=0xffffffff && (SCM0[%d].d[CHIP][%d][1]>>32)<=(SCM0[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2765 1
a2765 1
	  fprintf(pfile2, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM0[%d].d[CHIP][%d][1]>>32)!=0xffffffff && (SCM0[%d].d[CHIP][%d][1]>>32)>=(SCM0[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2768 1
a2768 1
	  fprintf(pfile2, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j, i, j);
d2776 1
a2776 1
	fprintf(pfile2, "adr = (Uint)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2778 1
a2778 1
	fprintf(pfile2, "adr = (Ull)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2783 12
a2794 12
	  fprintf(pfile2, "load64 = *(Ull*)(adr&~7LL);\n");
	  fprintf(pfile2, "if ((adr&7) == 0)\n");
	  fprintf(pfile2, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = load64;\n", i, i, j*UNIT_WIDTH+0, i, j);
	  fprintf(pfile2, "else if (!emax6_unaligned_load_valid) { /* BR[][][1] */\n");
	  fprintf(pfile2, "  emax6_unaligned_load_valid = 1;\n");
	  fprintf(pfile2, "  emax6_unaligned_load_high = load64;\n");
	  fprintf(pfile2, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+0, i, j);
	  fprintf(pfile2, "}\n");
	  fprintf(pfile2, "else { /* BR[][][0] */\n");
	  fprintf(pfile2, "  emax6_unaligned_load_valid = 0;\n");
	  fprintf(pfile2, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+0, i, j);
	  fprintf(pfile2, "}\n");
d2797 1
a2797 1
	  fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, i, j*UNIT_WIDTH+0);
d2800 1
a2800 1
	  fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, i, j*UNIT_WIDTH+0);
d2803 4
a2806 4
	  fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, i, j*UNIT_WIDTH+0);
          fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, i, j*UNIT_WIDTH+1);
	  fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, i, j*UNIT_WIDTH+2);
	  fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, i, j*UNIT_WIDTH+3);
d2813 1
a2813 1
      fprintf(pfile2, "}\n");
d2817 1
a2817 1
      fprintf(pfile2, "{ union { Uint i; float f; } f3, f2, f1, f0; Ull t3, t2, t1, t0, ex1, ex2, ex3, ex4, ex5, c1, c0, ex1_outd, ex2_outd;\n");
d2837 2
a2838 2
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex1_outd = ex1;\n");
d2844 16
a2859 16
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(pfile2, "f1.i = (Uint)(ex1);\n");
	  fprintf(pfile2, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(pfile2, "f3.i = (Uint)(ex3>>32);\n");
	  fprintf(pfile2, "if (f2.i != -1 && f2.i == f3.i) {\n");
	  fprintf(pfile2, "  f2.i = (Uint)(ex2);\n");
	  fprintf(pfile2, "  f3.i = (Uint)(ex3);\n");
	  fprintf(pfile2, "  f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(pfile2, "}\n");
	  fprintf(pfile2, "else {\n");
	  fprintf(pfile2, "  f0.f = f1.f;\n");
	  fprintf(pfile2, "}\n");
	  fprintf(pfile2, "t0 = f0.i;\n");
	  fprintf(pfile2, "ex1_outd = t0;\n");
d2864 14
a2877 14
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(pfile2, "f1.i = (Uint)(ex1>>32);\n");
	  fprintf(pfile2, "f2.i = (Uint)(ex2>>32)^%08.8x;\n", conf[i][j].cdw0.op1==OP_FMA?0:0x80000000);
	  fprintf(pfile2, "f3.i = (Uint)(ex3>>32);\n");
	  fprintf(pfile2, "f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(pfile2, "t2 = f0.i;\n");
	  fprintf(pfile2, "f1.i = (Uint)(ex1);\n");
	  fprintf(pfile2, "f2.i = (Uint)(ex2)^%08.8x;\n", conf[i][j].cdw0.op1==OP_FMA?0:0x80000000);
	  fprintf(pfile2, "f3.i = (Uint)(ex3);\n");
	  fprintf(pfile2, "f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(pfile2, "t0 = f0.i;\n");
	  fprintf(pfile2, "ex1_outd = (t2<<32)|(t0);\n");
d2881 11
a2891 11
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "f1.i = (Uint)(ex1>>32);\n");
	  fprintf(pfile2, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(pfile2, "f0.f = f1.f + f2.f;\n");
	  fprintf(pfile2, "t2 = f0.i;\n");
	  fprintf(pfile2, "f1.i = (Uint)(ex1);\n");
	  fprintf(pfile2, "f2.i = (Uint)(ex2);\n");
	  fprintf(pfile2, "f0.f = f1.f + f2.f;\n");
	  fprintf(pfile2, "t0 = f0.i;\n");
	  fprintf(pfile2, "ex1_outd = (t2<<32)|(t0);\n");
d2895 11
a2905 11
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "f1.i = (Uint)(ex1>>32);\n");
	  fprintf(pfile2, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(pfile2, "f0.f = f1.f * f2.f;\n");
	  fprintf(pfile2, "t2 = f0.i;\n");
	  fprintf(pfile2, "f1.i = (Uint)(ex1);\n");
	  fprintf(pfile2, "f2.i = (Uint)(ex2);\n");
	  fprintf(pfile2, "f0.f = f1.f * f2.f;\n");
	  fprintf(pfile2, "t0 = f0.i;\n");
	  fprintf(pfile2, "ex1_outd = (t2<<32)|(t0);\n");
d2908 8
a2915 8
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(pfile2, "t2 = (ex1>>32&0x00000000ffffffffLL)+((ex2>>32&0x00000000ffffffffLL)+(ex3>>32&0x00000000ffffffffLL));\n");
	  fprintf(pfile2, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile2, "t0 = (ex1    &0x00000000ffffffffLL)+((ex2    &0x00000000ffffffffLL)+(ex3    &0x00000000ffffffffLL));\n");
	  fprintf(pfile2, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile2, "ex1_outd = (t2<<32)|(t0);\n");
d2918 8
a2925 8
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(pfile2, "t2 = (ex1>>32&0x00000000ffffffffLL)-((ex2>>32&0x00000000ffffffffLL)+(ex3>>32&0x00000000ffffffffLL));\n");
	  fprintf(pfile2, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile2, "t0 = (ex1    &0x00000000ffffffffLL)-((ex2    &0x00000000ffffffffLL)+(ex3    &0x00000000ffffffffLL));\n");
	  fprintf(pfile2, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile2, "ex1_outd = (t2<<32)|(t0);\n");
d2928 7
a2934 7
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "t2 = (ex1>>32&0x00000000ffffffffLL)+(ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile2, "t0 = (ex1    &0x00000000ffffffffLL)+(ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile2, "ex1_outd = (t2<<32)|(t0);\n");
d2937 7
a2943 7
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "t2 = (ex1>>32&0x00000000ffffffffLL)-(ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile2, "t0 = (ex1    &0x00000000ffffffffLL)-(ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile2, "ex1_outd = (t2<<32)|(t0);\n");
d2946 5
a2950 5
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "c1 = (ex1>>32&0x00000000ffffffffLL) == (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "c0 = (ex1    &0x00000000ffffffffLL) == (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "ex1_outd = (c1<<32)|c0;\n");
d2953 5
a2957 5
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "c1 = (ex1>>32&0x00000000ffffffffLL) != (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "c0 = (ex1    &0x00000000ffffffffLL) != (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "ex1_outd = (c1<<32)|c0;\n");
d2960 5
a2964 5
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "c1 = (ex1>>32&0x00000000ffffffffLL) < (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "c0 = (ex1    &0x00000000ffffffffLL) < (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "ex1_outd = (c1<<32)|c0;\n");
d2967 5
a2971 5
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "c1 = (ex1>>32&0x00000000ffffffffLL) <= (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "c0 = (ex1    &0x00000000ffffffffLL) <= (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "ex1_outd = (c1<<32)|c0;\n");
d2974 5
a2978 5
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "c1 = (ex1>>32&0x00000000ffffffffLL) > (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "c0 = (ex1    &0x00000000ffffffffLL) > (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "ex1_outd = (c1<<32)|c0;\n");
d2981 5
a2985 5
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "c1 = (ex1>>32&0x00000000ffffffffLL) >= (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "c0 = (ex1    &0x00000000ffffffffLL) >= (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "ex1_outd = (c1<<32)|c0;\n");
d2988 8
a2995 8
	  fprintf(pfile2, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile2, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile2, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(pfile2, "c1 = ex1>>32&1;\n");
	  fprintf(pfile2, "c0 = ex1    &1;\n");
	  fprintf(pfile2, "t2 = c1 ? (ex2&0xffffffff00000000LL) : (ex3&0xffffffff00000000LL);\n");
	  fprintf(pfile2, "t0 = c0 ? (ex2&0x00000000ffffffffLL) : (ex3&0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "ex1_outd = t2 | t0;\n");
d3005 1
a3005 1
	  fprintf(pfile2, "ex2_outd = ex1_outd;\n");
d3008 2
a3009 2
	  fprintf(pfile2, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(pfile2, "ex2_outd = ex1_outd & ex4;\n");
d3012 2
a3013 2
	  fprintf(pfile2, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(pfile2, "ex2_outd = ex1_outd | ex4;\n");
d3016 2
a3017 2
	  fprintf(pfile2, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(pfile2, "ex2_outd = ex1_outd ^ ex4;\n");
d3027 1
a3027 1
	  fprintf(pfile2, "SCAR[%d].r[CHIP][%d] = ex2_outd;\n", i, j);
d3030 4
a3033 4
	  fprintf(pfile2, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(pfile2, "t1 = (Ull)(ex2_outd     &0xffffffff00000000LL)<<ex5;\n");
	  fprintf(pfile2, "t0 = (Ull)(ex2_outd<<ex5&0x00000000ffffffffLL);\n");
	  fprintf(pfile2, "SCAR[%d].r[CHIP][%d] = t1 | t0;\n", i, j);
d3036 4
a3039 4
	  fprintf(pfile2, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(pfile2, "t1 = (Ull)(ex2_outd>>ex5&0xffffffff00000000LL);\n");
	  fprintf(pfile2, "t0 = (Ull)(ex2_outd     &0x00000000ffffffffLL)>>ex5;\n");
	  fprintf(pfile2, "SCAR[%d].r[CHIP][%d] = t1 | t0;\n", i, j);
d3046 1
a3046 1
      fprintf(pfile2, "}\n");
d3050 1
a3050 1
      fprintf(pfile2, "{ Ull cs0, cs1, cs2, cs3, cex, adr, mexdist;\n");
d3060 5
a3064 5
	fprintf(pfile2, "cs0 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs0);
	fprintf(pfile2, "cs1 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs1);
	fprintf(pfile2, "cs2 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs2);
	fprintf(pfile2, "cs3 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs3);
	fprintf(pfile2, "cex = ((0x%04.4x>>(((cs3>>32&1)<<3)|((cs2>>32&1)<<2)|((cs1>>32&1)<<1)|(cs0>>32&1))&1)?2:0) | ((0x%04.4x>>(((cs3&1)<<3)|((cs2&1)<<2)|((cs1&1)<<1)|(cs0&1))&1)?1:0);\n", cex_tab, cex_tab);
d3084 1
a3084 1
	  fprintf(pfile2, "cex = 3;\n");
d3086 3
a3088 3
	fprintf(pfile2, "SCM0[%d].b[CHIP][%d] = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : SCM0[%d].awoo[CHIP][%d];\n", i, j, ea0bs, ea0bs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(pfile2, "SCM0[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", i, j, ea0os, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
	fprintf(pfile2, "mexdist = (%d || INIT0[CHIP]) ? 0 : %d;\n", conf[i][j].cdw0.mex0op, conf[i][j].cdw0.mex0dist==0? 0: conf[i][j].cdw0.mex0dist==1? 1: conf[i][j].cdw0.mex0dist==2? 2:
d3093 1
a3093 1
	  fprintf(pfile2, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d3096 1
a3096 1
	  fprintf(pfile2, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j, i, j);
d3104 1
a3104 1
	fprintf(pfile2, "adr = (Uint)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d3106 1
a3106 1
	fprintf(pfile2, "adr = (Ull)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d3111 2
a3112 2
	  fprintf(pfile2, "if (cex>>1&1) *((Uint*)(adr&~7LL)+1) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d])>>32;\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
	  fprintf(pfile2, "if (cex   &1) *((Uint*)(adr&~7LL)  ) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n",     mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3115 1
a3115 1
	  fprintf(pfile2, "if (cex   &1) *(Uint*)(adr&~3LL) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3118 1
a3118 1
	  fprintf(pfile2, "if (cex   &1) *(Uchar*)adr = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3121 4
a3124 4
	  fprintf(pfile2, "*((Ull*)(adr&~31LL)+0) = (%d==1? SCAR[%d].r[CHIP][0] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
	  fprintf(pfile2, "*((Ull*)(adr&~31LL)+1) = (%d==1? SCAR[%d].r[CHIP][1] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws1, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts1);
	  fprintf(pfile2, "*((Ull*)(adr&~31LL)+2) = (%d==1? SCAR[%d].r[CHIP][2] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws2, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts2);
	  fprintf(pfile2, "*((Ull*)(adr&~31LL)+3) = (%d==1? SCAR[%d].r[CHIP][3] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws3, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts3);
d3131 1
a3131 1
      fprintf(pfile2, "}\n");
d3135 1
a3135 1
      fprintf(pfile2, "{\n");
d3139 1
a3139 1
	fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+0, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts0);
d3143 1
a3143 1
	fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+1, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts1);
d3147 1
a3147 1
	fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+2, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts2);
d3150 1
a3150 1
	fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCAR[%d].r[CHIP][%d];\n", i, i, j*UNIT_WIDTH+2, i, j);
d3154 1
a3154 1
	fprintf(pfile2, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+3, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts3);
d3156 1
a3156 1
      fprintf(pfile2, "}\n");
d3158 5
a3162 5
    fprintf(pfile2, "uLOOP[CHIP]--;\n");
    fprintf(pfile2, "SCBR[%d].enq[CHIP] = 1-SCBR[%d].enq[CHIP];\n", i, i);
    fprintf(pfile2, "}\n"); /* for (CHIP) */
    fprintf(pfile2, "}\n"); /* while (1) */
    fprintf(pfile2, "}\n"); /* pth_func() */
d3165 1
a3165 1
  fprintf(pfile2, "/* EMAXSC end */\n");
@


1.102
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.101 2021/12/22 12:30:38 nakashim Exp nakashim $";
d2613 10
a2622 8
  fprintf(pfile, "#ifdef EMAXSC\n");
  fprintf(pfile, "/* EMAXSC start */\n");
  fprintf(pfile, "struct  sc_pth   {int dmy[4];}           sc_pth[%d];\n", EMAX_DEPTH);
  fprintf(pfile, "struct  sc_param {int LOOP0; int LOOP1;} sc_param[%d];\n", EMAX_DEPTH);
  fprintf(pfile, "struct  {unsigned long long b[%d][%d],o[%d][%d],awoo[%d][%d],d[%d][%d][2];} SCM0[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* eag0 */
  fprintf(pfile, "struct  {unsigned long long b[%d][%d],o[%d][%d],awoo[%d][%d],d[%d][%d][2];} SCM1[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* eag1 */
  fprintf(pfile, "struct  {unsigned long long r[%d][%d];}                                     SCAR[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH, EMAX_DEPTH); /* alu  */
  fprintf(pfile, "struct  {unsigned long long r[%d][2][%d],enq[%d],d0[4],deq[%d],d1[4];}      SCBR[%d] __attribute__((aligned(64)));\n", EMAX_NCHIP, EMAX_WIDTH*UNIT_WIDTH, EMAX_NCHIP, EMAX_NCHIP, EMAX_DEPTH); /* br   */
d2624 2
a2625 2
    fprintf(pfile, "void emax6sc_pth_%s_%02.2d(struct sc_param *);\n", id[current_prefix].name, i);
  fprintf(pfile, "#include \"%s\"\n", objprog);
d2630 6
a2635 5
    fprintf(pfile, "void emax6sc_pth_%s_%02.2d(struct sc_param *param) {\n", id[current_prefix].name, i);
    fprintf(pfile, "Ull  CHIP, LOOP0=param->LOOP0, LOOP1=param->LOOP1;\n");
    fprintf(pfile, "Ull  INIT1[%d], INIT0[%d];\n", EMAX_NCHIP, EMAX_NCHIP);
    fprintf(pfile, "Uint uLOOP[%d];\n", EMAX_NCHIP);
    fprintf(pfile, "for (CHIP=0; CHIP<%d; CHIP++) { /* unit%d */\n", current_nchip, i);
d2637 1
a2637 1
      fprintf(pfile, "LOOP1=1;uLOOP[CHIP]=LOOP0=%s;\n", id[dec[i][j].dexu.ex1h].name);
d2639 1
a2639 1
      fprintf(pfile, "uLOOP[CHIP]=LOOP1*LOOP0;\n");
d2641 13
a2653 13
      fprintf(pfile, "LOOP1=1;uLOOP[CHIP]=LOOP0;\n");
    fprintf(pfile, "}\n");
    fprintf(pfile, "while (1) {\n");
    fprintf(pfile, "for (CHIP=0; CHIP<%d; CHIP++)\n", current_nchip);
    fprintf(pfile, "if (uLOOP[CHIP]) break;\n");
    fprintf(pfile, "if (CHIP==%d) break;\n", current_nchip);
    fprintf(pfile, "for (CHIP=0; CHIP<%d; CHIP++) {\n", current_nchip); /* 各unit内でsoft-multithreading */
    fprintf(pfile, "if (uLOOP[CHIP]==0) continue;\n", i);
  //fprintf(pfile, "printf(\"%d: uLOOP[%%d]=%%d\\n\", (Uint)CHIP, (Uint)uLOOP[CHIP]);\n", i);
    fprintf(pfile, "if ((%d && SCBR[%d].enq[CHIP]==SCBR[%d].deq[CHIP]) || (%d<%d && SCBR[%d].enq[CHIP]!=SCBR[%d].deq[CHIP])) continue;\n", i, (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, last_row, i, i);
    fprintf(pfile, "INIT1[CHIP]=(uLOOP[CHIP]>LOOP1*LOOP0-LOOP0);\n");
    fprintf(pfile, "INIT0[CHIP]=(uLOOP[CHIP]-(uLOOP[CHIP]/LOOP0*LOOP0)==0);\n");
    fprintf(pfile, "SCBR[%d].deq[CHIP] = 1-SCBR[%d].deq[CHIP];\n", (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH);
d2673 3
a2675 3
      fprintf(pfile, "{ Ull adr, mexdist, load64;\n");
      fprintf(pfile, "  static int emax6_unaligned_load_valid;\n");
      fprintf(pfile, "  static Ull emax6_unaligned_load_high;\n");
d2683 3
a2685 3
	fprintf(pfile, "SCM1[%d].b[CHIP][%d] = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM1[%d].b[CHIP][%d]) : SCM1[%d].awoo[CHIP][%d];\n", i, j, ea1bs, ea1bs, i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(pfile, "SCM1[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM1[%d].o[CHIP][%d], %d);\n", i, j, ea1os, i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea1msk);
	fprintf(pfile, "mexdist = (%d || INIT0[CHIP]) ? 0 : %d;\n", conf[i][j].cdw0.mex1op, conf[i][j].cdw0.mex1dist==0? 0: conf[i][j].cdw0.mex1dist==1? 1: conf[i][j].cdw0.mex1dist==2? 2:
d2690 1
a2690 1
	  fprintf(pfile, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d2693 1
a2693 1
	  fprintf(pfile, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM1[%d].d[CHIP][%d][0]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d][1]>>32)<=(SCM1[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2696 1
a2696 1
	  fprintf(pfile, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM1[%d].d[CHIP][%d][1]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d][1]>>32)>=(SCM1[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2699 1
a2699 1
	  fprintf(pfile, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j, i, j);
d2707 1
a2707 1
	fprintf(pfile, "adr = (Uint)(SCM1[%d].awoo[CHIP][%d] + SCM1[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2709 1
a2709 1
	fprintf(pfile, "adr = (Ull)(SCM1[%d].awoo[CHIP][%d] + SCM1[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2714 12
a2725 12
	  fprintf(pfile, "load64 = *(Ull*)(adr&~7LL);\n");
	  fprintf(pfile, "if ((adr&7) == 0)\n");
	  fprintf(pfile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = load64;\n", i, i, j*UNIT_WIDTH+1, i, j);
	  fprintf(pfile, "else if (!emax6_unaligned_load_valid) { /* BR[][][1] */\n");
	  fprintf(pfile, "  emax6_unaligned_load_valid = 1;\n");
	  fprintf(pfile, "  emax6_unaligned_load_high = load64;\n");
	  fprintf(pfile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+1, i, j);
	  fprintf(pfile, "}\n");
	  fprintf(pfile, "else { /* BR[][][0] */\n");
	  fprintf(pfile, "  emax6_unaligned_load_valid = 0;\n");
	  fprintf(pfile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+1, i, j);
	  fprintf(pfile, "}\n");
d2728 1
a2728 1
	  fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, i, j*UNIT_WIDTH+1);
d2731 1
a2731 1
	  fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, i, j*UNIT_WIDTH+1);
d2734 4
a2737 4
	  fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, i, j*UNIT_WIDTH+0);
          fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, i, j*UNIT_WIDTH+1);
	  fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, i, j*UNIT_WIDTH+2);
	  fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, i, j*UNIT_WIDTH+3);
d2752 3
a2754 3
	fprintf(pfile, "SCM0[%d].b[CHIP][%d] = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : SCM0[%d].awoo[CHIP][%d];\n", i, j, ea0bs, ea0bs, i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(pfile, "SCM0[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", i, j, ea0os, i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
	fprintf(pfile, "mexdist = (%d || INIT0[CHIP]) ? 0 : %d;\n", conf[i][j].cdw0.mex0op, conf[i][j].cdw0.mex0dist==0? 0: conf[i][j].cdw0.mex0dist==1? 1: conf[i][j].cdw0.mex0dist==2? 2:
d2759 1
a2759 1
	  fprintf(pfile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d2762 1
a2762 1
	  fprintf(pfile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM0[%d].d[CHIP][%d][0]>>32)!=0xffffffff && (SCM0[%d].d[CHIP][%d][1]>>32)<=(SCM0[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2765 1
a2765 1
	  fprintf(pfile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:((SCM0[%d].d[CHIP][%d][1]>>32)!=0xffffffff && (SCM0[%d].d[CHIP][%d][1]>>32)>=(SCM0[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2768 1
a2768 1
	  fprintf(pfile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j, i, j);
d2776 1
a2776 1
	fprintf(pfile, "adr = (Uint)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2778 1
a2778 1
	fprintf(pfile, "adr = (Ull)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2783 12
a2794 12
	  fprintf(pfile, "load64 = *(Ull*)(adr&~7LL);\n");
	  fprintf(pfile, "if ((adr&7) == 0)\n");
	  fprintf(pfile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = load64;\n", i, i, j*UNIT_WIDTH+0, i, j);
	  fprintf(pfile, "else if (!emax6_unaligned_load_valid) { /* BR[][][1] */\n");
	  fprintf(pfile, "  emax6_unaligned_load_valid = 1;\n");
	  fprintf(pfile, "  emax6_unaligned_load_high = load64;\n");
	  fprintf(pfile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+0, i, j);
	  fprintf(pfile, "}\n");
	  fprintf(pfile, "else { /* BR[][][0] */\n");
	  fprintf(pfile, "  emax6_unaligned_load_valid = 0;\n");
	  fprintf(pfile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+0, i, j);
	  fprintf(pfile, "}\n");
d2797 1
a2797 1
	  fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, i, j*UNIT_WIDTH+0);
d2800 1
a2800 1
	  fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, i, j*UNIT_WIDTH+0);
d2803 4
a2806 4
	  fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, i, j*UNIT_WIDTH+0);
          fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, i, j*UNIT_WIDTH+1);
	  fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, i, j*UNIT_WIDTH+2);
	  fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, i, j*UNIT_WIDTH+3);
d2813 1
a2813 1
      fprintf(pfile, "}\n");
d2817 1
a2817 1
      fprintf(pfile, "{ union { Uint i; float f; } f3, f2, f1, f0; Ull t3, t2, t1, t0, ex1, ex2, ex3, ex4, ex5, c1, c0, ex1_outd, ex2_outd;\n");
d2837 2
a2838 2
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex1_outd = ex1;\n");
d2844 16
a2859 16
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(pfile, "f1.i = (Uint)(ex1);\n");
	  fprintf(pfile, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(pfile, "f3.i = (Uint)(ex3>>32);\n");
	  fprintf(pfile, "if (f2.i != -1 && f2.i == f3.i) {\n");
	  fprintf(pfile, "  f2.i = (Uint)(ex2);\n");
	  fprintf(pfile, "  f3.i = (Uint)(ex3);\n");
	  fprintf(pfile, "  f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(pfile, "}\n");
	  fprintf(pfile, "else {\n");
	  fprintf(pfile, "  f0.f = f1.f;\n");
	  fprintf(pfile, "}\n");
	  fprintf(pfile, "t0 = f0.i;\n");
	  fprintf(pfile, "ex1_outd = t0;\n");
d2864 14
a2877 14
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(pfile, "f1.i = (Uint)(ex1>>32);\n");
	  fprintf(pfile, "f2.i = (Uint)(ex2>>32)^%08.8x;\n", conf[i][j].cdw0.op1==OP_FMA?0:0x80000000);
	  fprintf(pfile, "f3.i = (Uint)(ex3>>32);\n");
	  fprintf(pfile, "f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(pfile, "t2 = f0.i;\n");
	  fprintf(pfile, "f1.i = (Uint)(ex1);\n");
	  fprintf(pfile, "f2.i = (Uint)(ex2)^%08.8x;\n", conf[i][j].cdw0.op1==OP_FMA?0:0x80000000);
	  fprintf(pfile, "f3.i = (Uint)(ex3);\n");
	  fprintf(pfile, "f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(pfile, "t0 = f0.i;\n");
	  fprintf(pfile, "ex1_outd = (t2<<32)|(t0);\n");
d2881 11
a2891 11
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "f1.i = (Uint)(ex1>>32);\n");
	  fprintf(pfile, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(pfile, "f0.f = f1.f + f2.f;\n");
	  fprintf(pfile, "t2 = f0.i;\n");
	  fprintf(pfile, "f1.i = (Uint)(ex1);\n");
	  fprintf(pfile, "f2.i = (Uint)(ex2);\n");
	  fprintf(pfile, "f0.f = f1.f + f2.f;\n");
	  fprintf(pfile, "t0 = f0.i;\n");
	  fprintf(pfile, "ex1_outd = (t2<<32)|(t0);\n");
d2895 11
a2905 11
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "f1.i = (Uint)(ex1>>32);\n");
	  fprintf(pfile, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(pfile, "f0.f = f1.f * f2.f;\n");
	  fprintf(pfile, "t2 = f0.i;\n");
	  fprintf(pfile, "f1.i = (Uint)(ex1);\n");
	  fprintf(pfile, "f2.i = (Uint)(ex2);\n");
	  fprintf(pfile, "f0.f = f1.f * f2.f;\n");
	  fprintf(pfile, "t0 = f0.i;\n");
	  fprintf(pfile, "ex1_outd = (t2<<32)|(t0);\n");
d2908 8
a2915 8
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(pfile, "t2 = (ex1>>32&0x00000000ffffffffLL)+((ex2>>32&0x00000000ffffffffLL)+(ex3>>32&0x00000000ffffffffLL));\n");
	  fprintf(pfile, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile, "t0 = (ex1    &0x00000000ffffffffLL)+((ex2    &0x00000000ffffffffLL)+(ex3    &0x00000000ffffffffLL));\n");
	  fprintf(pfile, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile, "ex1_outd = (t2<<32)|(t0);\n");
d2918 8
a2925 8
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(pfile, "t2 = (ex1>>32&0x00000000ffffffffLL)-((ex2>>32&0x00000000ffffffffLL)+(ex3>>32&0x00000000ffffffffLL));\n");
	  fprintf(pfile, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile, "t0 = (ex1    &0x00000000ffffffffLL)-((ex2    &0x00000000ffffffffLL)+(ex3    &0x00000000ffffffffLL));\n");
	  fprintf(pfile, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile, "ex1_outd = (t2<<32)|(t0);\n");
d2928 7
a2934 7
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "t2 = (ex1>>32&0x00000000ffffffffLL)+(ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile, "t0 = (ex1    &0x00000000ffffffffLL)+(ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile, "ex1_outd = (t2<<32)|(t0);\n");
d2937 7
a2943 7
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "t2 = (ex1>>32&0x00000000ffffffffLL)-(ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile, "t0 = (ex1    &0x00000000ffffffffLL)-(ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(pfile, "ex1_outd = (t2<<32)|(t0);\n");
d2946 5
a2950 5
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "c1 = (ex1>>32&0x00000000ffffffffLL) == (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile, "c0 = (ex1    &0x00000000ffffffffLL) == (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile, "ex1_outd = (c1<<32)|c0;\n");
d2953 5
a2957 5
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "c1 = (ex1>>32&0x00000000ffffffffLL) != (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile, "c0 = (ex1    &0x00000000ffffffffLL) != (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile, "ex1_outd = (c1<<32)|c0;\n");
d2960 5
a2964 5
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "c1 = (ex1>>32&0x00000000ffffffffLL) < (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile, "c0 = (ex1    &0x00000000ffffffffLL) < (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile, "ex1_outd = (c1<<32)|c0;\n");
d2967 5
a2971 5
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "c1 = (ex1>>32&0x00000000ffffffffLL) <= (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile, "c0 = (ex1    &0x00000000ffffffffLL) <= (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile, "ex1_outd = (c1<<32)|c0;\n");
d2974 5
a2978 5
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "c1 = (ex1>>32&0x00000000ffffffffLL) > (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile, "c0 = (ex1    &0x00000000ffffffffLL) > (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile, "ex1_outd = (c1<<32)|c0;\n");
d2981 5
a2985 5
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "c1 = (ex1>>32&0x00000000ffffffffLL) >= (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(pfile, "c0 = (ex1    &0x00000000ffffffffLL) >= (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(pfile, "ex1_outd = (c1<<32)|c0;\n");
d2988 8
a2995 8
	  fprintf(pfile, "ex1 = exm(!%d||(INIT1[CHIP]&&INIT0[CHIP])||((%d&1)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(pfile, "ex2 = exm(((%d&2)&&INIT0[CHIP]) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(pfile, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(pfile, "c1 = ex1>>32&1;\n");
	  fprintf(pfile, "c0 = ex1    &1;\n");
	  fprintf(pfile, "t2 = c1 ? (ex2&0xffffffff00000000LL) : (ex3&0xffffffff00000000LL);\n");
	  fprintf(pfile, "t0 = c0 ? (ex2&0x00000000ffffffffLL) : (ex3&0x00000000ffffffffLL);\n");
	  fprintf(pfile, "ex1_outd = t2 | t0;\n");
d3005 1
a3005 1
	  fprintf(pfile, "ex2_outd = ex1_outd;\n");
d3008 2
a3009 2
	  fprintf(pfile, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(pfile, "ex2_outd = ex1_outd & ex4;\n");
d3012 2
a3013 2
	  fprintf(pfile, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(pfile, "ex2_outd = ex1_outd | ex4;\n");
d3016 2
a3017 2
	  fprintf(pfile, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(pfile, "ex2_outd = ex1_outd ^ ex4;\n");
d3027 1
a3027 1
	  fprintf(pfile, "SCAR[%d].r[CHIP][%d] = ex2_outd;\n", i, j);
d3030 4
a3033 4
	  fprintf(pfile, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(pfile, "t1 = (Ull)(ex2_outd     &0xffffffff00000000LL)<<ex5;\n");
	  fprintf(pfile, "t0 = (Ull)(ex2_outd<<ex5&0x00000000ffffffffLL);\n");
	  fprintf(pfile, "SCAR[%d].r[CHIP][%d] = t1 | t0;\n", i, j);
d3036 4
a3039 4
	  fprintf(pfile, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(pfile, "t1 = (Ull)(ex2_outd>>ex5&0xffffffff00000000LL);\n");
	  fprintf(pfile, "t0 = (Ull)(ex2_outd     &0x00000000ffffffffLL)>>ex5;\n");
	  fprintf(pfile, "SCAR[%d].r[CHIP][%d] = t1 | t0;\n", i, j);
d3046 1
a3046 1
      fprintf(pfile, "}\n");
d3050 1
a3050 1
      fprintf(pfile, "{ Ull cs0, cs1, cs2, cs3, cex, adr, mexdist;\n");
d3060 5
a3064 5
	fprintf(pfile, "cs0 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs0);
	fprintf(pfile, "cs1 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs1);
	fprintf(pfile, "cs2 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs2);
	fprintf(pfile, "cs3 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs3);
	fprintf(pfile, "cex = ((0x%04.4x>>(((cs3>>32&1)<<3)|((cs2>>32&1)<<2)|((cs1>>32&1)<<1)|(cs0>>32&1))&1)?2:0) | ((0x%04.4x>>(((cs3&1)<<3)|((cs2&1)<<2)|((cs1&1)<<1)|(cs0&1))&1)?1:0);\n", cex_tab, cex_tab);
d3084 1
a3084 1
	  fprintf(pfile, "cex = 3;\n");
d3086 3
a3088 3
	fprintf(pfile, "SCM0[%d].b[CHIP][%d] = (!(%d&1)||INIT0[CHIP]) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : SCM0[%d].awoo[CHIP][%d];\n", i, j, ea0bs, ea0bs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(pfile, "SCM0[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", i, j, ea0os, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
	fprintf(pfile, "mexdist = (%d || INIT0[CHIP]) ? 0 : %d;\n", conf[i][j].cdw0.mex0op, conf[i][j].cdw0.mex0dist==0? 0: conf[i][j].cdw0.mex0dist==1? 1: conf[i][j].cdw0.mex0dist==2? 2:
d3093 1
a3093 1
	  fprintf(pfile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d3096 1
a3096 1
	  fprintf(pfile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0[CHIP]?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0[CHIP]?0:mexdist);\n", i, j, i, j, i, j);
d3104 1
a3104 1
	fprintf(pfile, "adr = (Uint)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d3106 1
a3106 1
	fprintf(pfile, "adr = (Ull)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d3111 2
a3112 2
	  fprintf(pfile, "if (cex>>1&1) *((Uint*)(adr&~7LL)+1) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d])>>32;\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
	  fprintf(pfile, "if (cex   &1) *((Uint*)(adr&~7LL)  ) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n",     mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3115 1
a3115 1
	  fprintf(pfile, "if (cex   &1) *(Uint*)(adr&~3LL) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3118 1
a3118 1
	  fprintf(pfile, "if (cex   &1) *(Uchar*)adr = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3121 4
a3124 4
	  fprintf(pfile, "*((Ull*)(adr&~31LL)+0) = (%d==1? SCAR[%d].r[CHIP][0] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
	  fprintf(pfile, "*((Ull*)(adr&~31LL)+1) = (%d==1? SCAR[%d].r[CHIP][1] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws1, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts1);
	  fprintf(pfile, "*((Ull*)(adr&~31LL)+2) = (%d==1? SCAR[%d].r[CHIP][2] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws2, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts2);
	  fprintf(pfile, "*((Ull*)(adr&~31LL)+3) = (%d==1? SCAR[%d].r[CHIP][3] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws3, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts3);
d3131 1
a3131 1
      fprintf(pfile, "}\n");
d3135 1
a3135 1
      fprintf(pfile, "{\n");
d3139 1
a3139 1
	fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+0, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts0);
d3143 1
a3143 1
	fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+1, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts1);
d3147 1
a3147 1
	fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+2, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts2);
d3150 1
a3150 1
	fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCAR[%d].r[CHIP][%d];\n", i, i, j*UNIT_WIDTH+2, i, j);
d3154 1
a3154 1
	fprintf(pfile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+3, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts3);
d3156 1
a3156 1
      fprintf(pfile, "}\n");
d3158 5
a3162 5
    fprintf(pfile, "uLOOP[CHIP]--;\n");
    fprintf(pfile, "SCBR[%d].enq[CHIP] = 1-SCBR[%d].enq[CHIP];\n", i, i);
    fprintf(pfile, "}\n"); /* for (CHIP) */
    fprintf(pfile, "}\n"); /* while (1) */
    fprintf(pfile, "}\n"); /* pth_func() */
d3165 1
a3165 2
  fprintf(pfile, "/* EMAXSC end */\n");
  fprintf(pfile, "#endif\n");
@


1.101
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.100 2021/12/22 11:33:56 nakashim Exp nakashim $";
d2646 2
a2647 1
    fprintf(pfile, "if ((%d && SCBR[%d].enq[CHIP]==SCBR[%d].deq[CHIP]) || SCBR[%d].enq[CHIP]!=SCBR[%d].deq[CHIP]) continue;\n", i, (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, i);
@


1.100
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.99 2021/12/22 04:35:38 nakashim Exp nakashim $";
d2615 6
a2620 16
  fprintf(pfile, "#define EMAX_NCHIP %d\n", EMAX_NCHIP);
  fprintf(pfile, "#define EMAX_DEPTH %d\n", EMAX_DEPTH);
  fprintf(pfile, "#define EMAX_WIDTH %d\n", EMAX_WIDTH);
  fprintf(pfile, "#define UNIT_WIDTH %d\n", UNIT_WIDTH);
  fprintf(pfile, "struct sc_pth   {int dmy[4];}           sc_pth[EMAX_DEPTH];\n");
  fprintf(pfile, "struct sc_param {int LOOP0; int LOOP1;} sc_param[EMAX_DEPTH];\n");
  fprintf(pfile, "unsigned int       uLOOP[EMAX_DEPTH][EMAX_NCHIP];\n");
  fprintf(pfile, "unsigned long long INIT1[EMAX_NCHIP], INIT0[EMAX_NCHIP];\n");
  fprintf(pfile, "struct  {unsigned long long b[EMAX_NCHIP][EMAX_WIDTH],o[EMAX_NCHIP][EMAX_WIDTH],awoo[EMAX_NCHIP][EMAX_WIDTH],d[EMAX_NCHIP][EMAX_WIDTH][2];} SCM0[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* eag0 */
  fprintf(pfile, "struct  {unsigned long long b[EMAX_NCHIP][EMAX_WIDTH],o[EMAX_NCHIP][EMAX_WIDTH],awoo[EMAX_NCHIP][EMAX_WIDTH],d[EMAX_NCHIP][EMAX_WIDTH][2];} SCM1[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* eag1 */
  fprintf(pfile, "struct  {unsigned long long r[EMAX_NCHIP][EMAX_WIDTH];}                                                                                     SCAR[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* alu  */
  fprintf(pfile, "struct  {unsigned long long r[EMAX_NCHIP][2][EMAX_WIDTH*UNIT_WIDTH],enq[EMAX_NCHIP],d0[4],deq[EMAX_NCHIP],d1[4];}                           SCBR[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* br   */
  fprintf(pfile, "#undef  EMAX_NCHIP\n");
  fprintf(pfile, "#undef  EMAX_DEPTH\n");
  fprintf(pfile, "#undef  EMAX_WIDTH\n");
  fprintf(pfile, "#undef  UNIT_WIDTH\n");
d2629 3
a2631 1
    fprintf(pfile, "Ull CHIP, LOOP0=param->LOOP0, LOOP1=param->LOOP1;\n");
d2634 1
a2634 1
      fprintf(pfile, "LOOP1=1;uLOOP[%d][CHIP]=LOOP0=%s;\n", i, id[dec[i][j].dexu.ex1h].name);
d2636 1
a2636 1
      fprintf(pfile, "uLOOP[%d][CHIP]=LOOP1*LOOP0;\n", i);
d2638 1
a2638 1
      fprintf(pfile, "LOOP1=1;uLOOP[%d][CHIP]=LOOP0;\n", i);
d2642 1
a2642 1
    fprintf(pfile, "if (uLOOP[%d][CHIP]) break;\n", i);
d2645 1
a2645 1
    fprintf(pfile, "if (uLOOP[%d][CHIP]==0) continue;\n", i);
d2647 2
a2648 2
    fprintf(pfile, "INIT1[CHIP]=(uLOOP[%d][CHIP]>LOOP1*LOOP0-LOOP0);\n", i);
    fprintf(pfile, "INIT0[CHIP]=(uLOOP[%d][CHIP]-(uLOOP[%d][CHIP]/LOOP0*LOOP0)==0);\n", i, i);
d3154 1
a3154 1
    fprintf(pfile, "uLOOP[%d][CHIP]--;\n", i);
@


1.99
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.98 2021/12/22 02:41:12 nakashim Exp nakashim $";
d2619 2
a2620 2
  fprintf(pfile, "struct sc_pth   {int dmy[4];} sc_pth[EMAX_DEPTH];\n");
  fprintf(pfile, "struct sc_param {int unit;}   sc_param[EMAX_DEPTH];\n");
d2639 1
a2639 1
    fprintf(pfile, "Ull CHIP, LOOP1, LOOP0;\n");
d2656 1
a2656 1
    fprintf(pfile, "INIT0[CHIP]=(uLOOP[%d][CHIP]-(uLOOP[%d][CHIP]/LOOP0*LOOP0)==0);\n", i);
d3272 1
a3272 1
    fprintf(ofile, "pthread_create((pthread_t*)&sc_pth[%d], 0, emax6sc_pth_%s_%02.2d, &sc_param[%d]);\n", i, id[current_prefix].name, i);
@


1.98
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.97 2021/12/21 03:59:49 nakashim Exp nakashim $";
d2619 2
d2623 4
a2626 5
  fprintf(pfile, "struct {unsigned long long b[EMAX_NCHIP][EMAX_WIDTH],o[EMAX_NCHIP][EMAX_WIDTH],awoo[EMAX_NCHIP][EMAX_WIDTH],d[EMAX_NCHIP][EMAX_WIDTH][2];} SCM0[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* eag0 */
  fprintf(pfile, "struct {unsigned long long b[EMAX_NCHIP][EMAX_WIDTH],o[EMAX_NCHIP][EMAX_WIDTH],awoo[EMAX_NCHIP][EMAX_WIDTH],d[EMAX_NCHIP][EMAX_WIDTH][2];} SCM1[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* eag1 */
  fprintf(pfile, "struct {unsigned long long r[EMAX_NCHIP][EMAX_WIDTH];}                                                                                     SCAR[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* alu  */
  fprintf(pfile, "struct {unsigned long long r[EMAX_NCHIP][2][EMAX_WIDTH*UNIT_WIDTH],enq[EMAX_NCHIP],d0[4],deq[EMAX_NCHIP],d1[4];}                           SCBR[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* br   */
  fprintf(pfile, "struct emax6pth {int th; int x;} emax6pth[EMAX_DEPTH] __attribute__((aligned(64)));\n");
d2631 2
d2638 1
a2638 1
    fprintf(pfile, "void emax6sc_pth_%s_%02.2d(struct pth *param) {\n", id[current_prefix].name, i);
d3271 4
a3274 4
//for (i=0; i<=last_raw; i++)
//  pthread_create(&th_emax6sc[i], NULL, emax6sc_pth_yyy, param_emax6sc[i]);
//for (i=0; i<=last_raw; i++)
//  pthread_join(th_emax6sc[i], NULL);
@


1.97
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.96 2021/12/16 14:28:32 nakashim Exp nakashim $";
a2614 13
  fprintf(pfile, "#ifndef UTYPEDEF\n");
  fprintf(pfile, "#define UTYPEDEF\n");
  fprintf(pfile, "typedef unsigned char      Uchar;\n");
  fprintf(pfile, "typedef unsigned short     Ushort;\n");
  fprintf(pfile, "typedef unsigned int       Uint;\n");
  fprintf(pfile, "typedef unsigned long long Ull;\n");
  fprintf(pfile, "typedef long long int      Sll;\n");
  fprintf(pfile, "#if __AARCH64EL__ == 1\n");
  fprintf(pfile, "typedef long double Dll;\n");
  fprintf(pfile, "#else\n");
  fprintf(pfile, "typedef struct {Ull u[2];} Dll;\n");
  fprintf(pfile, "#endif\n");
  fprintf(pfile, "#endif\n");
d2619 7
a2625 6
  fprintf(pfile, "Uint    uLOOP[EMAX_DEPTH][EMAX_NCHIP];\n");
  fprintf(pfile, "Ull     INIT1[EMAX_NCHIP], INIT0[EMAX_NCHIP];\n");
  fprintf(pfile, "struct  {Ull b[EMAX_NCHIP][EMAX_WIDTH],o[EMAX_NCHIP][EMAX_WIDTH],awoo[EMAX_NCHIP][EMAX_WIDTH],d[EMAX_NCHIP][EMAX_WIDTH][2];} SCM0[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* eag0 */
  fprintf(pfile, "struct  {Ull b[EMAX_NCHIP][EMAX_WIDTH],o[EMAX_NCHIP][EMAX_WIDTH],awoo[EMAX_NCHIP][EMAX_WIDTH],d[EMAX_NCHIP][EMAX_WIDTH][2];} SCM1[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* eag1 */
  fprintf(pfile, "struct  {Ull r[EMAX_NCHIP][EMAX_WIDTH];}                                                                                     SCAR[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* alu  */
  fprintf(pfile, "struct  {Ull r[EMAX_NCHIP][2][EMAX_WIDTH*UNIT_WIDTH],enq[EMAX_NCHIP],d0[4],deq[EMAX_NCHIP],d1[4];}                           SCBR[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* br   */
d2630 1
d2636 1
@


1.96
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.95 2021/12/16 10:44:50 nakashim Exp nakashim $";
d566 1
a566 1
      /*          │                           *//* (1)mop(OP_LDUWR, &BR[7][0][1])                     */
d1385 3
a1387 6
      case OP_LDWR: /* 32bit signed */
      case OP_LDUWR:/* 32bit unsigned */
//    case OP_LDHR: /* 16bit signed */
//    case OP_LDUHR:/* 16bit unsigned */
      case OP_LDBR: /*  8bit signed */
      case OP_LDUBR:/*  8bit unsigned */
d2613 29
a2641 111
  fprintf(ofile, "#ifdef EMAXSC\n");
  fprintf(ofile, "/* EMAXSC start */\n");
  fprintf(ofile, "#define EMAX_NCHIP %d\n", EMAX_NCHIP);
  fprintf(ofile, "#define EMAX_DEPTH %d\n", EMAX_DEPTH);
  fprintf(ofile, "#define EMAX_WIDTH %d\n", EMAX_WIDTH);
  fprintf(ofile, "#define UNIT_WIDTH %d\n", UNIT_WIDTH);
  fprintf(ofile, "struct {Ull b[EMAX_NCHIP][EMAX_WIDTH],o[EMAX_NCHIP][EMAX_WIDTH],awoo[EMAX_NCHIP][EMAX_WIDTH],d[EMAX_NCHIP][EMAX_WIDTH][2];} SCM0[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* eag0 */
  fprintf(ofile, "struct {Ull b[EMAX_NCHIP][EMAX_WIDTH],o[EMAX_NCHIP][EMAX_WIDTH],awoo[EMAX_NCHIP][EMAX_WIDTH],d[EMAX_NCHIP][EMAX_WIDTH][2];} SCM1[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* eag1 */
  fprintf(ofile, "struct {Ull r[EMAX_NCHIP][EMAX_WIDTH];}                                                                                     SCAR[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* alu  */
  fprintf(ofile, "struct {Ull r[EMAX_NCHIP][2][EMAX_WIDTH*UNIT_WIDTH],enq[EMAX_NCHIP],d0[4],deq[EMAX_NCHIP],d1[4];}                           SCBR[EMAX_DEPTH] __attribute__((aligned(64)));\n"); /* br   */
  fprintf(ofile, "#undef  EMAX_NCHIP\n");
  fprintf(ofile, "#undef  EMAX_DEPTH\n");
  fprintf(ofile, "#undef  EMAX_WIDTH\n");
  fprintf(ofile, "#undef  UNIT_WIDTH\n");
  fprintf(ofile, "Uint uLOOP1, uLOOP0;\n");
    
  /* init REGV(breg) */
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      for (k=0; k<UNIT_WIDTH; k++) {
	if (regv[i][j].br[k].v) {
	  if (id[regv[i][j].br[k].h].chip) { /* CHIP */
	    for (c=0; c<current_nchip; c++) {
	      fprintf(ofile, "SCBR[%d].r[%d][0][%d] = %d;\n", i, c, j*UNIT_WIDTH+k, c);
	      fprintf(ofile, "SCBR[%d].r[%d][1][%d] = %d;\n", i, c, j*UNIT_WIDTH+k, c);
	    }
	  }
	  else if (id[regv[i][j].br[k].h].cidx) { /* xxx[CHIP] */
	    for (c=0; c<current_nchip; c++) {
	      fprintf(ofile, "SCBR[%d].r[%d][0][%d] = %s[%d];\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name, c);
	      fprintf(ofile, "SCBR[%d].r[%d][1][%d] = %s[%d];\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name, c);
	    }
	  }
	  else if (regv[i][j].br[k].s < 0) {
	    for (c=0; c<current_nchip; c++) {
	      fprintf(ofile, "SCBR[%d].r[%d][0][%d] = %s;\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name);
	      fprintf(ofile, "SCBR[%d].r[%d][1][%d] = %s;\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name);
	    }
	  }
	  else {
	    for (c=0; c<current_nchip; c++) {
	      fprintf(ofile, "SCBR[%d].r[%d][0][%d] = %s[%d];\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name, regv[i][j].br[k].s);
	      fprintf(ofile, "SCBR[%d].r[%d][1][%d] = %s[%d];\n", i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name, regv[i][j].br[k].s);
	    }
	  }
	}
      }
    }
  }

  /* init REGV(eag) */
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (regv[i][j].ea0b_v) {
	if (id[regv[i][j].ea0b_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].b[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea0b_h].name, c);
	}
	else if (regv[i][j].ea0b_s < 0) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].b[%d][%d] = (Ull)%s;\n", i, c, j, id[regv[i][j].ea0b_h].name);
	}
	else {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].b[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
	}
      }
      if (regv[i][j].ea0o_v) {
	if (id[regv[i][j].ea0o_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].o[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea0o_h].name, c);
	}
	else if (regv[i][j].ea0o_s < 0) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].o[%d][%d] = (Ull)%s;\n", i, c, j, id[regv[i][j].ea0o_h].name);
	}
	else {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM0[%d].o[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
	}
      }
      if (regv[i][j].ea1b_v) {
	if (id[regv[i][j].ea1b_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].b[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea1b_h].name, c);
	}
	else if (regv[i][j].ea1b_s < 0) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].b[%d][%d] = (Ull)%s;\n", i, c, j, id[regv[i][j].ea1b_h].name);
	}
	else {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].b[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
	}
      }
      if (regv[i][j].ea1o_v) {
	if (id[regv[i][j].ea1o_h].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].o[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea1o_h].name, c);
	}
	else if (regv[i][j].ea1o_s < 0) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].o[%d][%d] = (Ull)%s;\n", i, c, j, id[regv[i][j].ea1o_h].name);
	}
	else {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "SCM1[%d].o[%d][%d] = (Ull)%s[%d];\n", i, c, j, id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
	}
      }
    }
  }
d2646 37
a2682 50
    if (conf[0][0].cdw0.op1 == OP_WHILE) {
      fprintf(ofile, "INIT1=1;\n");
      fprintf(ofile, "for (INIT0=1,uLOOP0=%s; uLOOP0--; INIT0=0) {\n", id[dec[i][j].dexu.ex1h].name);
    }
    else {
      int c;
      if (conf[0][1].cdw0.op1 == OP_FOR) {
	if (forinit_cidx[1]) { /* NCHIP */
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t%s;\n", forinit[1][c]);
	}
	else
	  fprintf(ofile, "\t%s;\n", forinit[1][0]);
	fprintf(ofile, "for (INIT1=1,uLOOP1=LOOP1; uLOOP1--; INIT1=0) {\n");
      }
      else
	fprintf(ofile, "INIT1=1;\n");
      if (conf[0][0].cdw0.op1 == OP_FOR) {
	if (forinit_cidx[0]) { /* NCHIP */
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t%s;\n", forinit[0][c]);
	}
	else
	  fprintf(ofile, "\t%s;\n", forinit[0][0]);
	fprintf(ofile, "for (INIT0=1,uLOOP0=LOOP0; uLOOP0--; INIT0=0) {\n");
      }
    }
    fprintf(ofile, "for (CHIP=0; CHIP<%d; CHIP++) {\n", current_nchip); /* 各unit内でsoft-multithreading */
    fprintf(ofile, "if ((%d && SCBR[%d].enq[CHIP]==SCBR[%d].deq[CHIP]) || SCBR[%d].deq[CHIP]!=SCBR[%d].enq[CHIP]) continue;\n", i, (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i);
    /* BR[i-1][0]                r  r                    r  r                      */
    /* BR[i-1][1]                            r  r                    r  r          */
    /* deq-       0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  1  1  1  1          */
    /*                            any0↑          ↑          ↑                   */
    /* exe[i]                 ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓  (先頭 && deq-==enq0)ならexe開始.exe後deq-=1-deq-, enq0==deq0ならenq0=1-enq0 */
    /*                      deq-==enq0   ↓          ↓          ↓          ↓                */
    /* enq0          0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  1  1  1  1  0  0  0          */
    /* BR[i][0]                  w  w    /   r  r    /   w  w    /   r  r    /   w  w          */
    /* BR[i][1]                         /    w  w   /    r  r   /    w  w   /    r  r          */
    /* deq0          0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  1  1  1  1          */
    /*                                  enq0!=deq0↑          ↑          ↑                   */
    /* exe[i+1]                           ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓  (enq0!=deq0 && deq0==enq1)★ならexe開始.exe後deq0=1-deq0, enq1==dec1ならenq1=1-enq1 */
    /*                                  deq0==enq1   ↓          ↓          ↓          ↓                */
    /* enq1          0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  1  1  1  1  0  0  0          */
    /* BR[i+1][0]                            w  w    /   r  r    /   w  w    /   r  r    /   w  w          */
    /* BR[i+1][1]                                   /    w  w   /    r  r   /    w  w   /    r  r          */
    /* deq1          0  0  0  0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  1  1  1  1          */
    /*                                              enq1!=deq1↑          ↑          ↑                   */
    /* exe[i+2]                                       ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓  (enq1!=deq1 && deq1==enq2)★ならexe開始.exe後deq1=1-deq1, enq2==dec2ならenq2=1-enq2 */
    /*                                              deq1==enq2   ↓          ↓          ↓          ↓                */
    /* enq2                      0  0  0  0  0  0  0  0  0  0  0  1  1  1  1  0  0  0  0  1  1  1  1  0  0             */
d2684 3
a2686 3
      fprintf(ofile, "{ Ull adr, mexdist, load64;\n");
      fprintf(ofile, "  static int emax6_unaligned_load_valid;\n");
      fprintf(ofile, "  static Ull emax6_unaligned_load_high;\n");
d2694 3
a2696 3
	fprintf(ofile, "SCM1[%d].b[CHIP][%d] = (!(%d&1)||INIT0) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM1[%d].b[CHIP][%d]) : SCM1[%d].awoo[CHIP][%d];\n", i, j, ea1bs, ea1bs, i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(ofile, "SCM1[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM1[%d].o[CHIP][%d], %d);\n", i, j, ea1os, i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea1msk);
	fprintf(ofile, "mexdist = (%d || INIT0) ? 0 : %d;\n", conf[i][j].cdw0.mex1op, conf[i][j].cdw0.mex1dist==0? 0: conf[i][j].cdw0.mex1dist==1? 1: conf[i][j].cdw0.mex1dist==2? 2:
d2701 1
a2701 1
	  fprintf(ofile, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d2704 1
a2704 1
	  fprintf(ofile, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0?0:((SCM1[%d].d[CHIP][%d][0]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d][1]>>32)<=(SCM1[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2707 1
a2707 1
	  fprintf(ofile, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0?0:((SCM1[%d].d[CHIP][%d][1]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d][1]>>32)>=(SCM1[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2710 1
a2710 1
	  fprintf(ofile, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+(INIT0?0:mexdist);\n", i, j, i, j, i, j);
d2713 1
a2713 1
	  printf("undefined conf[%d][%d].mex1op=%d\n", i, j, conf[i][j].cdw0.mex1op);
d2718 1
a2718 1
	fprintf(ofile, "adr = (Uint)(SCM1[%d].awoo[CHIP][%d] + SCM1[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2720 1
a2720 1
	fprintf(ofile, "adr = (Ull)(SCM1[%d].awoo[CHIP][%d] + SCM1[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2725 12
a2736 18
	  fprintf(ofile, "load64 = *(Ull*)(adr&~7LL);\n");
	  fprintf(ofile, "if ((adr&7) == 0)\n");
	  fprintf(ofile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = load64;\n", i, i, j*UNIT_WIDTH+1, i, j);
	  fprintf(ofile, "else if (!emax6_unaligned_load_valid) { /* BR[][][1] */\n");
	  fprintf(ofile, "  emax6_unaligned_load_valid = 1;\n");
	  fprintf(ofile, "  emax6_unaligned_load_high = load64;\n");
	  fprintf(ofile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+1, i, j);
	  fprintf(ofile, "}\n");
	  fprintf(ofile, "else { /* BR[][][0] */\n");
	  fprintf(ofile, "  emax6_unaligned_load_valid = 0;\n");
	  fprintf(ofile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM1[%d].d[CHIP][%d][1] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+1, i, j);
	  fprintf(ofile, "}\n");
	  break;
	case OP_LDWR: /* s32bit lmm LMM is preloaded, random-access */
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, i, j*UNIT_WIDTH+1);
	  break;
	case OP_LDUWR: /* u32bit lmm LMM is preloaded, random-access */
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, i, j*UNIT_WIDTH+1);
d2738 2
a2739 2
	case OP_LDBR: /* s8bit lmm LMM is preloaded, random-access */
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)(Uint)(int)*(char*)adr<<32 | (Ull)(Uint)(int)*(char*)adr;\n", i, i, j*UNIT_WIDTH+1);
d2741 2
a2742 2
	case OP_LDUBR: /* u8bit lmm LMM is preloaded, random-access */
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, i, j*UNIT_WIDTH+1);
d2745 4
a2748 4
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, i, j*UNIT_WIDTH+0);
          fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, i, j*UNIT_WIDTH+1);
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, i, j*UNIT_WIDTH+2);
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, i, j*UNIT_WIDTH+3);
d2751 1
a2751 1
	  printf("undefined conf[%d][%d].cdw1.ea1op=%d\n", i, j, conf[i][j].cdw1.ea1op);
d2763 3
a2765 3
	fprintf(ofile, "SCM0[%d].b[CHIP][%d] = (!(%d&1)||INIT0) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : SCM0[%d].awoo[CHIP][%d];\n", i, j, ea0bs, ea0bs, i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(ofile, "SCM0[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", i, j, ea0os, i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
	fprintf(ofile, "mexdist = (%d || INIT0) ? 0 : %d;\n", conf[i][j].cdw0.mex0op, conf[i][j].cdw0.mex0dist==0? 0: conf[i][j].cdw0.mex0dist==1? 1: conf[i][j].cdw0.mex0dist==2? 2:
d2770 1
a2770 1
	  fprintf(ofile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d2773 1
a2773 1
	  fprintf(ofile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0?0:((SCM0[%d].d[CHIP][%d][0]>>32)!=0xffffffff && (SCM0[%d].d[CHIP][%d][1]>>32)<=(SCM0[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2776 1
a2776 1
	  fprintf(ofile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0?0:((SCM0[%d].d[CHIP][%d][1]>>32)!=0xffffffff && (SCM0[%d].d[CHIP][%d][1]>>32)>=(SCM0[%d].d[CHIP][%d][0]>>32))?mexdist:0);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2779 1
a2779 1
	  fprintf(ofile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0?0:mexdist);\n", i, j, i, j, i, j);
d2782 1
a2782 1
	  printf("undefined conf[%d][%d].mex0op=%d\n", i, j, conf[i][j].cdw0.mex0op);
d2787 1
a2787 1
	fprintf(ofile, "adr = (Uint)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2789 1
a2789 1
	fprintf(ofile, "adr = (Ull)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d2794 12
a2805 15
	  fprintf(ofile, "load64 = *(Ull*)(adr&~7LL);\n");
	  fprintf(ofile, "if ((adr&7) == 0)\n");
	  fprintf(ofile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = load64;\n", i, i, j*UNIT_WIDTH+0, i, j);
	  fprintf(ofile, "else if (!emax6_unaligned_load_valid) { /* BR[][][1] */\n");
	  fprintf(ofile, "  emax6_unaligned_load_valid = 1;\n");
	  fprintf(ofile, "  emax6_unaligned_load_high = load64;\n");
	  fprintf(ofile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+0, i, j);
	  fprintf(ofile, "}\n");
	  fprintf(ofile, "else { /* BR[][][0] */\n");
	  fprintf(ofile, "  emax6_unaligned_load_valid = 0;\n");
	  fprintf(ofile, "  SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCM0[%d].d[CHIP][%d][0] = emax6_unaligned_load_high << (8-(adr&7))*8 | load64 >> (adr&7)*8;\n", i, i, j*UNIT_WIDTH+0, i, j);
	  fprintf(ofile, "}\n");
	  break;
	case OP_LDWR: /* s32bit lmm LMM is preloaded, random-access */
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, i, j*UNIT_WIDTH+0);
d2807 2
a2808 2
	case OP_LDUWR: /* u32bit lmm LMM is preloaded, random-access */
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)*(Uint*)(adr&~3LL)<<32 | (Ull)*(Uint*)(adr&~3LL);\n", i, i, j*UNIT_WIDTH+0);
d2810 2
a2811 5
	case OP_LDBR: /* s8bit lmm LMM is preloaded, random-access */
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)(Uint)(int)*(char*)adr<<32 | (Ull)(Uint)(int)*(char*)adr;\n", i, i, j*UNIT_WIDTH+0);
	  break;
	case OP_LDUBR: /* u8bit lmm LMM is preloaded, random-access */
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = (Ull)(Uint)*(Uchar*)adr<<32 | (Ull)(Uint)*(Uchar*)adr;\n", i, i, j*UNIT_WIDTH+0);
d2814 4
a2817 4
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+0);\n", i, i, j*UNIT_WIDTH+0);
          fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+1);\n", i, i, j*UNIT_WIDTH+1);
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+2);\n", i, i, j*UNIT_WIDTH+2);
	  fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = *((Ull*)(adr&~31LL)+3);\n", i, i, j*UNIT_WIDTH+3);
d2820 1
a2820 1
	  printf("undefined conf[%d][%d].cdw1.ea0op=%d\n", i, j, conf[i][j].cdw1.ea0op);
d2824 1
a2824 1
      fprintf(ofile, "}\n");
d2828 1
a2828 1
      fprintf(ofile, "{ union { Uint i; float f; } f3, f2, f1, f0; Ull t3, t2, t1, t0, ex1, ex2, ex3, ex4, ex5, c1, c0, ex1_outd, ex2_outd;\n");
d2848 2
a2849 2
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex1_outd = ex1;\n");
d2855 16
a2870 16
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(ofile, "f1.i = (Uint)(ex1);\n");
	  fprintf(ofile, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(ofile, "f3.i = (Uint)(ex3>>32);\n");
	  fprintf(ofile, "if (f2.i != -1 && f2.i == f3.i) {\n");
	  fprintf(ofile, "  f2.i = (Uint)(ex2);\n");
	  fprintf(ofile, "  f3.i = (Uint)(ex3);\n");
	  fprintf(ofile, "  f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(ofile, "}\n");
	  fprintf(ofile, "else {\n");
	  fprintf(ofile, "  f0.f = f1.f;\n");
	  fprintf(ofile, "}\n");
	  fprintf(ofile, "t0 = f0.i;\n");
	  fprintf(ofile, "ex1_outd = t0;\n");
d2875 14
a2888 14
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(ofile, "f1.i = (Uint)(ex1)>>32);\n");
	  fprintf(ofile, "f2.i = (Uint)(ex2>>32)^%08.8x;\n", conf[i][j].cdw0.op1==OP_FMA?0:0x80000000);
	  fprintf(ofile, "f3.i = (Uint)(ex3>>32);\n");
	  fprintf(ofile, "f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(ofile, "t2 = f0.i;\n");
	  fprintf(ofile, "f1.i = (Uint)(ex1);\n");
	  fprintf(ofile, "f2.i = (Uint)(ex2)^%08.8x;\n", conf[i][j].cdw0.op1==OP_FMA?0:0x80000000);
	  fprintf(ofile, "f3.i = (Uint)(ex3);\n");
	  fprintf(ofile, "f0.f = f1.f + (f2.f * f3.f);\n");
	  fprintf(ofile, "t0 = f0.i;\n");
	  fprintf(ofile, "ex1_outd = (t2<<32)|(t0);\n");
d2892 11
a2902 11
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "f1.i = (Uint)(ex1>>32);\n");
	  fprintf(ofile, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(ofile, "f0.f = f1.f + f2.f;\n");
	  fprintf(ofile, "t2 = f0.i;\n");
	  fprintf(ofile, "f1.i = (Uint)(ex1);\n");
	  fprintf(ofile, "f2.i = (Uint)(ex2);\n");
	  fprintf(ofile, "f0.f = f1.f + f2.f;\n");
	  fprintf(ofile, "t0 = f0.i;\n");
	  fprintf(ofile, "ex1_outd = (t2<<32)|(t0);\n");
d2906 11
a2916 11
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "f1.i = (Uint)(ex1>>32);\n");
	  fprintf(ofile, "f2.i = (Uint)(ex2>>32);\n");
	  fprintf(ofile, "f0.f = f1.f * f2.f;\n");
	  fprintf(ofile, "t2 = f0.i;\n");
	  fprintf(ofile, "f1.i = (Uint)(ex1);\n");
	  fprintf(ofile, "f2.i = (Uint)(ex2);\n");
	  fprintf(ofile, "f0.f = f1.f * f2.f;\n");
	  fprintf(ofile, "t0 = f0.i;\n");
	  fprintf(ofile, "ex1_outd = (t2<<32)|(t0);\n");
d2919 8
a2926 8
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(ofile, "t2 = (ex1>>32&0x00000000ffffffffLL)+((ex2>>32&0x00000000ffffffffLL)+(ex3>>32&0x00000000ffffffffLL));\n");
	  fprintf(ofile, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(ofile, "t0 = (ex1    &0x00000000ffffffffLL)+((ex2    &0x00000000ffffffffLL)+(ex3    &0x00000000ffffffffLL));\n");
	  fprintf(ofile, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(ofile, "ex1_outd = (t2<<32)|(t0);\n");
d2929 8
a2936 8
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(ofile, "t2 = (ex1>>32&0x00000000ffffffffLL)-((ex2>>32&0x00000000ffffffffLL)+(ex3>>32&0x00000000ffffffffLL));\n");
	  fprintf(ofile, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(ofile, "t0 = (ex1    &0x00000000ffffffffLL)-((ex2    &0x00000000ffffffffLL)+(ex3    &0x00000000ffffffffLL));\n");
	  fprintf(ofile, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(ofile, "ex1_outd = (t2<<32)|(t0);\n");
d2939 7
a2945 7
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "t2 = (ex1>>32&0x00000000ffffffffLL)+(ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(ofile, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(ofile, "t0 = (ex1    &0x00000000ffffffffLL)+(ex2    &0x00000000ffffffffLL);\n");
	  fprintf(ofile, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(ofile, "ex1_outd = (t2<<32)|(t0);\n");
d2948 7
a2954 7
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "t2 = (ex1>>32&0x00000000ffffffffLL)-(ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(ofile, "t2 &= 0x00000000ffffffffLL;\n");
	  fprintf(ofile, "t0 = (ex1    &0x00000000ffffffffLL)-(ex2    &0x00000000ffffffffLL);\n");
	  fprintf(ofile, "t0 &= 0x00000000ffffffffLL;\n");
	  fprintf(ofile, "ex1_outd = (t2<<32)|(t0);\n");
d2957 5
a2961 5
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "c1 = (ex1>>32&0x00000000ffffffffLL) == (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(ofile, "c0 = (ex1    &0x00000000ffffffffLL) == (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(ofile, "ex1_outd = (c1<<32)|c0;\n");
d2964 5
a2968 5
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "c1 = (ex1>>32&0x00000000ffffffffLL) != (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(ofile, "c0 = (ex1    &0x00000000ffffffffLL) != (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(ofile, "ex1_outd = (c1<<32)|c0;\n");
d2971 5
a2975 5
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "c1 = (ex1>>32&0x00000000ffffffffLL) < (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(ofile, "c0 = (ex1    &0x00000000ffffffffLL) < (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(ofile, "ex1_outd = (c1<<32)|c0;\n");
d2978 5
a2982 5
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "c1 = (ex1>>32&0x00000000ffffffffLL) <= (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(ofile, "c0 = (ex1    &0x00000000ffffffffLL) <= (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(ofile, "ex1_outd = (c1<<32)|c0;\n");
d2985 5
a2989 5
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "c1 = (ex1>>32&0x00000000ffffffffLL) > (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(ofile, "c0 = (ex1    &0x00000000ffffffffLL) > (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(ofile, "ex1_outd = (c1<<32)|c0;\n");
d2992 5
a2996 5
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "c1 = (ex1>>32&0x00000000ffffffffLL) >= (ex2>>32&0x00000000ffffffffLL);\n");
	  fprintf(ofile, "c0 = (ex1    &0x00000000ffffffffLL) >= (ex2    &0x00000000ffffffffLL);\n");
	  fprintf(ofile, "ex1_outd = (c1<<32)|c0;\n");
d2999 8
a3006 8
	  fprintf(ofile, "ex1 = exm(!%d||(INIT1&&INIT0)||((%d&1)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCAR[%d].r[CHIP][%d], %d);\n", ex1s, init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex1brs, i, j, ex1exp);
	  fprintf(ofile, "ex2 = exm(((%d&2)&&INIT0) ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : 0, %d);\n", init, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, i, j, ex2exp);
	  fprintf(ofile, "ex3 = exm(SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d], %d);\n",                             !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs, i, j, ex3exp);
	  fprintf(ofile, "c1 = ex1>>32&1;\n");
	  fprintf(ofile, "c0 = ex1    &1;\n");
	  fprintf(ofile, "t2 = c1 ? (ex2&0xffffffff00000000LL) : (ex3&0xffffffff00000000LL);\n");
	  fprintf(ofile, "t0 = c0 ? (ex2&0x00000000ffffffffLL) : (ex3&0x00000000ffffffffLL);\n");
	  fprintf(ofile, "ex1_outd = t2 | t0;\n");
d3009 1
a3009 1
	  printf("undefined conf[%d][%d].cdw0.op1=%d\n", i, j, conf[i][j].cdw0.op1);
d3016 1
a3016 1
	  fprintf(ofile, "ex2_outd = ex1_outd;\n");
d3019 2
a3020 2
	  fprintf(ofile, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(ofile, "ex2_outd = ex1_outd & ex4;\n");
d3023 2
a3024 2
	  fprintf(ofile, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(ofile, "ex2_outd = ex1_outd | ex4;\n");
d3027 2
a3028 2
	  fprintf(ofile, "ex4 = %d==0 ? 0x%08.8x%08.8xLL : %d==1 ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e2is, (Uint)(e2imm>>32), (Uint)e2imm, e2is, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex2brs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(ofile, "ex2_outd = ex1_outd ^ ex4;\n");
d3031 1
a3031 1
	  printf("undefined conf[%d][%d].cdw0.op2=%d\n", i, j, conf[i][j].cdw0.op2);
d3038 1
a3038 1
	  fprintf(ofile, "SCAR[%d].r[CHIP][%d] = ex2_outd;\n", i, j);
d3041 4
a3044 4
	  fprintf(ofile, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(ofile, "t1 = (Ull)(ex2_outd     &0xffffffff00000000LL)<<ex5;\n");
	  fprintf(ofile, "t0 = (Ull)(ex2_outd<<ex5&0x00000000ffffffffLL);\n");
	  fprintf(ofile, "SCAR[%d].r[CHIP][%d] = t1 | t0;\n", i, j);
d3047 4
a3050 4
	  fprintf(ofile, "ex5 = %d==0 ? 0x%08.8x : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", e3is, e3imm, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ex3brs);
	  fprintf(ofile, "t1 = (Ull)(ex2_outd>>ex5&0xffffffff00000000LL);\n");
	  fprintf(ofile, "t0 = (Ull)(ex2_outd     &0x00000000ffffffffLL)>>ex5;\n");
	  fprintf(ofile, "SCAR[%d].r[CHIP][%d] = t1 | t0;\n", i, j);
d3053 1
a3053 1
	  printf("undefined conf[%d][%d].cdw0.op3=%d\n", i, j, conf[i][j].cdw0.op3);
d3057 1
a3057 1
      fprintf(ofile, "}\n");
d3061 1
a3061 1
      fprintf(ofile, "{ Ull cs0, cs1, cs2, cs3, cex, adr, mexdist;\n");
d3071 5
a3075 5
	fprintf(ofile, "cs0 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs0);
	fprintf(ofile, "cs1 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs1);
	fprintf(ofile, "cs2 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs2);
	fprintf(ofile, "cs3 = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, cs3);
	fprintf(ofile, "cex = ((0x%04.4x>>(((cs3>>32&1)<<3)|((cs2>>32&1)<<2)|((cs1>>32&1)<<1)|(cs0>>32&1))&1)?2:0) | ((0x%04.4x>>(((cs3&1)<<3)|((cs2&1)<<2)|((cs1&1)<<1)|(cs0&1))&1)?1:0);\n", cex_tab, cex_tab);
d3095 1
a3095 1
	  fprintf(ofile, "cex = 3;\n");
d3097 3
a3099 3
	fprintf(ofile, "SCM0[%d].b[CHIP][%d] = (!(%d&1)||INIT0) ? ((%d&2)?SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]:SCM0[%d].b[CHIP][%d]) : SCM0[%d].awoo[CHIP][%d];\n", i, j, ea0bs, ea0bs, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, eab, i, j, i, j); /*初回 or mexinitの毎INIT0*/
	fprintf(ofile, "SCM0[%d].o[CHIP][%d] = eam(%d ? SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] : SCM0[%d].o[CHIP][%d], %d);\n", i, j, ea0os, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, eao, i, j, (Uint)conf[i][j].cdw1.ea0msk);
	fprintf(ofile, "mexdist = (%d || INIT0) ? 0 : %d;\n", conf[i][j].cdw0.mex0op, conf[i][j].cdw0.mex0dist==0? 0: conf[i][j].cdw0.mex0dist==1? 1: conf[i][j].cdw0.mex0dist==2? 2:
d3104 1
a3104 1
	  fprintf(ofile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d]);\n", i, j, i, j, i, j);
d3107 1
a3107 1
	  fprintf(ofile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+(INIT0?0:mexdist);\n", i, j, i, j, i, j);
d3110 1
a3110 1
	  printf("undefined conf[%d][%d].mex0op=%d\n", i, j, conf[i][j].cdw0.mex0op);
d3115 1
a3115 1
	fprintf(ofile, "adr = (Uint)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d3117 1
a3117 1
	fprintf(ofile, "adr = (Ull)(SCM0[%d].awoo[CHIP][%d] + SCM0[%d].o[CHIP][%d]);\n", i, j, i, j, i, j);
d3122 2
a3123 2
	  fprintf(ofile, "if (cex>>1&1) *((Uint*)(adr&~7LL)+1) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d])>>32;\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
	  fprintf(ofile, "if (cex   &1) *((Uint*)(adr&~7LL)  ) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n",     mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3126 1
a3126 1
	  fprintf(ofile, "if (cex   &1) *(Uint*)(adr&~3LL) = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3129 1
a3129 1
	  fprintf(ofile, "if (cex   &1) *(Uchar*)adr = (%d==1? SCAR[%d].r[CHIP][%d] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, j, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
d3132 4
a3135 4
	  fprintf(ofile, "*((Ull*)(adr&~31LL)+0) = (%d==1? SCAR[%d].r[CHIP][0] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws0, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts0);
	  fprintf(ofile, "*((Ull*)(adr&~31LL)+1) = (%d==1? SCAR[%d].r[CHIP][1] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws1, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts1);
	  fprintf(ofile, "*((Ull*)(adr&~31LL)+2) = (%d==1? SCAR[%d].r[CHIP][2] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws2, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts2);
	  fprintf(ofile, "*((Ull*)(adr&~31LL)+3) = (%d==1? SCAR[%d].r[CHIP][3] : SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d]);\n", mws3, i, !fold?(i+EMAX_DEPTH-1)%EMAX_DEPTH:i, i, ts3);
d3142 1
a3142 1
      fprintf(ofile, "}\n");
d3146 1
a3146 1
      fprintf(ofile, "{\n");
d3150 1
a3150 1
	fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+0, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts0);
d3154 1
a3154 1
	fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+1, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts1);
d3158 1
a3158 1
	fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+2, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts2);
d3161 1
a3161 1
	fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCAR[%d].r[CHIP][%d];\n", i, i, j*UNIT_WIDTH+2, i, j);
d3165 109
a3273 1
	fprintf(ofile, "SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d] = SCBR[%d].r[CHIP][SCBR[%d].enq[CHIP]][%d];\n", i, i, j*UNIT_WIDTH+3, (i+EMAX_DEPTH-1)%EMAX_DEPTH, ts3);
a3274 1
      fprintf(ofile, "}\n");
a3275 8
    fprintf(ofile, "SCBR[%d].deq[CHIP] = 1-SCBR[%d].deq[CHIP]; if (SCBR[%d].enq[CHIP] == SCBR[%d].deq[CHIP]) SCBR[%d].enq[CHIP] = 1-SCBR[%d].enq[CHIP];\n", (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, i, i, i);
    fprintf(ofile, "}\n"); /* for (CHIP) */
    if (conf[0][0].cdw0.op1 == OP_WHILE)
      fprintf(ofile, "}\n");
    if (conf[0][0].cdw0.op1 == OP_FOR)
      fprintf(ofile, "}\n");
    if (conf[0][1].cdw0.op1 == OP_FOR)
      fprintf(ofile, "}\n");
d3278 5
a3803 1
  case OP_LDUWR:
a3804 1
//case OP_LDUHR:
a3805 1
  case OP_LDUBR:
d4858 1
a4858 1
  int ea0singleload = (ea0op && (ea0op <= OP_LDUBR));
d4981 1
a4981 1
  int ea1singleload = (ea1op && (ea1op <= OP_LDUBR));
d5339 2
a5340 2
  int ea0singleload = (ea0op && (ea0op <= OP_LDUBR));
  int ea1singleload = (ea1op && (ea1op <= OP_LDUBR));
@


1.95
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.94 2021/12/16 09:22:27 nakashim Exp nakashim $";
d2729 1
a2729 1
  for (i=0; i<last_row; i++) {
@


1.94
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.93 2021/12/16 05:39:51 nakashim Exp nakashim $";
d2782 1
a2782 1
      fprintf(ofile, "{ Uint adr, mexdist, load64;\n");
d2802 1
a2802 1
	  fprintf(ofile, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+INIT0?0:((SCM1[%d].d[CHIP][%d][0]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d][1]>>32)<=(SCM1[%d].d[CHIP][%d][0]>>32))?mexdist:0;\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2805 1
a2805 1
	  fprintf(ofile, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+INIT0?0:((SCM1[%d].d[CHIP][%d][1]>>32)!=0xffffffff && (SCM1[%d].d[CHIP][%d][1]>>32)>=(SCM1[%d].d[CHIP][%d][0]>>32))?mexdist:0;\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2808 1
a2808 1
	  fprintf(ofile, "SCM1[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM1[%d].b[CHIP][%d]:SCM1[%d].awoo[CHIP][%d])+INIT0?0:mexdist;\n", i, j, i, j, i, j);
d2877 1
a2877 1
	  fprintf(ofile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+INIT0?0:((SCM0[%d].d[CHIP][%d][0]>>32)!=0xffffffff && (SCM0[%d].d[CHIP][%d][1]>>32)<=(SCM0[%d].d[CHIP][%d][0]>>32))?mexdist:0;\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2880 1
a2880 1
	  fprintf(ofile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+INIT0?0:((SCM0[%d].d[CHIP][%d][1]>>32)!=0xffffffff && (SCM0[%d].d[CHIP][%d][1]>>32)>=(SCM0[%d].d[CHIP][%d][0]>>32))?mexdist:0;\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2883 1
a2883 1
	  fprintf(ofile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+INIT0?0:mexdist;\n", i, j, i, j, i, j);
d3217 1
a3217 1
	  fprintf(ofile, "SCM0[%d].awoo[CHIP][%d] = (Ull)(INIT0?SCM0[%d].b[CHIP][%d]:SCM0[%d].awoo[CHIP][%d])+INIT0?0:mexdist;\n", i, j, i, j, i, j);
d3279 1
a3279 1
    //fprintf(ofile, "SCBR[%d].deq[CHIP] = 1-SCBR[%d].deq[CHIP]; if (SCBR[%d].enq[CHIP] == SCBR[%d].deq[CHIP]) SCBR[%d].enq[CHIP] = 1- SCBR[%d].enq[CHIP];\n", (i+EMAX_DEPTH-1)%EMAX_DEPTH, (i+EMAX_DEPTH-1)%EMAX_DEPTH, i, i, i, i);
@


1.93
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.92 2021/12/16 00:09:52 nakashim Exp nakashim $";
d2638 4
a2641 2
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "SCBR[%d].r[%d][SCBR[%d].enq[%d]][%d] = %d;\n", i, c, i, c, j*UNIT_WIDTH+k, c);
d2644 4
a2647 2
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "SCBR[%d].r[%d][SCBR[%d].enq[%d]][%d] = %s[%d];\n", i, c, i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name, c);
d2650 4
a2653 2
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "SCBR[%d].r[%d][SCBR[%d].enq[%d]][%d] = %s;\n", i, c, i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name);
d2656 4
a2659 2
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "SCBR[%d].r[%d][SCBR[%d].enq[%d]][%d] = %s[%d];\n", i, c, i, c, j*UNIT_WIDTH+k, id[regv[i][j].br[k].h].name, regv[i][j].br[k].s);
d3279 2
d3282 5
a3286 5
      fprintf(ofile, "}}\n");
    else if (conf[0][1].cdw0.op1 == OP_FOR && conf[0][0].cdw0.op1 == OP_FOR)
      fprintf(ofile, "}}}\n");
    else /* if (conf[0][0].cdw0.op1 == OP_FOR) */
      fprintf(ofile, "}}\n");
@


1.92
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.91 2021/12/15 23:31:09 nakashim Exp nakashim $";
d2756 1
a2756 1
    /* exe[i]                 ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓  (先頭かつ deq-==enq0)なら exe開始.exe後deq-=1-deq-, enq0==deq0ならenq0=1-enq0 */
d2763 1
a2763 1
    /* exe[i+1]                           ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓  (enq0!=deq0 && deq0==enq1)★なら exe開始.exe後deq0=1-deq0, enq1==dec1ならenq1=1-enq1 */
d2770 1
a2770 1
    /* exe[i+2]                                       ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓    ★ ↓ ↓  (enq1!=deq1 && deq1==enq2)★なら exe開始.exe後deq1=1-deq1, enq2==dec2ならenq2=1-enq2 */
@


1.91
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.90 2021/12/08 00:58:43 nakashim Exp nakashim $";
d2632 89
@


1.90
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.89 2021/09/21 07:42:15 nakashim Exp nakashim $";
d3093 1
a3093 1
	int fold  = conf[i][j].cdw0.fold;    /* 0:normal, 1:load-exe-store folding */
d3107 3
@


1.89
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.88 2021/08/11 10:54:45 nakashim Exp nakashim $";
d28 2
a29 1
  if (mode == 1) /* emit drain */
d31 1
d1008 1
a1008 1
        dexu->ex1e   = EXP_H3210;    /* 0:--, 1:B5410, 2:B7632, 3:H3210 */
d1012 1
a1012 1
        dexu->ex2e   = EXP_H3210;    /* 0:--, 1:B5410, 2:B7632, 3:H3210 */
d1016 1
a1016 1
        dexu->ex3e   =  0;           /* 0:--, 1:B5410, 2:B7632, 3:H3210 */
d2614 577
a3190 1
  /* Step 7 ... emit all                                                                                    */
d3193 1
d3321 2
a3322 1
  if (mode == 1) /* emit drain */
d3324 1
d3632 1
d3634 1
a3634 1
  /* Step 8 ... emit tgif                                                                                   */
d4265 1
a4265 1
           conf[i][j].cdw0.ex1exp, /*:  2; 0:--, 1:B5410, 2:B7632, 3:H3210 */
d4267 1
a4267 1
           conf[i][j].cdw0.ex2exp, /*:  2; 0:--, 1:B5410, 2:B7632, 3:H3210 */
d4269 1
a4269 1
           conf[i][j].cdw0.ex3exp, /*:  2; 0:--, 1:B5410, 2:B7632, 3:H3210 */
d4593 1
a4593 1
         int ex1exp, /*:  2; 0:--, 1:B5410, 2:B7632, 3:H3210 */
d4595 1
a4595 1
         int ex2exp, /*:  2; 0:--, 1:B5410, 2:B7632, 3:H3210 */
d4597 1
a4597 1
         int ex3exp, /*:  2; 0:--, 1:B5410, 2:B7632, 3:H3210 */
@


1.88
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.87 2021/08/11 04:45:48 nakashim Exp nakashim $";
d20 1
d25 1
d604 1
d822 94
d1024 2
a1025 2
        dmop1->updt  = 1;  /* for internal update of ea1 */
        dmop1->offsm = 15; /* for internal update of ea1 */
d1029 2
a1030 2
        dmop1->updt  = 1;  /* for internal update of ea1 */
        dmop1->offsm = 15; /* for internal update of ea1 */
d1041 1
a1041 1
        set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
d1486 7
d1495 2
d1519 2
d1523 1
a1523 1
      if (last_mop==1) /* load */
d1525 8
a1532 1
      else /* store/load */
d1534 7
d1550 2
a1551 1
        set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
d1557 3
d1634 2
a1635 1
        set_reg_path(last_row, last_col, folding, type, RTYPE_BASE, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
d1638 4
a1641 1
          if (insn[i].imop.mtype == MTYPE_RLOAD) {
d1644 13
a1656 4
          else {
	    int rw = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
	    int f  = id[dmop0->forceh].val;
	    int p  = 0; /* initial value */
d1658 19
a1676 19
	    case 0: /* lmr */ case 1: /* lmp */ case 2: /* lmf */ conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
	    case 4: /* lmw */ case 5: /* lmd */                   conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
	    case 6: /* lmx */                                     conf[last_row][last_col].cdw2.lmm_axiw = 1; conf[last_row][last_col].cdw2.lmm_axir = 1; break;
	    case 3: /* lddmq */ case 7: /* tr */                  conf[last_row][last_col].cdw2.lmm_axiw = 0; conf[last_row][last_col].cdw2.lmm_axir = 0; break;
	    }
	    conf[last_row][last_col].cdw2.lmm_mode = 3;
            lmmi[last_row][last_col].v     = 1;
            lmmi[last_row][last_col].rw    = rw;
            lmmi[last_row][last_col].f     = f;
            lmmi[last_row][last_col].p     = p;
            lmmi[last_row][last_col].blk   = dmop0->blk;
	    lmmi[last_row][last_col].cidx  = id[dmop0->toph].cidx;
            lmmi[last_row][last_col].len   = id[dmop0->lenh].val-1;
            lmmi[last_row][last_col].ofs   = 0; /* initial value */
            lmmi[last_row][last_col].top   = (Ull)id[dmop0->toph].name;
            lmmx[last_row][last_col].forcev= dmop0->forcev;
            lmmx[last_row][last_col].forceh= dmop0->forceh;
            lmmx[last_row][last_col].lenv  = dmop0->lenv;
            lmmx[last_row][last_col].lenh  = dmop0->lenh;
d1840 1
d1849 24
d1875 3
a1877 3
      conf[i][j].cdw1.ea0op  = dec[i][j].dmop0.op;
      conf[i][j].cdw1.ea0bs  =((!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0brv?0:2)|(dec[i][j].dmop0.updt?1:0); /* 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
      conf[i][j].cdw1.ea0os  = (!dec[i][j].dmop0.op||dec[i][j].dmop0.op==OP_IM_PREF )||bus[i][j].ea0orv?0:1;                             /* 0:ea0or, 1:eaobrs */
d1879 25
d1906 1
a1906 1
        conf[i][j].cdw1.ea1op  = dec[i][j].dmop0.op;
d1908 3
a1910 3
        conf[i][j].cdw1.ea1op  = dec[i][j].dmop1.op;
      conf[i][j].cdw1.ea1bs  =((!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1brv?0:2)|(dec[i][j].dmop1.updt?1:0); /* 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(eabbrs+self-loop) */
      conf[i][j].cdw1.ea1os  = (!dec[i][j].dmop1.op||dec[i][j].dmop1.op==OP_IM_DRAIN)||bus[i][j].ea1orv?0:1;                             /* 0:ea1or, 1:eaobrs */
d1912 3
d2852 1
a2852 1
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0b = %s[%d];\n", c, i, j, id[regv[i][j].ea0b_h].name, c);
d2855 1
a2855 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = %s;\n", i, j, id[regv[i][j].ea0b_h].name);
d2857 1
a2857 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = %s[%d];\n", i, j, id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
d2862 1
a2862 1
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea0o = %s[%d];\n", c, i, j, id[regv[i][j].ea0o_h].name, c);
d2865 1
a2865 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = %s;\n", i, j, id[regv[i][j].ea0o_h].name);
d2867 1
a2867 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = %s[%d];\n", i, j, id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
d2872 1
a2872 1
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1b = %s[%d];\n", c, i, j, id[regv[i][j].ea1b_h].name, c);
d2875 1
a2875 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = %s;\n", i, j, id[regv[i][j].ea1b_h].name);
d2877 1
a2877 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = %s[%d];\n", i, j, id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
d2882 1
a2882 1
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[%d].addr[%d][%d].ea1o = %s[%d];\n", c, i, j, id[regv[i][j].ea1o_h].name, c);
d2885 1
a2885 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = %s;\n", i, j, id[regv[i][j].ea1o_h].name);
d2887 1
a2887 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = %s[%d];\n", i, j, id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
d3212 2
a3213 2
     /* reg_type:  ITYPE_MO4/ITYPE_MOPの場合のみ有効: レジスタ種別 RTYPE_DATA, RTYPE_BASE, RTYPE_OFFS */
     /* reg_loc:   ITYPE_MO4/ITYPE_MOPの場合のみ有効: MO4/MOPのbase/offsの位置 0:mop0, 1:mop1 */
d3226 1
a3226 1
    if (insn_type == ITYPE_MO4 || insn_type == ITYPE_MOP) { /* store4/store1 */
d3229 1
a3229 1
        printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot store constant variable %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
d3234 1
a3234 1
            printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
d3247 1
a3247 1
            printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_BASE %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
d3262 1
a3262 1
            printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with prefetch)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
d3273 1
a3273 1
            printf("in %s: [%d][%d] ITYPE_MO4/ITYPE_MOP cannot find empty reg for RTYPE_OFFS %s (may conflict with drain)\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
d3704 10
a3713 6
           conf[i][j].cdw1.ea0op,  /*:  5; mem_opcd */
           conf[i][j].cdw1.ea0bs,  /*:  2; 0:ea0br, 1:ea0dr(ea0br+self-loop), 2:eabbrs, 3:ea0dr(eabbrs+self-loop) */
           conf[i][j].cdw1.ea0os,  /*:  1; 0:ea0or, 1:eaobrs */
           conf[i][j].cdw1.ea0msk, /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
           conf[i][j].cdw1.eabbrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
           conf[i][j].cdw1.eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
d3717 9
a3725 6
           conf[i][j].cdw1.ea1op,  /*:  5; mem_opcd */
           conf[i][j].cdw1.ea1bs,  /*:  2; 0:ea1br, 1:ea1dr(ea1br+self-loop), 2:eabbrs, 3:ea1dr(self-loop) */
           conf[i][j].cdw1.ea1os,  /*:  1; 0:ea1or, 1:eaobrs */
           conf[i][j].cdw1.ea1msk, /*:  4; 14:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
           conf[i][j].cdw1.eabbrs, /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
           conf[i][j].cdw1.eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
d3744 9
a3752 7
           conf[i][j].cdw1.ea0op,  /*:  5; mem_opcd */
           conf[i][j].cdw2.mwsa,   /*:  1; 0:lmwa,  1:ea0d        */
           conf[i][j].cdw2.mws0,   /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
           conf[i][j].cdw2.mws1,   /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
           conf[i][j].cdw2.mws2,   /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
           conf[i][j].cdw2.mws3,   /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
           conf[i][j].cdw2.lmm_mode/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
d3764 1
d3767 1
d3770 1
d3772 2
a3773 1
           bus[i][j].br[3].h
d4174 4
a4177 1
         int eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
d4240 3
a4242 1
  if (ea0bs & 1) { /* feedback-loop */
d4253 15
d4297 4
a4300 1
         int eaobrs  /*:  4; 0:br0_0, 1:br0_1, ... 15:3_3 */
d4363 3
a4365 1
  if (ea1bs & 1) { /* feedback-loop */
d4376 15
d4492 9
a4500 7
         int ea0op,  /* MWSAに加え,LDDMQおよびSTOREの場合にもMW有効 */
         int mwsa,   /*:  1; 0:lmwa,  1:ea0d        */
         int mws0,   /*:  2; 0:lmwd0, 1:exdr, 2:ts0 */
         int mws1,   /*:  2; 0:lmwd1, 1:exdr, 2:ts1 */
         int mws2,   /*:  2; 0:lmwd2, 1:exdr, 2:ts2 */
         int mws3,   /*:  2; 0:lmwd3, 1:exdr, 2:ts3 */
	 int lmm_mode/*:  2; 0:無効, 1:分割無, 2:2分割, 3:4分割 */
d4506 1
a4506 1
  int ea0store = (ea0op&0x10);
d4509 1
a4509 1
  if (mwsa==0) {
d4520 1
a4520 1
  if (ea0store || mwsa==0) {
d4535 2
a4536 2
  if ((ea0store || mwsa==0) && mws0==0) { col=1; /*red*/   thi=3; } /* lmwd0 */
  else                               { col=0; /*black*/ thi=1; }
d4538 2
a4539 2
  if ((ea0store || mwsa==0) && mws0==1) { col=1; /*red*/   thi=3; } /* exdr */
  else                               { col=0; /*black*/ thi=1; }
d4541 2
a4542 2
  if ((ea0store || mwsa==0) && mws0==2) { col=1; /*red*/   thi=3; } /* ts0 */
  else                               { col=0; /*black*/ thi=1; }
d4546 1
a4546 1
  if (ea0store || mwsa==0) {
d4561 2
a4562 2
  if ((ea0store || mwsa==0) && mws1==0) { col=1; /*red*/   thi=3; } /* lmwd1 */
  else                               { col=0; /*black*/ thi=1; }
d4564 2
a4565 2
  if ((ea0store || mwsa==0) && mws1==1) { col=1; /*red*/   thi=3; } /* exdr */
  else                               { col=0; /*black*/ thi=1; }
d4567 2
a4568 2
  if ((ea0store || mwsa==0) && mws1==2) { col=1; /*red*/   thi=3; } /* ts1 */
  else                               { col=0; /*black*/ thi=1; }
d4572 1
a4572 1
  if (ea0store || mwsa==0) {
d4587 2
a4588 2
  if ((ea0store || mwsa==0) && mws2==0) { col=1; /*red*/   thi=3; } /* lmwd2 */
  else                               { col=0; /*black*/ thi=1; }
d4590 2
a4591 2
  if ((ea0store || mwsa==0) && mws2==1) { col=1; /*red*/   thi=3; } /* exdr */
  else                               { col=0; /*black*/ thi=1; }
d4593 2
a4594 2
  if ((ea0store || mwsa==0) && mws2==2) { col=1; /*red*/   thi=3; } /* ts2 */
  else                               { col=0; /*black*/ thi=1; }
d4598 1
a4598 1
  if (ea0store || mwsa==0) {
d4613 2
a4614 2
  if ((ea0store || mwsa==0) && mws3==0) { col=1; /*red*/   thi=3; } /* lmwd3 */
  else                               { col=0; /*black*/ thi=1; }
d4616 2
a4617 2
  if ((ea0store || mwsa==0) && mws3==1) { col=1; /*red*/   thi=3; } /* exdr */
  else                               { col=0; /*black*/ thi=1; }
d4619 2
a4620 2
  if ((ea0store || mwsa==0) && mws3==2) { col=1; /*red*/   thi=3; } /* ts3 */
  else                               { col=0; /*black*/ thi=1; }
d4625 1
a4625 1
    draw_text(lmb_x+430, lmb_y+15, "M0", 1, 0);
d4628 1
a4628 1
    draw_text(lmb_x+430, lmb_y+15, "M1", 1, 0);
d4631 1
a4631 1
    draw_text(lmb_x+430, lmb_y+15, "M2", 1, 0);
d4634 1
a4634 1
    draw_text(lmb_x+430, lmb_y+15, "M3", 1, 0);
d4637 1
d4649 1
d4652 1
d4655 1
d4657 2
a4658 1
         int br3h
d4744 5
a4748 1
    draw_text(bri_x+365,   bri_y+14, id[br0h].name, 1, 0);
d4824 5
a4828 1
    draw_text(bri_x+245,   bri_y+14, id[br1h].name, 1, 0);
d4888 5
a4892 1
    draw_text(bri_x+125,   bri_y+14, id[br2h].name, 1, 0);
d4947 5
a4951 1
    draw_text(bri_x+5,     bri_y+14, id[br3h].name, 1, 0);
@


1.87
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.86 2021/06/18 03:04:05 nakashim Exp nakashim $";
a2425 1
  fprintf(ofile, "\temax6.lastdist = 0;\n");
d2559 1
@


1.86
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.85 2021/06/10 13:44:07 nakashim Exp nakashim $";
d2426 1
@


1.85
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.84 2021/06/08 12:05:28 nakashim Exp nakashim $";
d3514 1
a3514 1
           conf[i][j].cdw1.ea0msk, /*:  4; 15:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
d3523 1
a3523 1
           conf[i][j].cdw1.ea1msk, /*:  4; 15:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
d3966 1
a3966 1
         int ea0msk, /*:  4; 15:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
d4069 1
a4069 1
         int ea1msk, /*:  4; 15:64bit, 13:word1, 12:word0, 11-8:half3-0, 7-0:byte7-0 of offset */
@


1.84
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.83 2021/06/08 09:18:14 nakashim Exp nakashim $";
d425 8
d435 1
a435 5
        insn[i].iexe.src5v = T_NONE; /* delete */
        break;
      case OP_SFMAMAG:
	if (insn[i].iexe.op1 == OP_SFMA)
	  get_valid_row(ITYPE_EX4, 0, insn[i].iexe.src5v, insn[i].iexe.src5h, rdep);
d523 3
a525 3
        dexu->e2iv   = T_NONE;
        dexu->e2ih   = -1;
        dexu->e2is   = 0;
@


1.83
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.82 2021/06/08 07:36:27 nakashim Exp nakashim $";
d425 12
d522 3
a524 3
        dexu->e3iv   = T_NONE;
        dexu->e3ih   = -1;
        dexu->e3is   = 0;
@


1.82
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.81 2021/06/06 06:24:28 nakashim Exp nakashim $";
d497 1
a497 1
        dexu->ex1s   = j;
d515 1
a515 1
        dexu->exds   = j;
d3363 1
a3363 1
    printf("in %s: [%d][] (folding=%d) cannot find source bus[%d][].br[] for %s sidx=%d (malfunction)\n", id[current_prefix].name, (row+1)%EMAX_DEPTH, folding, row, id[src_hash].name, src_sidx);
@


1.81
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.80 2021/03/12 04:19:27 nakashim Exp $";
d412 1
d425 3
d431 20
a450 2
          last_row = *rdep;
          last_col = 0; /* 位置指定可能ex4.dstはALRのみ.var経由の同一row内後続st4()を配置可能 */
d494 1
a494 1
	dexu->fold   = 0; /* normal */
d521 3
a523 3
        set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dexu->ex1v, dexu->ex1h, dexu->ex1s); /* ex1s=3,2,1,0 */
        set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dexu->ex2v, dexu->ex2h, dexu->ex2s); /* ex2s=3,2,1,0 */
        set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dexu->ex3v, dexu->ex3h, dexu->ex3s); /* ex3s=3,2,1,0 */
d824 3
d3178 5
a3182 5
      if (insn_type == ITYPE_EX4 || insn_type == ITYPE_MO4) { /* multiple use (ex4/store4) */
        /* find same TR4+BR4 */
        for (j=0; j<EMAX_WIDTH; j++) {
          for (k=0; k<UNIT_WIDTH; k++) {
            if (!(bus[h][j].tr[k].v==src_type && bus[h][j].tr[k].h==src_hash && bus[h][j].tr[k].s==k
d3184 7
a3190 7
              break;
          }
          if (k >= UNIT_WIDTH)
            goto srp_tr_br_ready; /* found & proceed */
        }
        /* find empty TR4+BR4 */
        for (j=0; j<EMAX_WIDTH; j++) {
d3192 3
a3194 3
          /* LMM-bufferingのためには，伝搬REGがLMP対象UNITに混在してはダメ */
          if (lmmi[h][j].v && !lmmi[h][j].rw && lmmi[h][j].p) /* conflict with lmm pload */
            continue;
d3196 5
a3200 5
          for (k=0; k<UNIT_WIDTH; k++) {
            if (bus[h][j].tr[k].v || bus[h][j].br[k].v) /* inuse */
              break;
          }
          if (k >= UNIT_WIDTH) { /* empty TR4+BR4 found */
d3202 7
a3208 7
              bus[h][j].tr[k].v = src_type;
              bus[h][j].tr[k].h = src_hash;
              bus[h][j].tr[k].s = k;
              bus[h][j].br[k].v = src_type;
              bus[h][j].br[k].h = src_hash;
              bus[h][j].br[k].s = k;
            }
d3210 8
a3217 8
            conf[h][j].cdw2.brs1 = 2; /* 2:tr1 */
            conf[h][j].cdw2.brs2 = 2; /* 2:tr2 */
            conf[h][j].cdw2.brs3 = 2; /* 2:tr3 */
            goto srp_tr_br_ready; /* found & proceed */
          }
        }
        printf("in %s: [%d][%d] cannot find TR4+BR4 for %s\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
        exit(1);
@


1.80
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.79 2021/02/28 05:58:02 nakashim Exp nakashim $";
d9 1
a9 1
/* emax6.c 2012/9/22 */ 
@


1.79
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.78 2020/12/13 23:26:44 nakashim Exp nakashim $";
d2498 1
a2498 1
    fprintf(ofile, "\t            *(Ull*)&(reg_ctrl->i[c].addr[i][j].top) = ((Ull)(emax6.lmmi[c][i][j][lmmic].top+*((Ushort*)&emax6.lmmi[c][i][j][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)emax6.lmmi[c][i][j][lmmic].top;\n");
d2713 1
a2713 1
	    fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+*((Ushort*)&emax6.lmmi[%d][%d][%d][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)emax6.lmmi[%d][%d][%d][lmmic].top;\n", c, i, j, c, source_i, j, c, source_i, j, c, source_i, j);
d2716 1
a2716 1
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[0][%d][%d][lmmic].top+*((Ushort*)&emax6.lmmi[0][%d][%d][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)emax6.lmmi[0][%d][%d][lmmic].top;\n", i, j, source_i, j, source_i, j, source_i, j);
d2768 1
a2768 1
	    fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+emax6.lmmi[%d][%d][%d][lmmic].ofs+*((Ushort*)&emax6.lmmi[%d][%d][%d][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+emax6.lmmi[%d][%d][%d][lmmic].ofs);\n", c, i, j, c, i, j, c, i, j, c, i, j, c, i, j, c, i, j);
d2771 1
a2771 1
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[0][%d][%d][lmmic].top+emax6.lmmi[0][%d][%d][lmmic].ofs+*((Ushort*)&emax6.lmmi[0][%d][%d][lmmic]+1)*sizeof(Uint)+(sizeof(Uint)-1))<<32) | (Ull)(emax6.lmmi[0][%d][%d][lmmic].top+emax6.lmmi[0][%d][%d][lmmic].ofs);\n", i, j, i, j, i, j, i, j, i, j, i, j);
@


1.78
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.77 2020/11/25 00:52:40 nakashim Exp nakashim $";
d2498 1
a2498 1
    fprintf(ofile, "\t            *(Ull*)&(reg_ctrl->i[c].addr[i][j].top) = ((Ull)(emax6.lmmi[c][i][j][lmmic].top+*((Ushort*)&emax6.lmmi[c][i][j][lmmic]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[c][i][j][lmmic].top;\n");
d2713 1
a2713 1
	    fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+*((Ushort*)&emax6.lmmi[%d][%d][%d][lmmic]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[%d][%d][%d][lmmic].top;\n", c, i, j, c, source_i, j, c, source_i, j, c, source_i, j);
d2716 1
a2716 1
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[0][%d][%d][lmmic].top+*((Ushort*)&emax6.lmmi[0][%d][%d][lmmic]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[0][%d][%d][lmmic].top;\n", i, j, source_i, j, source_i, j, source_i, j);
d2768 1
a2768 1
	    fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+emax6.lmmi[%d][%d][%d][lmmic].ofs+*((Ushort*)&emax6.lmmi[%d][%d][%d][lmmic]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+emax6.lmmi[%d][%d][%d][lmmic].ofs);\n", c, i, j, c, i, j, c, i, j, c, i, j, c, i, j, c, i, j);
d2771 1
a2771 1
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[0][%d][%d][lmmic].top+emax6.lmmi[0][%d][%d][lmmic].ofs+*((Ushort*)&emax6.lmmi[0][%d][%d][lmmic]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)(emax6.lmmi[0][%d][%d][lmmic].top+emax6.lmmi[0][%d][%d][lmmic].ofs);\n", i, j, i, j, i, j, i, j, i, j, i, j);
@


1.77
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.76 2020/11/25 00:18:08 nakashim Exp nakashim $";
d3616 1
a3616 1
    thi=5;
d3620 1
a3620 1
    thi=5;
d3624 1
a3624 1
    thi=5;
d3628 1
a3628 1
    thi=5;
d3632 1
a3632 1
    thi=5;
d3636 1
a3636 1
    thi=5;
d3654 1
a3654 1
    thi=5;
d3658 1
a3658 1
    thi=5;
d3662 1
a3662 1
    thi=5;
d3666 1
a3666 1
    thi=5;
d3670 1
a3670 1
    thi=5;
d3674 1
a3674 1
    thi=5;
d3695 1
a3695 1
      thi=5;
d3699 1
a3699 1
      thi=5;
d3703 1
a3703 1
      thi=5;
d3707 1
a3707 1
      thi=5;
d3711 1
a3711 1
      thi=5;
d3715 1
a3715 1
      thi=5;
d3729 1
a3729 1
      thi=5;
d3733 1
a3733 1
      thi=5;
d3737 1
a3737 1
      thi=5;
d3741 1
a3741 1
      thi=5;
d3745 1
a3745 1
      thi=5;
d3749 1
a3749 1
      thi=5;
d3782 1
a3782 1
    thi=5;
d3813 1
a3813 1
    thi=5;
d3822 1
a3822 1
    thi=5;
d3834 1
a3834 1
    thi=5;
d3844 1
a3844 1
    thi=5;
d3869 1
a3869 1
    thi=5;
d3882 1
a3882 1
    thi=5;
d3892 1
a3892 1
    thi=5;
d3902 1
a3902 1
    thi=5;
d3912 1
a3912 1
    thi=5;
d3938 1
a3938 1
    thi=5;
d3958 1
a3958 1
    thi=5;
d3971 1
a3971 1
    thi=5;
d3981 1
a3981 1
    thi=5;
d3992 1
a3992 1
    thi=5;
d4004 1
a4004 1
    thi=5;
d4014 1
a4014 1
    thi=5;
d4041 1
a4041 1
    thi=5;
d4061 1
a4061 1
    thi=5;
d4074 1
a4074 1
    thi=5;
d4084 1
a4084 1
    thi=5;
d4095 1
a4095 1
    thi=5;
d4107 1
a4107 1
    thi=5;
d4117 1
a4117 1
    thi=5;
d4148 1
a4148 1
  if (tr0v) { col=2; /*green*/ thi=5; }
d4151 1
a4151 1
  if (tr0v && trs0==0) { col=2; /*green*/ thi=5; } /* lmwd */
d4154 1
a4154 1
  if (tr0v && trs0==1) { col=2; /*green*/ thi=5; } /* exdr */
d4157 1
a4157 1
  if (tr0v && trs0==2) { col=2; /*green*/ thi=5; } /* ts */
d4162 1
a4162 1
  if (tr1v) { col=2; /*green*/ thi=5; }
d4165 1
a4165 1
  if (tr1v && trs1==0) { col=2; /*green*/ thi=5; } /* lmwd */
d4168 1
a4168 1
  if (tr1v && trs1==1) { col=2; /*green*/ thi=5; } /* exdr */
d4171 1
a4171 1
  if (tr1v && trs1==2) { col=2; /*green*/ thi=5; } /* ts */
d4176 1
a4176 1
  if (tr2v) { col=2; /*green*/ thi=5; }
d4179 1
a4179 1
  if (tr2v && trs2==0) { col=2; /*green*/ thi=5; } /* lmwd */
d4182 1
a4182 1
  if (tr2v && trs2==1) { col=2; /*green*/ thi=5; } /* exdr */
d4185 1
a4185 1
  if (tr2v && trs2==2) { col=2; /*green*/ thi=5; } /* ts */
d4190 1
a4190 1
  if (tr3v) { col=2; /*green*/ thi=5; }
d4193 1
a4193 1
  if (tr3v && trs3==0) { col=2; /*green*/ thi=5; } /* lmwd */
d4196 1
a4196 1
  if (tr3v && trs3==1) { col=2; /*green*/ thi=5; } /* exdr */
d4199 1
a4199 1
  if (tr3v && trs3==2) { col=2; /*green*/ thi=5; } /* ts */
d4222 1
a4222 1
    thi=5;
d4233 1
a4233 1
    thi=5;
d4246 1
a4246 1
  if ((ea0store || mwsa==0) && mws0==0) { col=1; /*red*/   thi=5; } /* lmwd0 */
d4249 1
a4249 1
  if ((ea0store || mwsa==0) && mws0==1) { col=1; /*red*/   thi=5; } /* exdr */
d4252 1
a4252 1
  if ((ea0store || mwsa==0) && mws0==2) { col=1; /*red*/   thi=5; } /* ts0 */
d4259 1
a4259 1
    thi=5;
d4272 1
a4272 1
  if ((ea0store || mwsa==0) && mws1==0) { col=1; /*red*/   thi=5; } /* lmwd1 */
d4275 1
a4275 1
  if ((ea0store || mwsa==0) && mws1==1) { col=1; /*red*/   thi=5; } /* exdr */
d4278 1
a4278 1
  if ((ea0store || mwsa==0) && mws1==2) { col=1; /*red*/   thi=5; } /* ts1 */
d4285 1
a4285 1
    thi=5;
d4298 1
a4298 1
  if ((ea0store || mwsa==0) && mws2==0) { col=1; /*red*/   thi=5; } /* lmwd2 */
d4301 1
a4301 1
  if ((ea0store || mwsa==0) && mws2==1) { col=1; /*red*/   thi=5; } /* exdr */
d4304 1
a4304 1
  if ((ea0store || mwsa==0) && mws2==2) { col=1; /*red*/   thi=5; } /* ts2 */
d4311 1
a4311 1
    thi=5;
d4324 1
a4324 1
  if ((ea0store || mwsa==0) && mws3==0) { col=1; /*red*/   thi=5; } /* lmwd3 */
d4327 1
a4327 1
  if ((ea0store || mwsa==0) && mws3==1) { col=1; /*red*/   thi=5; } /* exdr */
d4330 1
a4330 1
  if ((ea0store || mwsa==0) && mws3==2) { col=1; /*red*/   thi=5; } /* ts3 */
d4376 1
a4376 1
    thi=5;
d4383 1
a4383 1
  if (brs0==1) { col=4; thi=5; } /* mr10 */
d4390 1
a4390 1
  if (brs0==2) { col=4; thi=5; } /* tr0 */
d4393 1
a4393 1
  if (brs0==3) { col=4; thi=5; } /* mr0 */
d4425 1
a4425 1
    thi=5;
d4429 1
a4429 1
    thi=5;
d4433 1
a4433 1
    thi=5;
d4437 1
a4437 1
    thi=5;
d4441 1
a4441 1
    thi=5;
d4445 1
a4445 1
    thi=5;
d4456 1
a4456 1
    thi=5;
d4463 1
a4463 1
  if (brs1==1) { col=4; thi=5; } /* mr11 */
d4470 1
a4470 1
  if (brs1==2) { col=4; thi=5; } /* tr1 */
d4473 1
a4473 1
  if (brs1==3) { col=4; thi=5; } /* mr1 */
d4501 1
a4501 1
    thi=5;
d4505 1
a4505 1
    thi=5;
d4509 1
a4509 1
    thi=5;
d4513 1
a4513 1
    thi=5;
d4517 1
a4517 1
    thi=5;
d4521 1
a4521 1
    thi=5;
d4532 1
a4532 1
    thi=5;
d4539 1
a4539 1
  if (brs2==1) { col=4; thi=5; } /* mr12 */
d4546 1
a4546 1
  if (brs2==2) { col=4; thi=5; } /* tr2 */
d4549 1
a4549 1
  if (brs2==3) { col=5; thi=5; } /* exdr */
d4561 1
a4561 1
    thi=5;
d4565 1
a4565 1
    thi=5;
d4569 1
a4569 1
    thi=5;
d4573 1
a4573 1
    thi=5;
d4577 1
a4577 1
    thi=5;
d4581 1
a4581 1
    thi=5;
d4592 1
a4592 1
    thi=5;
d4599 1
a4599 1
  if (brs3==1) { col=4; thi=5; } /* mr13 */
d4606 1
a4606 1
  if (brs3==2) { col=4; thi=5; } /* tr3 */
d4616 1
a4616 1
    thi=5;
d4620 1
a4620 1
    thi=5;
d4624 1
a4624 1
    thi=5;
d4628 1
a4628 1
    thi=5;
d4632 1
a4632 1
    thi=5;
d4636 1
a4636 1
    thi=5;
d4657 1
a4657 1
    thi=5;
d4671 1
a4671 1
    thi=5;
d4685 1
a4685 1
    thi=5;
d4699 1
a4699 1
    thi=5;
d4713 1
a4713 1
    thi=5;
@


1.76
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.75 2020/11/16 13:15:28 nakashim Exp nakashim $";
d550 1
a550 3
#if 0
      case OP_CCAT:   /* 2 */
#endif
d594 1
a594 1
      case OP_WSWAP:
d609 2
a610 4
#if 0
      case OP_SRAC:
      case OP_SRAD:
#endif
d1240 1
a1240 3
#if 0
      case OP_STHR: /* 16bit */
#endif
d1247 2
a1248 4
#if 0
      case OP_LDHR: /* 16bit signed */
      case OP_LDUHR:/* 16bit unsigned */
#endif
d2893 2
a2894 4
#if 0
  case OP_LDHR:
  case OP_LDUHR:
#endif
d2902 1
a2902 3
#if 0
  case OP_STHR:
#endif
@


1.75
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.74 2020/08/30 12:10:39 nakashim Exp nakashim $";
d550 1
d552 1
@


1.74
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.73 2020/07/15 23:18:48 nakashim Exp nakashim $";
d609 1
d612 1
d1242 1
d1244 1
d1251 1
d1254 1
d2899 1
d2902 1
d2910 1
d2912 1
@


1.73
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.72 2020/07/05 09:40:38 nakashim Exp nakashim $";
d3339 1
@


1.72
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.71 2020/07/03 03:41:58 nakashim Exp nakashim $";
d2367 4
@


1.71
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.70 2020/06/05 04:06:27 nakashim Exp nakashim $";
d360 2
@


1.70
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.69 2020/06/01 03:10:33 nakashim Exp nakashim $";
d3277 31
@


1.69
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.68 2020/05/26 11:33:26 nakashim Exp nakashim $";
d1958 1
a1958 1
	  && lmmi[i][1].rw    == lmmi[i][0].rw
d1981 1
a1981 1
	  && lmmi[i][3].rw    == lmmi[i][2].rw
d2023 1
a2023 1
         && lmmi[i][2].rw    == lmmi[i][0].rw
d2039 1
a2039 1
         && lmmi[i][3].rw    == lmmi[i][0].rw
d2057 1
a2057 1
         && lmmi[i][2].rw    == lmmi[i][0].rw
d2072 1
a2072 1
         && lmmi[i][3].rw    == lmmi[i][0].rw
d2089 1
a2089 1
         && lmmi[i][2].rw    == lmmi[i][1].rw
d2104 1
a2104 1
         && lmmi[i][3].rw    == lmmi[i][1].rw
d2359 1
a2359 1
      /* && lmmi[i][j].rw     == lmmi[k][j].rw*//* lmf and lmx can be merged */
@


1.68
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.67 2020/05/05 13:55:38 nakashim Exp nakashim $";
d905 1
a905 1
	  int f  = dmop1->force;
d923 2
d938 1
a938 1
            if (dmop1->force) { /* reserved for LDDMQ */
d964 2
d995 1
a995 1
	  int f  = (dmop0->mtype==MTYPE_DLOAD||dmop0->mtype==MTYPE_TRANS)?1:dmop0->force;
d1013 2
d1039 2
d1055 1
a1055 1
            if (dmop0->force) { /* reserved for TR */
d1085 2
d1279 2
a1280 1
          int fce = dec[last_row][last_col].dmop1.force;
d1288 2
a1289 1
                                   && (fce == insn[i].imop.force);
d1335 2
a1336 1
          int fce = dec[last_row][last_col].dmop1.force;
d1344 2
a1345 1
                                   && (fce == insn[i].imop.force);
d1389 1
a1389 1
	  int f  = dmop1->force;
d1407 2
d1422 1
a1422 1
            if (dmop1->force) { /* reserved for LDDMQ */
d1448 2
d1473 1
a1473 1
	    int f  = dmop0->force;
d1491 2
d1511 1
a1511 1
              if (dmop0->force) { /* reserved for TR */
d1541 2
d2416 1
a2416 1
	      fprintf(ofile, "\t*(Uint*)&emax6.lmmi[%d][%d][%d][emax6.lmmic] = 0x%08.8x;\n", c, i, j, *(Uint*)&lmmi[i][j]);
d2418 1
a2418 1
	      fprintf(ofile, "\t*(Uint*)&emax6.lmmi[%d][%d][%d][emax6.lmmic] = ((%s-1)<<16)|0x%04.4x;\n", c, i, j, id[lmmx[i][j].lenh].name, *(Ushort*)&lmmi[i][j]);
d2428 1
a2428 1
	    fprintf(ofile, "\t*(Uint*)&emax6.lmmi[0][%d][%d][emax6.lmmic] = 0x%08.8x;\n", i, j, *(Uint*)&lmmi[i][j]);
d2430 1
a2430 1
	    fprintf(ofile, "\t*(Uint*)&emax6.lmmi[0][%d][%d][emax6.lmmic] = ((%s-1)<<16)|0x%04.4x;\n", i, j, id[lmmx[i][j].lenh].name, *(Ushort*)&lmmi[i][j]);
@


1.67
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.66 2019/03/17 23:31:28 nakashim Exp nakashim $";
d2769 1
a2769 1
	fprintf(ofile, "\temax6.lmmd[%d][%d] = ~0>>%d;\n", i, j, sizeof(Uchar)*8-current_nchip); /* set dirty */
@


1.66
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.65 2019/03/17 13:17:46 nakashim Exp nakashim $";
a2488 1
  fprintf(ofile, "\t  ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].adtr = emax_info.ddr_mmap - emax_info.lmm_phys;\n");
@


1.65
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.64 2019/02/23 13:38:29 nakashim Exp nakashim $";
d2567 18
d2839 2
@


1.64
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.63 2019/02/21 00:40:36 nakashim Exp nakashim $";
d2545 22
d2613 26
d2816 6
@


1.63
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.62 2019/02/17 12:45:35 nakashim Exp nakashim $";
d361 4
a383 4
      if (dec[last_row][last_col].dexu.fold) { /* exeがfoldなら同一unit.storeも無条件でfold */
	printf("load-exe-store folding assumed ");
	folding = 1; /* load-exe-store folding */
      }
d622 20
a641 2
          last_row = *rdep;
          last_col = 0;
d659 1
a659 1
	    printf("load-exe-store folding assumed ");
d1280 12
d1293 6
a1298 6
            /* new_load,new_storeは次colへ */
            last_col++; /* overflowはあとで検査.EXEがWIDTH以上あれば次段へ移動 */
            if (last_col >= EMAX_WIDTH) {
              last_row++;
              last_col = 0;
            }
d1334 6
d1445 1
a1445 5
        if (insn[i].imop.mtype == MTYPE_RSTORE) {
	  if (dec[last_row][last_col].dexu.fold) { /* exeがfoldなら同一unit.storeも無条件でfold */
	    printf("load-exe-store folding assumed ");
	    folding = 1; /* load-exe-store folding */
	  }
a1446 1
	}
@


1.62
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.61 2018/12/19 02:00:31 nakashim Exp nakashim $";
d2432 1
a2432 1
    fprintf(ofile, "\t  int    c, i,j;\n");
d2456 1
a2456 1
  fprintf(ofile, "\t  int i;\n");
d2464 6
@


1.61
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.60 2018/12/19 01:59:41 nakashim Exp $";
d348 3
d380 8
a387 4
      set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dcex->bit0v, dcex->bit0h, -1);
      set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dcex->bit1v, dcex->bit1h, -1);
      set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dcex->bit2v, dcex->bit2h, -1);
      set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dcex->bit3v, dcex->bit3h, -1);
d411 1
d563 1
@


1.60
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.59 2018/12/18 22:59:17 nakashim Exp nakashim $";
d9 1
a9 1
/* emax6.c 2012/9/22 */
@


1.59
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.58 2018/12/09 03:31:28 nakashim Exp nakashim $";
d2407 1
a2407 1
	  if (lmmi[i][j].cidx) { /* NCHIP間でlmm_topが異なる場合 */
@


1.58
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.57 2018/12/08 12:05:43 nakashim Exp nakashim $";
d2287 3
a2289 1
  /* Step 6 ... Set additional copy-flag for Vertical Broadcast(slave)                                                  */
d2292 2
a2293 2
    for (i=0; i<EMAX_DEPTH-1; i++) {
      for (k=i+1; k<EMAX_DEPTH; k++) {
d2297 1
a2297 1
         && lmmi[i][j].rw     == lmmi[k][j].rw
d2317 1
d2347 2
d2404 1
a2404 1
	if (lmmi_bitmap[j] & (1LL<<i) && ((!current_mapdist&&lmmi[i][j].rw&&!lmmi[i][j].p)||(current_mapdist&&lmmi[i+current_mapdist][j].rw&&!lmmi[i+current_mapdist][j].p))) {
d2459 13
a2471 5
  fprintf(ofile, "\telse if (%d>0) {/*mapdist*/\n", current_mapdist);
  fprintf(ofile, "\t  emax6.status = STATUS_SCON;\n");
  fprintf(ofile, "\t  ((struct reg_ctrl*)emax6.reg_ctrl)->i[0].cmd = 2LL; // SCON\n");
  fprintf(ofile, "\t  while (((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat & 0x0f); //EXRING_BUSY\n");
  fprintf(ofile, "\t}\n");
d2593 1
a2593 1
	    fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 2, %d, %d, %d, %d);/*load*/\n", mode, current_mapdist, c, i, j); /* phase=2 load */
d2596 1
a2596 1
	  fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 2, %d, 0, %d, %d);/*load*/\n", mode, current_mapdist, i, j); /* phase=2 load */
@


1.57
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.56 2018/12/08 00:37:52 nakashim Exp nakashim $";
d2389 2
d2434 2
d2460 2
d2532 2
d2570 2
d2588 2
d2651 2
@


1.56
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.55 2018/12/07 02:51:33 nakashim Exp nakashim $";
d2359 1
a2359 1
	else{  /* NCHIP間でlmm_topが共通の場合 */
d2400 6
a2405 2
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t  emax6_check_lmmi_and_dma(0, 1, %d, %d, %d, %d);/*drain*/\n", current_mapdist, c, i, j); /* phase=1 drain */
d2620 1
a2620 1
	if (lmmi[i][j].rw) { /* pdrain */
d2622 1
a2622 9
	    fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, %d, %d, %d);/*pdrain*/\n", mode, current_mapdist, c, i, j); /* phase=3 exec */
	}
	else { /* pload */
	  if (lmmi[i][j].cidx) { /* NCHIP間でlmm_topが異なる場合 */
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, %d, %d, %d);/*pload*/\n", mode, current_mapdist, c, i, j); /* phase=3 exec */
	  }
	  else /* NCHIP間でlmm_topが共通の場合 */
	    fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, 0, %d, %d);/*pload*/\n", mode, current_mapdist, i, j); /* phase=3 exec */
d2624 2
@


1.55
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.54 2018/11/30 04:30:18 nakashim Exp nakashim $";
d2346 7
a2352 11
        if (lmmx[i][j].lenv == T_IMMEDIATE) { /* IMMEDIATE */
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t*(Uint*)&emax6.lmmi[%d][%d][%d][emax6.lmmic] = 0x%08.8x;\n", c, i, j, *(Uint*)&lmmi[i][j]);
        }
        else { /* VARIABLE */
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t*(Uint*)&emax6.lmmi[%d][%d][%d][emax6.lmmic] = ((%s-1)<<16)|0x%04.4x;\n", c, i, j, id[lmmx[i][j].lenh].name, *(Ushort*)&lmmi[i][j]);
        }
	if (lmmi[i][j].ofs) { /* ptophが有効の場合,topが[CHIP]ならptopも[CHIP]でなければおかしい */
	  if (lmmi[i][j].cidx) {
	    for (c=0; c<current_nchip; c++)
d2354 3
d2358 7
a2364 1
	  else
d2366 3
a2369 10
	else {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\temax6.lmmi[%d][%d][%d][emax6.lmmic].ofs = 0;\n", c, i, j);
	}
	if (lmmi[i][j].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\temax6.lmmi[%d][%d][%d][emax6.lmmic].top = %s[%d];\n", c, i, j, (char*)lmmi[i][j].top, c);
	}
	else
	  fprintf(ofile, "\temax6.lmmi[0][%d][%d][emax6.lmmic].top = %s;\n", i, j, (char*)lmmi[i][j].top);
d2547 6
a2552 2
	for (c=0; c<current_nchip; c++)
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+*((Ushort*)&emax6.lmmi[%d][%d][%d][lmmic]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[%d][%d][%d][lmmic].top;\n", c, i, j, c, source_i, j, c, source_i, j, c, source_i, j);
d2564 6
a2569 2
	for (c=0; c<current_nchip; c++)
	  fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 2, %d, %d, %d, %d);/*load*/\n", mode, current_mapdist, c, i, j); /* phase=2 load */
d2598 6
a2603 2
	for (c=0; c<current_nchip; c++)
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+emax6.lmmi[%d][%d][%d][lmmic].ofs+*((Ushort*)&emax6.lmmi[%d][%d][%d][lmmic]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)(emax6.lmmi[%d][%d][%d][lmmic].top+emax6.lmmi[%d][%d][%d][lmmic].ofs);\n", c, i, j, c, i, j, c, i, j, c, i, j, c, i, j, c, i, j);
d2616 12
a2627 2
	for (c=0; c<current_nchip; c++)
	  fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, %d, %d, %d);/*pdrain,pload*/\n", mode, current_mapdist, c, i, j); /* phase=3 exec */
@


1.54
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.53 2018/11/30 01:09:23 nakashim Exp nakashim $";
d2348 1
a2348 1
	    fprintf(ofile, "\t*(Uint*)&emax6.lmmi[emax6.lmmic][%d][%d][%d] = 0x%08.8x;\n", c, i, j, *(Uint*)&lmmi[i][j]);
d2352 1
a2352 1
	    fprintf(ofile, "\t*(Uint*)&emax6.lmmi[emax6.lmmic][%d][%d][%d] = ((%s-1)<<16)|0x%04.4x;\n", c, i, j, id[lmmx[i][j].lenh].name, *(Ushort*)&lmmi[i][j]);
d2357 1
a2357 1
	      fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d][%d].ofs = (Uchar*)%s[%d] - (Uchar*)%s[%d];\n", c, i, j, (char*)lmmi[i][j].top + lmmi[i][j].ofs, c, (char*)lmmi[i][j].top, c);
d2360 1
a2360 1
	    fprintf(ofile, "\temax6.lmmi[emax6.lmmic][0][%d][%d].ofs = (Uchar*)%s - (Uchar*)%s;\n", i, j, (char*)lmmi[i][j].top + lmmi[i][j].ofs, (char*)lmmi[i][j].top);
d2364 1
a2364 1
	    fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d][%d].ofs = 0;\n", c, i, j);
d2368 1
a2368 1
	    fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d][%d].top = %s[%d];\n", c, i, j, (char*)lmmi[i][j].top, c);
d2371 1
a2371 1
	  fprintf(ofile, "\temax6.lmmi[emax6.lmmic][0][%d][%d].top = %s;\n", i, j, (char*)lmmi[i][j].top);
d2418 1
a2418 1
    fprintf(ofile, "\t      if (emax6.lmmi_bitmap[j] & (1LL<<i) && emax6.lmmi[lmmic][0][i][j].rw) {\n");
d2420 2
a2421 2
    fprintf(ofile, "\t          if (emax6.lmmi[lmmic][0][i][j].ofs)\n");
    fprintf(ofile, "\t            *(Ull*)&(reg_ctrl->i[c].addr[i][j].top) = ((Ull)(emax6.lmmi[lmmic][c][i][j].top+*((Ushort*)&emax6.lmmi[lmmic][c][i][j]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][c][i][j].top;\n");
d2550 1
a2550 1
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][%d][%d][%d].top+*((Ushort*)&emax6.lmmi[lmmic][%d][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][%d][%d][%d].top;\n", c, i, j, c, source_i, j, c, source_i, j, c, source_i, j);
d2593 1
a2593 1
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][%d][%d][%d].top+emax6.lmmi[lmmic][%d][%d][%d].ofs+*((Ushort*)&emax6.lmmi[lmmic][%d][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)(emax6.lmmi[lmmic][%d][%d][%d].top+emax6.lmmi[lmmic][%d][%d][%d].ofs);\n", c, i, j, c, i, j, c, i, j, c, i, j, c, i, j, c, i, j);
@


1.53
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.52 2018/11/26 10:18:38 nakashim Exp nakashim $";
d2347 2
a2348 6
	  if (lmmi[i][j].cidx) {
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "\t*(Uint*)&emax6.lmmi[emax6.lmmic][%d][%d][%d] = 0x%08.8x;\n", c, i, j, *(Uint*)&lmmi[i][j]);
	  }
	  else
	    fprintf(ofile, "\t*(Uint*)&emax6.lmmi[emax6.lmmic][0][%d][%d] = 0x%08.8x;\n", i, j, *(Uint*)&lmmi[i][j]);
d2351 2
a2352 6
	  if (lmmi[i][j].cidx) {
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "\t*(Uint*)&emax6.lmmi[emax6.lmmic][%d][%d][%d] = ((%s-1)<<16)|0x%04.4x;\n", c, i, j, id[lmmx[i][j].lenh].name, *(Ushort*)&lmmi[i][j]);
	  }
	  else
	    fprintf(ofile, "\t*(Uint*)&emax6.lmmi[emax6.lmmic][0][%d][%d] = ((%s-1)<<16)|0x%04.4x;\n", i, j, id[lmmx[i][j].lenh].name, *(Ushort*)&lmmi[i][j]);
d2363 2
a2364 6
	  if (lmmi[i][j].cidx) {
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d][%d].ofs = 0;\n", c, i, j);
	  }
	  else
	    fprintf(ofile, "\temax6.lmmi[emax6.lmmic][0][%d][%d].ofs = 0;\n", i, j);
d2402 2
a2403 6
	  if (lmmi[i][j].cidx) {
	    for (c=0; c<current_nchip; c++)
	      fprintf(ofile, "\t  emax6_check_lmmi_and_dma(0, 1, %d, %d, %d, %d);/*drain*/\n", current_mapdist, c, i, j); /* phase=1 drain */
	  }
	  else
	    fprintf(ofile, "\t  emax6_check_lmmi_and_dma(0, 1, %d, 0, %d, %d);/*drain*/\n", current_mapdist, i, j); /* phase=1 drain */
d2419 1
a2419 8
    fprintf(ofile, "\t        if (emax6.lmmi[lmmic][0][i][j].cidx) {\n");
    fprintf(ofile, "\t          for (c=0; c<%d; c++) {\n", current_nchip);
    fprintf(ofile, "\t            if (emax6.lmmi[lmmic][0][i][j].ofs)\n");
    fprintf(ofile, "\t              *(Ull*)&(reg_ctrl->i[c].addr[i][j].top) = ((Ull)(emax6.lmmi[lmmic][c][i][j].top+*((Ushort*)&emax6.lmmi[lmmic][c][i][j]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][c][i][j].top;\n");
    fprintf(ofile, "\t            emax6_check_lmmi_and_dma(1, 1, mapdist, c, i, j);/*drain*/\n"); /* phase=1 drain */
    fprintf(ofile, "\t          }\n");
    fprintf(ofile, "\t        }\n");
    fprintf(ofile, "\t        else {\n");
d2421 2
a2422 2
    fprintf(ofile, "\t            *(Ull*)&(reg_ctrl->i[0].addr[i][j].top) = ((Ull)(emax6.lmmi[lmmic][0][i][j].top+*((Ushort*)&emax6.lmmi[lmmic][0][i][j]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][0][i][j].top;\n");
    fprintf(ofile, "\t          emax6_check_lmmi_and_dma(1, 1, mapdist, 0, i, j);/*drain*/\n"); /* phase=1 drain */
d2549 2
a2550 6
	if (lmmi[i][j].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][%d][%d][%d].top+*((Ushort*)&emax6.lmmi[lmmic][%d][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][%d][%d][%d].top;\n", c, i, j, c, source_i, j, c, source_i, j, c, source_i, j);
	}
	else
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][0][%d][%d].top+*((Ushort*)&emax6.lmmi[lmmic][0][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][0][%d][%d].top;\n", i, j, source_i, j, source_i, j, source_i, j);
d2562 2
a2563 6
	if (lmmi[i][j].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 2, %d, %d, %d, %d);/*load*/\n", mode, current_mapdist, c, i, j); /* phase=2 load */
	}
	else
	  fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 2, %d, 0, %d, %d);/*load*/\n", mode, current_mapdist, i, j); /* phase=2 load */
d2592 2
a2593 6
	if (lmmi[i][j].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[%d].addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][%d][%d][%d].top+emax6.lmmi[lmmic][%d][%d][%d].ofs+*((Ushort*)&emax6.lmmi[lmmic][%d][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)(emax6.lmmi[lmmic][%d][%d][%d].top+emax6.lmmi[lmmic][%d][%d][%d].ofs);\n", c, i, j, c, i, j, c, i, j, c, i, j, c, i, j, c, i, j);
	}
	else
	    fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][0][%d][%d].top+emax6.lmmi[lmmic][0][%d][%d].ofs+*((Ushort*)&emax6.lmmi[lmmic][0][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)(emax6.lmmi[lmmic][0][%d][%d].top+emax6.lmmi[lmmic][0][%d][%d].ofs);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2606 2
a2607 6
	if (lmmi[i][j].cidx) {
	  for (c=0; c<current_nchip; c++)
	    fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, %d, %d, %d);/*pdrain,pload*/\n", mode, current_mapdist, c, i, j); /* phase=3 exec */
	}
	else
	  fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, 0, %d, %d);/*pdrain,pload*/\n", mode, current_mapdist, i, j); /* phase=3 exec */
d2614 2
a2615 6
      if (lmmi_bitmap[j] & (1LL<<i) && lmmi[i][j].rw && !lmmi[i][j].p) {/* ●6 lmw/lmx */
	if (lmmi[i][j].cidx)
	  fprintf(ofile, "\temax6.lmmd[%d][%d] = ~0>>%d;\n", i, j, sizeof(Uchar)*8-current_nchip); /* set dirty */
	else
	  fprintf(ofile, "\temax6.lmmd[%d][%d] = 1;\n", i, j); /* set dirty */
      }
@


1.52
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.51 2018/11/25 08:45:13 nakashim Exp nakashim $";
d2347 6
a2352 1
          fprintf(ofile, "\t*(Uint*)&emax6.lmmi[emax6.lmmic][0][%d][%d] = 0x%08.8x;\n", i, j, *(Uint*)&lmmi[i][j]);
d2355 6
a2360 1
          fprintf(ofile, "\t*(Uint*)&emax6.lmmi[emax6.lmmic][0][%d][%d] = ((%s-1)<<16)|0x%04.4x;\n", i, j, id[lmmx[i][j].lenh].name, *(Ushort*)&lmmi[i][j]);
d2370 8
a2377 2
	else
	  fprintf(ofile, "\temax6.lmmi[emax6.lmmic][0][%d][%d].ofs = 0;\n", i, j);
d2653 6
a2658 2
      if (lmmi_bitmap[j] & (1LL<<i) && lmmi[i][j].rw && !lmmi[i][j].p)/* ●6 lmw/lmx */
	fprintf(ofile, "\temax6.lmmd[%d][%d] = 1;\n", i, j); /* set dirty */
@


1.51
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.50 2018/11/25 02:28:37 nakashim Exp nakashim $";
d2451 1
a2451 1
  fprintf(ofile, "\t  //while (((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat & 0xf0); //LMRING_BUSY \n");
@


1.50
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.49 2018/11/15 00:49:07 nakashim Exp nakashim $";
d2819 1
a2819 1
    return;
d2821 1
a2821 1
    return;
d2891 1
a2891 1
            return; /* found & do nothing */
d2907 1
a2907 1
            return; /* generate ARM->BR */
@


1.49
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.48 2018/11/14 01:43:29 nakashim Exp nakashim $";
d2451 1
a2451 1
  fprintf(ofile, "\t  while (((struct reg_ctrl*)emax6.reg_ctrl)->i[0].stat & 0xf0); //LMRING_BUSY \n");
@


1.48
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.47 2018/10/18 12:42:55 nakashim Exp nakashim $";
d2557 1
a2557 1
	  for (c=0; c<EMAX_NCHIP; c++)
d2608 1
a2608 1
	  for (c=0; c<EMAX_NCHIP; c++)
@


1.47
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.46 2018/10/16 13:26:30 nakashim Exp nakashim $";
d17 1
a17 1
  int i, j, k, flag;
d887 11
a897 11
          lmmi[last_row][last_col].v     = 1;
          lmmi[last_row][last_col].rw    = rw;
          lmmi[last_row][last_col].f     = f;
          lmmi[last_row][last_col].p     = p;
          lmmi[last_row][last_col].blk   = dmop1->blk;
          lmmi[last_row][last_col].cidx  = id[dmop1->toph].cidx;
          lmmi[last_row][last_col].len   = id[dmop1->lenh].val-1;
          lmmi[last_row][last_col].ofs   = 0; /* initial value */
          lmmi[last_row][last_col].top   = (Ull)id[dmop1->toph].name;
          lmmx[last_row][last_col].lenv  = dmop1->lenv;
          lmmx[last_row][last_col].lenh  = dmop1->lenh;
d912 2
a913 2
            lmmi[last_row][last_col].p   = 1; /* optional prefetch *//* lmm_axiw/lmm_axirは，lmrとlmpとで同じ扱いなので設定済 */
            lmmi[last_row][last_col].ofs = (Uint)(id[dmop1->ptoph].name - id[dmop1->toph].name);
d926 5
a930 5
            lmmi[last_row+current_mapdist][last_col].v     = 1;
            lmmi[last_row+current_mapdist][last_col].rw    = rw;
            lmmi[last_row+current_mapdist][last_col].f     = f;
            lmmi[last_row+current_mapdist][last_col].p     = p;
            lmmi[last_row+current_mapdist][last_col].blk   = dmop1->blk;
d932 5
a936 5
            lmmi[last_row+current_mapdist][last_col].len   = id[dmop1->plenh].val-1;
            lmmi[last_row+current_mapdist][last_col].ofs   = 0;
            lmmi[last_row+current_mapdist][last_col].top   = (Ull)id[dmop1->ptoph].name;
            lmmx[last_row+current_mapdist][last_col].lenv  = dmop1->plenv;
            lmmx[last_row+current_mapdist][last_col].lenh  = dmop1->plenh;
d973 5
a977 5
          lmmi[last_row][last_col].v     = 1;
          lmmi[last_row][last_col].rw    = rw;
          lmmi[last_row][last_col].f     = f;
          lmmi[last_row][last_col].p     = p;
          lmmi[last_row][last_col].blk   = dmop0->blk;
d979 5
a983 5
          lmmi[last_row][last_col].len   = id[dmop0->lenh].val-1;
          lmmi[last_row][last_col].ofs   = 0; /* initial value */
          lmmi[last_row][last_col].top   = (Ull)id[dmop0->toph].name;
          lmmx[last_row][last_col].lenv  = dmop0->lenv;
          lmmx[last_row][last_col].lenh  = dmop0->lenh;
d997 5
a1001 5
            lmmi[last_row][last_col].v     = 1;
            lmmi[last_row][last_col].rw    = rw;
            lmmi[last_row][last_col].f     = f;
            lmmi[last_row][last_col].p     = p;
            lmmi[last_row][last_col].blk   = 0;
d1003 5
a1007 5
            lmmi[last_row][last_col].len   = 0;
            lmmi[last_row][last_col].ofs   = 0;
            lmmi[last_row][last_col].top   = (Ull)id[dmop0->toph].name;
            lmmx[last_row][last_col].lenv  = dmop0->lenv;
            lmmx[last_row][last_col].lenh  = dmop0->lenh;
d1023 2
a1024 2
            lmmi[last_row][last_col].p   = 1; /* optional postdrain *//* lmm_axiw/lmm_axirは，lmwとlmdとで同じ扱いなので設定済 */
            lmmi[last_row][last_col].ofs = (Uint)(id[dmop0->ptoph].name - id[dmop0->toph].name);
d1027 4
a1030 4
            if (lmmi[last_row-current_mapdist][last_col].v) {
              printf("in %s: [%d][%d] drain may conflict with other lmm\n", id[current_prefix].name, last_row, last_col);
              exit(1);
            }
d1041 5
a1045 5
            lmmi[last_row-current_mapdist][last_col].v     = 1;
            lmmi[last_row-current_mapdist][last_col].rw    = rw;
            lmmi[last_row-current_mapdist][last_col].f     = f;
            lmmi[last_row-current_mapdist][last_col].p     = p;
            lmmi[last_row-current_mapdist][last_col].blk   = dmop0->blk;
d1047 5
a1051 5
            lmmi[last_row-current_mapdist][last_col].len   = id[dmop0->plenh].val-1;
            lmmi[last_row-current_mapdist][last_col].ofs   = 0;
            lmmi[last_row-current_mapdist][last_col].top   = (Ull)id[dmop0->ptoph].name;
            lmmx[last_row-current_mapdist][last_col].lenv  = dmop0->plenv;
            lmmx[last_row-current_mapdist][last_col].lenh  = dmop0->plenh;
d1339 5
a1343 5
          lmmi[last_row][last_col].v     = 1;
          lmmi[last_row][last_col].rw    = rw;
          lmmi[last_row][last_col].f     = f;
          lmmi[last_row][last_col].p     = p;
          lmmi[last_row][last_col].blk   = dmop1->blk;
d1345 5
a1349 5
          lmmi[last_row][last_col].len   = id[dmop1->lenh].val-1;
          lmmi[last_row][last_col].ofs   = 0; /* initial value */
          lmmi[last_row][last_col].top   = (Ull)id[dmop1->toph].name;
          lmmx[last_row][last_col].lenv  = dmop1->lenv;
          lmmx[last_row][last_col].lenh  = dmop1->lenh;
d1364 2
a1365 2
            lmmi[last_row][last_col].p   = 1; /* optional prefetch *//* lmm_axiw/lmm_axirは，lmrとlmpとで同じ扱いなので設定済 */
            lmmi[last_row][last_col].ofs = (Uint)(id[dmop1->ptoph].name - id[dmop1->toph].name);
d1378 5
a1382 5
            lmmi[last_row+current_mapdist][last_col].v     = 1;
            lmmi[last_row+current_mapdist][last_col].rw    = rw;
            lmmi[last_row+current_mapdist][last_col].f     = f;
            lmmi[last_row+current_mapdist][last_col].p     = p;
            lmmi[last_row+current_mapdist][last_col].blk   = dmop1->blk;
d1384 5
a1388 5
            lmmi[last_row+current_mapdist][last_col].len   = id[dmop1->plenh].val-1;
            lmmi[last_row+current_mapdist][last_col].ofs   = 0;
            lmmi[last_row+current_mapdist][last_col].top   = (Ull)id[dmop1->ptoph].name;
            lmmx[last_row+current_mapdist][last_col].lenv  = dmop1->plenv;
            lmmx[last_row+current_mapdist][last_col].lenh  = dmop1->plenh;
d2303 1
d2347 1
a2347 1
          fprintf(ofile, "\t*(Uint*)&emax6.lmmi[emax6.lmmic][%d][%d] = 0x%08.8x;\n", i, j, *(Uint*)&lmmi[i][j]);
d2350 1
a2350 1
          fprintf(ofile, "\t*(Uint*)&emax6.lmmi[emax6.lmmic][%d][%d] = ((%s-1)<<16)|0x%04.4x;\n", i, j, id[lmmx[i][j].lenh].name, *(Ushort*)&lmmi[i][j]);
a2353 1
	    int c;
d2355 1
a2355 1
	      fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d].ofs = (Uchar*)%s[%d] - (Uchar*)%s[%d];\n", i, j, (char*)lmmi[i][j].top + lmmi[i][j].ofs, c, (char*)lmmi[i][j].top, c);
d2358 1
a2358 1
	    fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d].ofs = (Uchar*)%s - (Uchar*)%s;\n", i, j, (char*)lmmi[i][j].top + lmmi[i][j].ofs, (char*)lmmi[i][j].top);
d2361 1
a2361 1
	  fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d].ofs = 0;\n", i, j);
a2362 1
	  int c;
d2364 1
a2364 1
	    fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d].top = %s[%d];\n", i, j, (char*)lmmi[i][j].top, c);
d2367 1
a2367 1
	  fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d].top = %s;\n", i, j, (char*)lmmi[i][j].top);
d2395 10
a2404 3
	if (lmmi_bitmap[j] & (1LL<<i) && ((!current_mapdist&&lmmi[i][j].rw&&!lmmi[i][j].p)||(current_mapdist&&lmmi[i+current_mapdist][j].rw&&!lmmi[i+current_mapdist][j].p))) /* 同一conf使用の最後にemax5_drain_dirty_lmm()する前提なので,新lmmi_bitmapと,更新前RANGEの組合せでもOK */
	                               /* 但し,SCON後はconf.lmm_modeがずれるので,drainの時にtag_matchしない.drainはlmmi更新後&SCON前 */
	  fprintf(ofile, "\t  emax6_check_lmmi_and_dma(0, 1, %d, %d, %d);/*drain*/\n", current_mapdist, i, j); /* phase=1 drain */
d2414 1
a2414 1
    fprintf(ofile, "\t  int    i,j;\n");
d2418 13
a2430 4
    fprintf(ofile, "\t      if (emax6.lmmi_bitmap[j] & (1LL<<i) && emax6.lmmi[lmmic][i][j].rw) {\n");
    fprintf(ofile, "\t        if (emax6.lmmi[lmmic][i][j].ofs)\n");
    fprintf(ofile, "\t          *(Ull*)&(reg_ctrl->i[0].addr[i][j].top) = ((Ull)(emax6.lmmi[lmmic][i][j].top+*((Ushort*)&emax6.lmmi[lmmic][i][j]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][i][j].top;\n");
    fprintf(ofile, "\t        emax6_check_lmmi_and_dma(1, 1, mapdist, i, j);/*drain*/\n"); /* phase=1 drain */
a2467 1
	    int c;
d2469 1
a2469 1
	      fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].breg[%d][%d].br[%d] = %d;\n", i, j, k, c);
a2471 1
	    int c;
d2473 1
a2473 1
	      fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].breg[%d][%d].br[%d] = %s[%d];\n", i, j, k, id[regv[i][j].br[k].h].name, c);
a2489 1
	  int c;
d2491 1
a2491 1
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0b = %s[%d];\n", i, j, id[regv[i][j].ea0b_h].name, c);
a2499 1
	  int c;
d2501 1
a2501 1
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea0o = %s[%d];\n", i, j, id[regv[i][j].ea0o_h].name, c);
a2509 1
	  int c;
d2511 1
a2511 1
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1b = %s[%d];\n", i, j, id[regv[i][j].ea1b_h].name, c);
a2519 1
	  int c;
d2521 1
a2521 1
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->i[0].addr[%d][%d].ea1o = %s[%d];\n", i, j, id[regv[i][j].ea1o_h].name, c);
d2551 1
d2553 1
a2553 1
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][%d][%d].top+*((Ushort*)&emax6.lmmi[lmmic][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][%d][%d].top;\n", i, j, i, j, i, j, i, j);
d2555 7
a2561 1
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][%d][%d].top+*((Ushort*)&emax6.lmmi[lmmic][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][%d][%d].top;\n", i, j, range_link[i][j], j, range_link[i][j], j, range_link[i][j], j);
d2572 8
a2579 2
      if (lmmi_bitmap[j] & (1LL<<i) && ((!lmmi[i][j].rw&&(!lmmi[i][j].p||lmmi[i][j].ofs))||(lmmi[i][j].rw&&lmmi[i][j].f))) /* lmr,lmf,lmx */
	fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 2, %d, %d, %d);/*load*/\n", mode, current_mapdist, i, j); /* phase=2 load */
d2607 6
a2612 1
	fprintf(ofile, "\t*(Ull*)&(reg_ctrl->i[0].addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][%d][%d].top+emax6.lmmi[lmmic][%d][%d].ofs+*((Ushort*)&emax6.lmmi[lmmic][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)(emax6.lmmi[lmmic][%d][%d].top+emax6.lmmi[lmmic][%d][%d].ofs);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2624 8
a2631 2
      if (lmmi_bitmap[j] & (1LL<<i) && lmmi[i][j].p)
	fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, %d, %d);/*pdrain,pload*/\n", mode, current_mapdist, i, j); /* phase=3 exec */
@


1.46
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.45 2018/09/10 23:56:03 nakashim Exp nakashim $";
d892 1
a892 1
          lmmi[last_row][last_col].chip  = id[dmop1->toph].chip;
d931 1
a931 1
	    lmmi[last_row+current_mapdist][last_col].chip  = id[dmop1->ptoph].chip;
d978 1
a978 1
	  lmmi[last_row][last_col].chip  = id[dmop0->toph].chip;
d1002 1
a1002 1
	    lmmi[last_row][last_col].chip  = id[dmop0->toph].chip;
d1046 1
a1046 1
	    lmmi[last_row-current_mapdist][last_col].chip  = id[dmop0->ptoph].chip;
d1344 1
a1344 1
	  lmmi[last_row][last_col].chip  = id[dmop1->toph].chip;
d1383 1
a1383 1
	    lmmi[last_row+current_mapdist][last_col].chip  = id[dmop1->ptoph].chip;
d1429 1
a1429 1
	    lmmi[last_row][last_col].chip  = id[dmop0->toph].chip;
d1477 1
a1477 1
	      lmmi[last_row-current_mapdist][last_col].chip  = id[dmop0->ptoph].chip;
d2351 9
a2359 2
	if (lmmi[i][j].ofs)
	  fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d].ofs = (Uchar*)%s - (Uchar*)%s;\n", i, j, (char*)lmmi[i][j].top + lmmi[i][j].ofs, (char*)lmmi[i][j].top);
d2362 7
a2368 1
        fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d].top = %s;\n", i, j, (char*)lmmi[i][j].top);
d2414 1
a2414 1
    fprintf(ofile, "\t          *(Ull*)&(reg_ctrl->addr[i][j].top) = ((Ull)(emax6.lmmi[lmmic][i][j].top+*((Ushort*)&emax6.lmmi[lmmic][i][j]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][i][j].top;\n");
d2430 1
a2430 1
  fprintf(ofile, "\t  ((struct reg_ctrl*)emax6.reg_ctrl)->adtr = emax_info.ddr_mmap - emax_info.lmm_phys;\n");
d2432 1
a2432 1
  fprintf(ofile, "\t  dst = (Dll*)(((struct reg_ctrl*)emax6.reg_ctrl)->conf);\n");
d2436 1
a2436 1
  fprintf(ofile, "\t  while (((struct reg_ctrl*)emax6.reg_ctrl)->stat & 0xf0); //LMRING_BUSY \n");
d2442 2
a2443 2
  fprintf(ofile, "\t  ((struct reg_ctrl*)emax6.reg_ctrl)->cmd = 2LL; // SCON\n");
  fprintf(ofile, "\t  while (((struct reg_ctrl*)emax6.reg_ctrl)->stat & 0x0f); //EXRING_BUSY\n");
d2452 12
a2463 2
	  if (regv[i][j].br[k].s < 0)
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->breg[%d][%d].br[%d] = %s;\n", i, j, k, id[regv[i][j].br[k].h].name);
d2465 2
a2466 1
	    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->breg[%d][%d].br[%d] = %s[%d];\n", i, j, k, id[regv[i][j].br[k].h].name, regv[i][j].br[k].s);
d2476 7
a2482 2
	if (regv[i][j].ea0b_s < 0)
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].ea0b = %s;\n", i, j, id[regv[i][j].ea0b_h].name);
d2484 1
a2484 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].ea0b = %s[%d];\n", i, j, id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
d2487 7
a2493 2
	if (regv[i][j].ea0o_s < 0)
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].ea0o = %s;\n", i, j, id[regv[i][j].ea0o_h].name);
d2495 1
a2495 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].ea0o = %s[%d];\n", i, j, id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
d2498 7
a2504 2
	if (regv[i][j].ea1b_s < 0)
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].ea1b = %s;\n", i, j, id[regv[i][j].ea1b_h].name);
d2506 1
a2506 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].ea1b = %s[%d];\n", i, j, id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
d2509 7
a2515 2
	if (regv[i][j].ea1o_s < 0)
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].ea1o = %s;\n", i, j, id[regv[i][j].ea1o_h].name);
d2517 1
a2517 1
	  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].ea1o = %s[%d];\n", i, j, id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
d2543 1
a2543 1
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][%d][%d].top+*((Ushort*)&emax6.lmmi[lmmic][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][%d][%d].top;\n", i, j, i, j, i, j, i, j);
d2545 1
a2545 1
	  fprintf(ofile, "\t*(Ull*)&(reg_ctrl->addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][%d][%d].top+*((Ushort*)&emax6.lmmi[lmmic][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][%d][%d].top;\n", i, j, range_link[i][j], j, range_link[i][j], j, range_link[i][j], j);
d2562 1
a2562 1
  fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->cmd = 3LL; // EXEC\n");
d2585 1
a2585 1
	fprintf(ofile, "\t*(Ull*)&(reg_ctrl->addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][%d][%d].top+emax6.lmmi[lmmic][%d][%d].ofs+*((Ushort*)&emax6.lmmi[lmmic][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)(emax6.lmmi[lmmic][%d][%d].top+emax6.lmmi[lmmic][%d][%d].ofs);\n", i, j, i, j, i, j, i, j, i, j, i, j);
d2609 1
a2609 1
  fprintf(ofile, "\twhile (((struct reg_ctrl*)emax6.reg_ctrl)->stat); //LMRING_BUSY|EXRING_BUSY\n");
@


1.45
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.44 2018/09/10 11:45:48 nakashim Exp nakashim $";
d892 1
d931 1
d978 1
d1002 1
d1046 1
d1344 1
d1383 1
d1429 1
d1477 1
@


1.44
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.43 2018/09/10 08:48:53 nakashim Exp nakashim $";
d3158 2
d3473 2
d3508 1
a3508 1
  snprintf(opcd, EXLABELMAX, "%02.2x-%01.1x-%01.1x", op1, op2, op3);
@


1.43
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.42 2018/09/10 04:29:31 nakashim Exp nakashim $";
d1585 1
@


1.42
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.41 2018/09/09 10:26:36 nakashim Exp nakashim $";
d1613 1
a1613 1
        ea1rs = search_prev_br0(i, dec[i][j].dexu.fold, dec[i][j].dmop1.basev, dec[i][j].dmop1.baseh, dec[i][j].dmop1.bases);
d1619 1
a1619 1
          printf("in %s: [%d][%d] dmop1.base(%s) and dmop0.base(%s) conflict\n", id[current_prefix].name, i, j, id[dec[i][j].dmop1.baseh].name, id[dec[i][j].dmop0.baseh].name);
d1633 1
a1633 1
        ea1rs = search_prev_br0(i, dec[i][j].dexu.fold, dec[i][j].dmop1.offsv, dec[i][j].dmop1.offsh, dec[i][j].dmop1.offss);
d1637 1
a1637 1
          printf("in %s: [%d][%d] dmop1.offs(%s) and dmop0.offs(%s) conflict\n", id[current_prefix].name, i, j, id[dec[i][j].dmop1.offsh].name, id[dec[i][j].dmop0.offsh].name);
d1667 1
a1667 1
          k = search_prev_br0(i, dec[i][j].dexu.fold, bus[i][j].tr[0].v, bus[i][j].tr[0].h, bus[i][j].tr[0].s);
d1698 1
a1698 1
          k = search_prev_br0(i, dec[i][j].dexu.fold, bus[i][j].tr[1].v, bus[i][j].tr[1].h, bus[i][j].tr[1].s);
d1720 1
a1720 1
          k = search_prev_br0(i, dec[i][j].dexu.fold, bus[i][j].tr[2].v, bus[i][j].tr[2].h, bus[i][j].tr[2].s);
d1742 1
a1742 1
          k = search_prev_br0(i, dec[i][j].dexu.fold, bus[i][j].tr[3].v, bus[i][j].tr[3].h, bus[i][j].tr[3].s);
@


1.41
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.40 2018/09/09 04:26:53 nakashim Exp nakashim $";
d1394 1
a1394 1
	  if (dec[last_row][last_col].dexu.fold && dec[last_row][last_col].dexu.exdh == dmop0->mopdh) {
d1400 2
a1401 2
        set_reg_path(last_row, last_col, 0, type, RTYPE_BASE, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
        set_reg_path(last_row, last_col, 0, type, RTYPE_OFFS, 0, dmop0->offsv, dmop0->offsh, dmop0->offss);
d1563 1
a1563 1
      conf[i][j].cdw0.ex1brs = search_prev_br0(i, dec[i][j].dexu.ex1v, dec[i][j].dexu.ex1h, dec[i][j].dexu.ex1s);
d1566 1
a1566 1
      conf[i][j].cdw0.ex2brs = search_prev_br0(i, dec[i][j].dexu.ex2v, dec[i][j].dexu.ex2h, dec[i][j].dexu.ex2s);
d1568 1
a1568 1
      conf[i][j].cdw0.ex3brs = search_prev_br0(i, dec[i][j].dexu.ex3v, dec[i][j].dexu.ex3h, dec[i][j].dexu.ex3s);
d1585 1
d1589 4
a1592 4
      conf[i][j].cdw1.cs0    = search_prev_br0(i, dec[i][j].dcex.bit0v, dec[i][j].dcex.bit0h, -1);
      conf[i][j].cdw1.cs1    = search_prev_br0(i, dec[i][j].dcex.bit1v, dec[i][j].dcex.bit1h, -1);
      conf[i][j].cdw1.cs2    = search_prev_br0(i, dec[i][j].dcex.bit2v, dec[i][j].dcex.bit2h, -1);
      conf[i][j].cdw1.cs3    = search_prev_br0(i, dec[i][j].dcex.bit3v, dec[i][j].dcex.bit3h, -1);
d1609 1
a1609 1
        ea0rs = search_prev_br0(i, dec[i][j].dmop0.basev, dec[i][j].dmop0.baseh, dec[i][j].dmop0.bases);
d1613 1
a1613 1
        ea1rs = search_prev_br0(i, dec[i][j].dmop1.basev, dec[i][j].dmop1.baseh, dec[i][j].dmop1.bases);
d1631 1
a1631 1
        ea0rs = search_prev_br0(i, dec[i][j].dmop0.offsv, dec[i][j].dmop0.offsh, dec[i][j].dmop0.offss);
d1633 1
a1633 1
        ea1rs = search_prev_br0(i, dec[i][j].dmop1.offsv, dec[i][j].dmop1.offsh, dec[i][j].dmop1.offss);
d1667 1
a1667 1
          k = search_prev_br0(i, bus[i][j].tr[0].v, bus[i][j].tr[0].h, bus[i][j].tr[0].s);
d1680 1
a1680 1
          k = search_prev_br0(i, bus[i][j].mw[0].v, bus[i][j].mw[0].h, bus[i][j].mw[0].s);
d1698 1
a1698 1
          k = search_prev_br0(i, bus[i][j].tr[1].v, bus[i][j].tr[1].h, bus[i][j].tr[1].s);
d1708 1
a1708 1
          k = search_prev_br0(i, bus[i][j].mw[1].v, bus[i][j].mw[1].h, bus[i][j].mw[1].s);
d1720 1
a1720 1
          k = search_prev_br0(i, bus[i][j].tr[2].v, bus[i][j].tr[2].h, bus[i][j].tr[2].s);
d1730 1
a1730 1
          k = search_prev_br0(i, bus[i][j].mw[2].v, bus[i][j].mw[2].h, bus[i][j].mw[2].s);
d1742 1
a1742 1
          k = search_prev_br0(i, bus[i][j].tr[3].v, bus[i][j].tr[3].h, bus[i][j].tr[3].s);
d1752 1
a1752 1
          k = search_prev_br0(i, bus[i][j].mw[3].v, bus[i][j].mw[3].h, bus[i][j].mw[3].s);
d3036 1
a3036 1
search_prev_br0(int row, int src_type, int src_hash, int src_sidx)
d3042 2
a3043 1
  row = (row+EMAX_DEPTH-1)%EMAX_DEPTH;
d3051 1
a3051 1
    printf("in %s: [%d][] cannot find source bus[%d][].br[] for %s sidx=%d (malfunction)\n", id[current_prefix].name, (row+1)%EMAX_DEPTH, row, id[src_hash].name, src_sidx);
@


1.40
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.39 2018/09/09 02:27:06 nakashim Exp nakashim $";
a629 1
	    printf("load-exe-store folding assumed ");
d632 1
d674 1
a674 1
      dexu->fold   = folding; /* load-exe-store folding assumed */
d738 3
a740 3
      set_reg_path(last_row, last_col, dexu->fold, type, RTYPE_DATA, 0, dexu->ex1v, dexu->ex1h, dexu->ex1s); /* discrete */
      set_reg_path(last_row, last_col, dexu->fold, type, RTYPE_DATA, 0, dexu->ex2v, dexu->ex2h, dexu->ex2s); /* discrete */
      set_reg_path(last_row, last_col, dexu->fold, type, RTYPE_DATA, 0, dexu->ex3v, dexu->ex3h, dexu->ex3s); /* discrete */
d1215 3
d1393 7
a1399 2
        if (insn[i].imop.mtype == MTYPE_RSTORE)
          set_reg_path(last_row, last_col, 0, type, RTYPE_DATA, 0, dmop0->mopdv, dmop0->mopdh, dmop0->mopds);
@


1.39
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.38 2018/09/08 16:32:07 nakashim Exp nakashim $";
d21 1
d607 3
d628 1
a628 1
        if (row < *rdep) { /* 指定rowには配置困難 */
d633 1
d635 1
a635 1
	  else {
d674 1
a674 1
      dexu->fold   = (row == *rdep-1 && insn[i].iexe.src1h != insn[i].iexe.exedh); /* load-exe-store folding assumed */
@


1.38
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.37 2018/09/07 02:03:55 nakashim Exp nakashim $";
d625 1
a625 1
	  if (row == *rdep-1) { /* load-exe-store foldingの場合,例えばrow=7,src=6,7 fold=1にセットしてトライ */
d669 1
a669 1
      dexu->fold   = (row == *rdep-1); /* load-exe-store folding assumed */
@


1.37
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.36 2018/09/05 22:59:50 nakashim Exp nakashim $";
d235 2
a236 2
      set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dexu->ex1v, dexu->ex1h, dexu->ex1s);
      set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dexu->ex2v, dexu->ex2h, dexu->ex2s);
d319 2
a320 2
      set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dexu->ex1v, dexu->ex1h, dexu->ex1s);
      set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dexu->ex2v, dexu->ex2h, dexu->ex2s);
d376 4
a379 4
      set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dcex->bit0v, dcex->bit0h, -1);
      set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dcex->bit1v, dcex->bit1h, -1);
      set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dcex->bit2v, dcex->bit2h, -1);
      set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dcex->bit3v, dcex->bit3h, -1);
d488 3
a490 3
        set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dexu->ex1v, dexu->ex1h, dexu->ex1s); /* ex1s=3,2,1,0 */
        set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dexu->ex2v, dexu->ex2h, dexu->ex2s); /* ex2s=3,2,1,0 */
        set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dexu->ex3v, dexu->ex3h, dexu->ex3s); /* ex3s=3,2,1,0 */
d627 2
d733 3
a735 3
      set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dexu->ex1v, dexu->ex1h, dexu->ex1s); /* discrete */
      set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dexu->ex2v, dexu->ex2h, dexu->ex2s); /* discrete */
      set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dexu->ex3v, dexu->ex3h, dexu->ex3s); /* discrete */
d869 2
a870 2
        set_reg_path(last_row, last_col, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
        set_reg_path(last_row, last_col, type, RTYPE_OFFS, 1, dmop1->offsv, dmop1->offsh, dmop1->offss);
a871 9
#if 0
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].v     = %d;\n",  id[current_prefix].name, last_row, last_col, 1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].rw    = %d;\n",  id[current_prefix].name, last_row, last_col,(dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].f     = %d;\n",  id[current_prefix].name, last_row, last_col, dmop1->force);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].p     = %d;\n",  id[current_prefix].name, last_row, last_col, 0);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].blk   = %d;\n",  id[current_prefix].name, last_row, last_col, dmop1->blk);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].len   = %d;\n",  id[current_prefix].name, last_row, last_col, dmop1->len);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].top   = %s;\n",  id[current_prefix].name, last_row, last_col, id[dmop1->toph].name);
#endif
a901 9
#if 0
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].v     = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, 1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].rw    = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col,(dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].f     = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, 0);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].p     = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, 1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].blk   = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, dmop1->blk);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].len   = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, dmop1->plen);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].top   = %s;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, id[dmop1->ptoph].name);
#endif
d942 2
a943 2
          set_reg_path(last_row, last_col, type, RTYPE_BASE, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
          set_reg_path(last_row, last_col, type, RTYPE_OFFS, 0, dmop0->offsv, dmop0->offsh, dmop0->offss);
d945 1
a945 1
            set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dmop0->mopdv, dmop0->mopdh, j);
d948 2
a949 2
          set_reg_path(last_row, last_col, 4 /*EXE*/, RTYPE_DATA, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
          set_reg_path(last_row, last_col, 4 /*EXE*/, RTYPE_DATA, 0, dmop0->offsv, dmop0->offsh, dmop0->offss);
d953 1
a953 1
            set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dmop0->mopdv, dmop0->mopdh, j);
a955 9
#if 0
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].v     = %d;\n",  id[current_prefix].name, last_row, last_col, 1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].rw    = %d;\n",  id[current_prefix].name, last_row, last_col,(dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].f     = %d;\n",  id[current_prefix].name, last_row, last_col, dmop0->force);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].p     = %d;\n",  id[current_prefix].name, last_row, last_col, 0);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].blk   = %d;\n",  id[current_prefix].name, last_row, last_col, dmop0->blk);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].len   = %d;\n",  id[current_prefix].name, last_row, last_col, dmop0->len);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].top   = %s;\n",  id[current_prefix].name, last_row, last_col, id[dmop0->toph].name);
#endif
a1009 9
#if 0
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].v     = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, 1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].rw    = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col,(dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].f     = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, 0);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].p     = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, 1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].blk   = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, dmop0->blk);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].len   = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, dmop0->plen);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].top   = %s;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, id[dmop0->ptoph].name);
#endif
a1064 7
#if 0
          bus[last_row+current_mapdist][last_col].ea0brv = T_IMMEDIATE; /* prefetch offset=32 通常lmmiとの競合検査のため場所予約 */
          bus[last_row+current_mapdist][last_col].ea0brh = -1;
          bus[last_row+current_mapdist][last_col].ea0orv = T_IMMEDIATE; /* prefetch offset=32 通常lmmiとの競合検査のため場所予約 */
          bus[last_row+current_mapdist][last_col].ea0orh = -1;
          fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0or = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, 32);
#endif
a1092 6
#if 0
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0br = %dLL; /* prev_ea0br->ex1 */\n", id[current_prefix].name, last_row, last_col, 0);
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0or = %dLL; /* prev_ea0or->ex2 */\n", id[current_prefix].name, last_row, last_col, 32);
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1br = %dLL; /* prev_ea0br->ex1 */\n", id[current_prefix].name, last_row, last_col, 0);
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1or = %dLL; /* prev_ea0or->ex2 */\n", id[current_prefix].name, last_row, last_col, 32);
#endif
a1142 6
#if 0
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0br = %dLL;\n", id[current_prefix].name, last_row, last_col, 0);
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0or = %dLL;\n", id[current_prefix].name, last_row, last_col, 32);
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1br = %dLL;\n", id[current_prefix].name, last_row, last_col, 0);
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1or = %dLL;\n", id[current_prefix].name, last_row, last_col, 32);
#endif
a1172 7
#if 0
          bus[last_row-current_mapdist][last_col].ea1brv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査 */
          bus[last_row-current_mapdist][last_col].ea1brh = -1;
          bus[last_row-current_mapdist][last_col].ea1orv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査 */
          bus[last_row-current_mapdist][last_col].ea1orh = -1;
          fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1or = %d;\n", id[current_prefix].name, last_row-current_mapdist, last_col, 32);
#endif
d1313 2
a1314 2
        set_reg_path(last_row, last_col, type, RTYPE_BASE, 1, dmop1->basev, dmop1->baseh, dmop1->bases);
        set_reg_path(last_row, last_col, type, RTYPE_OFFS, 1, dmop1->offsv, dmop1->offsh, dmop1->offss);
a1315 9
#if 0
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].v     = %d;\n",  id[current_prefix].name, last_row, last_col, 1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].rw    = %d;\n",  id[current_prefix].name, last_row, last_col,(dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].f     = %d;\n",  id[current_prefix].name, last_row, last_col, dmop1->force);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].p     = %d;\n",  id[current_prefix].name, last_row, last_col, 0);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].blk   = %d;\n",  id[current_prefix].name, last_row, last_col, dmop1->blk);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].len   = %d;\n",  id[current_prefix].name, last_row, last_col, dmop1->len);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].top   = %s;\n",  id[current_prefix].name, last_row, last_col, id[dmop1->toph].name);
#endif
a1345 9
#if 0
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].v     = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, 1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].rw    = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col,(dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].f     = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, 0);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].p     = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, 1);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].blk   = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, dmop1->blk);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].len   = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, dmop1->plen);
          fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].top   = %s;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, id[dmop1->ptoph].name);
#endif
d1386 3
a1388 3
          set_reg_path(last_row, last_col, type, RTYPE_DATA, 0, dmop0->mopdv, dmop0->mopdh, dmop0->mopds);
        set_reg_path(last_row, last_col, type, RTYPE_BASE, 0, dmop0->basev, dmop0->baseh, dmop0->bases);
        set_reg_path(last_row, last_col, type, RTYPE_OFFS, 0, dmop0->offsv, dmop0->offsh, dmop0->offss);
a1393 9
#if 0
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].v     = %d;\n",  id[current_prefix].name, last_row, last_col, 1);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].rw    = %d;\n",  id[current_prefix].name, last_row, last_col,(dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].f     = %d;\n",  id[current_prefix].name, last_row, last_col, dmop0->force);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].p     = %d;\n",  id[current_prefix].name, last_row, last_col, 0);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].blk   = %d;\n",  id[current_prefix].name, last_row, last_col, dmop0->blk);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].len   = %d;\n",  id[current_prefix].name, last_row, last_col, dmop0->len);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].top   = %s;\n",  id[current_prefix].name, last_row, last_col, id[dmop0->toph].name);
#endif
a1428 9
#if 0
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].v     = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, 1);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].rw    = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col,(dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].f     = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, 0);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].p     = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, 1);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].blk   = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, dmop0->blk);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].len   = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, dmop0->plen);
            fprintf(ofile, "\temax6_lmmi_%s->lmmi[%d][%d].top   = %s;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, id[dmop0->ptoph].name);
#endif
a1485 7
#if 0
            bus[last_row+current_mapdist][last_col].ea0brv = T_IMMEDIATE; /* prefetch offset=32 通常lmmiとの競合検査のため場所予約 */
            bus[last_row+current_mapdist][last_col].ea0brh = -1;
            bus[last_row+current_mapdist][last_col].ea0orv = T_IMMEDIATE; /* prefetch offset=32 通常lmmiとの競合検査のため場所予約 */
            bus[last_row+current_mapdist][last_col].ea0orh = -1;
            fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0or = %d;\n",  id[current_prefix].name, last_row+current_mapdist, last_col, 32);
#endif
a1517 7
#if 0
          bus[last_row-current_mapdist][last_col].ea1brv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査 */
          bus[last_row-current_mapdist][last_col].ea1brh = -1;
          bus[last_row-current_mapdist][last_col].ea1orv = T_IMMEDIATE; /* drain offset=32 通常lmmiとの競合検査 */
          bus[last_row-current_mapdist][last_col].ea1orh = -1;
          fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1or = %d;\n",  id[current_prefix].name, last_row-current_mapdist, last_col, 32);
#endif
a1791 6
#if 0
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0br = %dLL; /* LMM_buffering */\n", id[current_prefix].name, i, j, 0);
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0or = %dLL; /* LMM_buffering */\n", id[current_prefix].name, i, j, 32);
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1br = %dLL; /* LMM_buffering */\n", id[current_prefix].name, i, j, 0);
        fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1or = %dLL; /* LMM_buffering */\n", id[current_prefix].name, i, j, 32);
#endif
a2285 6
#if 0
  fprintf(ofile, "int emax6_lmmi_%s_i, emax6_lmmi_%s_j;\n", id[current_prefix].name, id[current_prefix].name);
  fprintf(ofile, "for (emax6_lmmi_%s_i=0;emax6_lmmi_%s_i<%d;emax6_lmmi_%s_i++) {\n", id[current_prefix].name, id[current_prefix].name, EMAX_WIDTH, id[current_prefix].name);
  fprintf(ofile, "for (emax6_lmmi_%s_j=0;emax6_lmmi_%s_j<%d;emax6_lmmi_%s_j++) {\n", id[current_prefix].name, id[current_prefix].name, EMAX_DEPTH, id[current_prefix].name);
  fprintf(ofile, "emax6_lmmi_%s[emax6_lmmi_%s_i][emax6_lmmi_%s_j].v = 0; }}\n", id[current_prefix].name, id[current_prefix].name, id[current_prefix].name);
#endif
a2473 4
#if 0
	fprintf(ofile, "\treg_ctrl->addr[%d][%d].top = emax6.lmmi[lmmic][%d][%d].top;\n", i, j, i, j);
	fprintf(ofile, "\treg_ctrl->addr[%d][%d].bot = emax6.lmmi[lmmic][%d][%d].top+*((Ushort*)&emax6.lmmi[lmmic][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1);\n", i, j, i, j, i, j);
#endif
a2516 4
#if 0
	fprintf(ofile, "\treg_ctrl->addr[%d][%d].top = emax6.lmmi[lmmic][%d][%d].top+emax6.lmmi[lmmic][%d][%d].ofs;\n", i, j, i, j, i, j);
	fprintf(ofile, "\treg_ctrl->addr[%d][%d].bot = emax6.lmmi[lmmic][%d][%d].top+emax6.lmmi[lmmic][%d][%d].ofs+*((Ushort*)&emax6.lmmi[lmmic][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1);\n", i, j, i, j, i, j, i, j);
#endif
d2684 1
a2684 1
      else { /* 後続命令タイプ ITYPE_WHILE || ITYPE_CEX || ITYPE_EX4 || ITYPE_EXE */
d2704 1
a2704 1
set_reg_path(int last_row, int last_col, int insn_type, int reg_type, int reg_loc, int src_type, int src_hash, int src_sidx)
d2737 3
a2739 16
          if (src_sidx < 0) {
#if 0
            fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0br = %s;\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
#endif
            regv[last_row][last_col].ea0b_v = src_type;
            regv[last_row][last_col].ea0b_h = src_hash;
            regv[last_row][last_col].ea0b_s = src_sidx;
          }
          else {
#if 0
            fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0br = %s[%d];\n", id[current_prefix].name, last_row, last_col, id[src_hash].name, src_sidx);
#endif
            regv[last_row][last_col].ea0b_v = src_type;
            regv[last_row][last_col].ea0b_h = src_hash;
            regv[last_row][last_col].ea0b_s = src_sidx;
          }
d2750 3
a2752 16
          if (src_sidx < 0) {
#if 0
            fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1br = %s;\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
#endif
            regv[last_row][last_col].ea1b_v = src_type;
            regv[last_row][last_col].ea1b_h = src_hash;
            regv[last_row][last_col].ea1b_s = src_sidx;
          }
          else {
#if 0
            fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1br = %s[%d];\n", id[current_prefix].name, last_row, last_col, id[src_hash].name, src_sidx);
#endif
            regv[last_row][last_col].ea1b_v = src_type;
            regv[last_row][last_col].ea1b_h = src_hash;
            regv[last_row][last_col].ea1b_s = src_sidx;
          }
d2763 3
a2765 16
          if (src_sidx < 0) {
#if 0
            fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0or = %s;\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
#endif
            regv[last_row][last_col].ea0o_v = src_type;
            regv[last_row][last_col].ea0o_h = src_hash;
            regv[last_row][last_col].ea0o_s = src_sidx;
          }
          else {
#if 0
            fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea0or = %s[%d];\n", id[current_prefix].name, last_row, last_col, id[src_hash].name, src_sidx);
#endif
            regv[last_row][last_col].ea0o_v = src_type;
            regv[last_row][last_col].ea0o_h = src_hash;
            regv[last_row][last_col].ea0o_s = src_sidx;
          }
d2774 3
a2776 16
          if (src_sidx < 0) {
#if 0
            fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1or = %s;\n", id[current_prefix].name, last_row, last_col, id[src_hash].name);
#endif
            regv[last_row][last_col].ea1o_v = src_type;
            regv[last_row][last_col].ea1o_h = src_hash;
            regv[last_row][last_col].ea1o_s = src_sidx;
          }
          else {
#if 0
            fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].ea1or = %s[%d];\n", id[current_prefix].name, last_row, last_col, id[src_hash].name, src_sidx);
#endif
            regv[last_row][last_col].ea1o_v = src_type;
            regv[last_row][last_col].ea1o_h = src_hash;
            regv[last_row][last_col].ea1o_s = src_sidx;
          }
d2781 5
a2785 2
    else { /* (insn_type == ITYPE_WHILE || insn_type == ITYPE_CEX || insn_type == ITYPE_EX4 || insn_type == ITYPE_EXE) */
      h = (last_row+EMAX_DEPTH-1)%EMAX_DEPTH; /* 直前段出力BR[][][0-3]の空きを探し,ARMが直接セット */
d2803 3
a2805 16
            if (src_sidx < 0) {
#if 0
              fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].br[%d] = %s;\n", id[current_prefix].name, h, j, k, id[src_hash].name);
#endif
              regv[h][j].br[k].v = src_type;
              regv[h][j].br[k].h = src_hash;
              regv[h][j].br[k].s = src_sidx;
            }
            else {
#if 0
              fprintf(ofile, "\temax6_regv_%s->regv[%d][%d].br[%d] = %s[%d];\n", id[current_prefix].name, h, j, k, id[src_hash].name, src_sidx);
#endif
              regv[h][j].br[k].v = src_type;
              regv[h][j].br[k].h = src_hash;
              regv[h][j].br[k].s = src_sidx;
            }
d2882 1
a2882 1
    for (h=id[src_hash].row+1; h<last_row; h++) { /* 途中まで,伝搬レジスタtr[][]とbr[][]を使用 */
d2924 1
a2924 1
      else { /* (insn_type == ITYPE_WHILE || insn_type == ITYPE_CEX || insn_type == ITYPE_EXE || insn_type == ITYPE_MOP) *//* single use */
@


1.36
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.35 2018/09/04 02:01:47 nakashim Exp nakashim $";
d211 1
d295 1
d461 1
d508 1
a508 1
      /* ★read-modify-writeの場合             */
d625 7
a631 2
          printf("in %s: exe cannot locate destination ALRNO/BDRNO (row=%d)\n", id[current_prefix].name, row);
          exit(1);
d667 1
d828 1
@


1.35
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.34 2018/02/21 04:19:35 nakashim Exp nakashim $";
d210 1
d502 18
a519 4
      /**************************************************/
      /* 1-1                                            */
      /* EXE has imm, var, var[], gpr, bdr[][][] as src */
      /**************************************************/
@


1.34
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.33 2018/02/21 03:17:05 nakashim Exp nakashim $";
d173 1
a173 1
        printf("in %s: while found illegal op=%d\n", id[current_prefix].name, insn[i].iexe.op1);
d183 1
a183 1
          printf("in %s: [%d][%d] while found\n", id[current_prefix].name, row, col);
d191 1
a191 1
          printf("in %s: while found violation of sequence (last_row=%d >= row=%d)\n", id[current_prefix].name, last_row, row);
d197 1
a197 1
        printf("in %s: [%d][%d] while exceeds EMAX_DEPTH/EMAX_WIDTH\n", id[current_prefix].name, last_row, last_col);
d201 1
a201 1
        printf("in %s: [%d][%d] while conflicts\n", id[current_prefix].name, last_row, last_col);
d244 83
d457 1
d643 1
d803 1
d1618 2
d2774 1
d2812 1
a2812 1
     /* insn_type: 命令種別     ITYPE_WHILE, ITYPE_CEX, ITYPE_EX4, ITYPE_EXE, ITYPE_MO4, ITYPE_MOP */
d2815 1
a2815 1
     /* src_type:  T_NONE, T_IMMEDIATE, T_EXRNO, T_ALRNO, T_BDRNO, T_VARIABLE */
d3148 1
d3492 1
a3492 1
  case 5: /* T_VARIABLE */
d3530 1
a3530 1
  case 5: /* T_VARIABLE */
d3571 1
a3571 1
    case 5: /* T_VARIABLE */
d3605 1
a3605 1
    case 5: /* T_VARIABLE */
d4299 1
a4299 1
  case 5: /* T_VARIABLE */
d4375 1
a4375 1
  case 5: /* T_VARIABLE */
d4435 1
a4435 1
  case 5: /* T_VARIABLE */
d4490 1
a4490 1
  case 5: /* T_VARIABLE */
@


1.33
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.32 2018/02/20 03:46:55 nakashim Exp nakashim $";
d2368 1
a2368 1
	if (lmmi_bitmap[j] & (1LL<<i) && ((!current_mapdist&&lmmi[i][j].rw)||(current_mapdist && lmmi[i+current_mapdist][j].rw && !lmmi[i+current_mapdist][j].p))) /* 同一conf使用の最後にemax5_drain_dirty_lmm()する前提なので,新lmmi_bitmapと,更新前RANGEの組合せでもOK */
@


1.32
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.31 2018/02/20 01:12:36 nakashim Exp nakashim $";
d1884 1
a1884 1
      lmmi[i][1].copy = 1;          /* mark as copy */
d1907 1
a1907 1
      lmmi[i][3].copy = 1;          /* mark as copy */
d1951 1
a1951 1
	  lmmi[i][2].copy = 1;          /* mark as copy */
d1967 1
a1967 1
	  lmmi[i][3].copy = 1;          /* mark as copy */
d1984 1
a1984 1
	  lmmi[i][2].copy = 1;          /* mark as copy */
d1999 1
a1999 1
	  lmmi[i][3].copy = 1;          /* mark as copy */
d2016 1
a2016 1
	  lmmi[i][2].copy = 1;          /* mark as copy */
d2031 1
a2031 1
	  lmmi[i][3].copy = 1;          /* mark as copy */
d2271 11
a2281 9
	if (lmmi[i][j].v          && lmmi[k][j].v
         && lmmi[i][j].copy  == 0 && lmmi[k][j].copy  == 0
         && lmmi[i][j].rw    == lmmi[k][j].rw
         && lmmi[i][j].f     == lmmi[k][j].f
         && lmmi[i][j].p     == lmmi[k][j].p
         && lmmi[i][j].blk   == lmmi[k][j].blk
         && lmmi[i][j].len   == lmmi[k][j].len
	 && lmmi[i][j].top   == lmmi[k][j].top) {
	  lmmi[k][j].copy = 1; /* mark as copy */
d2303 21
d2326 1
a2326 1
      if (lmmi[i][j].v & ~lmmi[i][j].copy) {
d2342 1
a2342 1
      if (lmmi[i][j].v) {
d2368 1
a2368 1
	if (lmmi_bitmap[j] & (1LL<<i) && (lmmi[i][j].rw||(current_mapdist && lmmi[i+current_mapdist][j].rw && !lmmi[i+current_mapdist][j].p))) /* 同一conf使用の最後にemax5_drain_dirty_lmm()する前提なので,新lmmi_bitmapと,更新前RANGEの組合せでもOK */
d2370 1
a2370 1
	  fprintf(ofile, "\t  emax6_check_lmmi_and_dma(%d, 1, %d, %d, %d);/*drain*/\n", mode, current_mapdist, i, j); /* phase=1 drain */
d2487 4
a2490 1
	fprintf(ofile, "\t*(Ull*)&(reg_ctrl->addr[%d][%d].top) = ((Ull)(emax6.lmmi[lmmic][%d][%d].top+*((Ushort*)&emax6.lmmi[lmmic][%d][%d]+1)*sizeof(Ull)+(sizeof(Ull)-1))<<32) | (Ull)emax6.lmmi[lmmic][%d][%d].top;\n", i, j, i, j, i, j, i, j);
d2501 1
a2501 1
      if (lmmi_bitmap[j] & (1LL<<i))
d2546 1
a2546 1
      if (lmmi_bitmap[j] & (1LL<<i))
d2551 7
@


1.31
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.30 2018/02/17 16:15:10 nakashim Exp nakashim $";
d2266 20
a2285 1
  /* Step 6 ... emit all                                                                                    */
d2540 1
a2540 1
  /* Step 7 ... emit tgif                                                                                   */
@


1.30
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.29 2018/02/16 06:37:02 nakashim Exp nakashim $";
d2278 1
a2278 1
  for (j=0; j<EMAX_WIDTH; j++)
d2280 2
d2284 1
a2284 1
      if (lmmi[i][j].v) {
d2300 5
a2304 4
#if 0
      else
        fprintf(ofile, "\t*(Uint*)&emax6.lmmi[emax6.lmmic][%d][%d] = 0x00000000;\n", i, j);
#endif
d2440 1
a2440 1
      if (lmmi_bitmap[j] & (1LL<<i)) {
@


1.29
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.28 2018/02/14 10:01:46 nakashim Exp nakashim $";
d2967 18
a2984 13
              bus[h][j].tr[k].v = src_type;
              bus[h][j].tr[k].h = src_hash;
              bus[h][j].tr[k].s = src_sidx;
              bus[h][j].br[k].v = src_type;
              bus[h][j].br[k].h = src_hash;
              bus[h][j].br[k].s = src_sidx;
              switch (k) {
              case 0: conf[h][j].cdw2.brs0 = 2; /* 2:tr0 */ break;
              case 1: conf[h][j].cdw2.brs1 = 2; /* 2:tr1 */ break;
              case 2: conf[h][j].cdw2.brs2 = 2; /* 2:tr2 */ break;
              case 3: conf[h][j].cdw2.brs3 = 2; /* 2:tr3 */ break;
              }
              goto srp_tr_br_ready; /* found & proceed */
@


1.28
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.27 2018/02/09 09:39:15 nakashim Exp nakashim $";
d2506 1
a2506 1
  fprintf(ofile, "asm volatile(\"b emax6_conf_end_%s\\n\"\n\".align 5\\n\"\n\"emax6_conf_%s:\\n\"\n", id[current_prefix].name, id[current_prefix].name, id[current_prefix].name);
d2515 1
a2515 1
  fprintf(ofile, "\"emax6_conf_end_%s:\\n\"\n", id[current_prefix].name);
@


1.27
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.26 2017/12/24 14:12:32 nakashim Exp nakashim $";
d2277 1
d2323 1
a2323 1
	if (lmmi_bitmap[j] & (1LL<<i)) /* 同一conf使用の最後にemax5_drain_dirty_lmm()する前提なので,新lmmi_bitmapと,更新前RANGEの組合せでもOK */
d2332 4
a2335 1
    fprintf(ofile, "\t  int i,j;\n");
d2339 5
a2343 2
    fprintf(ofile, "\t      if (emax6.lmmi_bitmap[j] & (1LL<<i))\n");
    fprintf(ofile, "\t        emax6_check_lmmi_and_dma(%d, 1, %d, i, j);/*drain*/\n", mode, current_mapdist); /* phase=1 drain */
d2481 1
a2481 2
      if (lmmi_bitmap[j] & (1LL<<i)) {
	fprintf(ofile, "\tif (emax6.lmmi[lmmic][%d][%d].ofs) {\n", i, j);
a2486 1
	fprintf(ofile, "\t}\n");
@


1.26
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.25 2017/09/13 04:55:35 nakashim Exp nakashim $";
a1874 1
	  &&(lmmi[i][1].rw==0 || lmmi[i][1].f)
a1897 1
	  &&(lmmi[i][3].rw==0 || lmmi[i][3].f)
a1939 1
         &&(lmmi[i][2].rw==0 || lmmi[i][2].f)
a1955 1
         &&(lmmi[i][3].rw==0 || lmmi[i][3].f)
a1973 1
         &&(lmmi[i][2].rw==0 || lmmi[i][2].f)
a1988 1
         &&(lmmi[i][3].rw==0 || lmmi[i][3].f)
a2005 1
         &&(lmmi[i][2].rw==0 || lmmi[i][2].f)
a2020 1
         &&(lmmi[i][3].rw==0 || lmmi[i][3].f)
@


1.25
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.24 2017/09/12 09:15:58 nakashim Exp nakashim $";
d406 1
@


1.24
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.23 2017/08/19 04:38:04 nakashim Exp nakashim $";
d2433 2
a2437 1
	fprintf(ofile, "\t*(Ull*)&(((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].top) = ((Ull)(emax6.lmmi[emax6.lmmic][%d][%d].top+(*((Ushort*)&emax6.lmmi[emax6.lmmic][%d][%d]+1)+1)*sizeof(Ull)-1)<<32) | (Ull)emax6.lmmi[emax6.lmmic][%d][%d].top;\n", i, j, i, j, i, j, i, j);
d2439 2
a2440 2
	fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].top = emax6.lmmi[emax6.lmmic][%d][%d].top;\n", i, j, i, j);
	fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].bot = emax6.lmmi[emax6.lmmic][%d][%d].top+(*((Ushort*)&emax6.lmmi[emax6.lmmic][%d][%d]+1)+1)*sizeof(Ull)-1;\n", i, j, i, j, i, j);
d2442 1
d2446 1
d2477 2
d2482 6
a2487 3
	fprintf(ofile, "\tif (emax6.lmmi[emax6.lmmic][%d][%d].ofs) {\n", i, j);
	fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].top = emax6.lmmi[emax6.lmmic][%d][%d].top+emax6.lmmi[emax6.lmmic][%d][%d].ofs;\n", i, j, i, j, i, j);
	fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].bot = emax6.lmmi[emax6.lmmic][%d][%d].top+emax6.lmmi[emax6.lmmic][%d][%d].ofs+(*((Ushort*)&emax6.lmmi[emax6.lmmic][%d][%d]+1)+1)*sizeof(Ull)-1;\n", i, j, i, j, i, j, i, j);
d2492 1
@


1.23
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.22 2017/08/19 02:53:20 nakashim Exp nakashim $";
d2298 4
a2301 1
        fprintf(ofile, "\temax6.lmmi[emax6.lmmic][%d][%d].ofs = (Uchar*)%s - (Uchar*)%s;\n", i, j, (char*)lmmi[i][j].top + lmmi[i][j].ofs, (char*)lmmi[i][j].top);
d2436 2
d2440 1
d2477 1
d2480 1
@


1.22
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.21 2017/08/18 12:27:17 nakashim Exp nakashim $";
d2290 2
@


1.21
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.20 2017/08/17 01:31:09 nakashim Exp nakashim $";
a2408 1
	break;	  
@


1.20
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.19 2017/08/16 15:32:38 nakashim Exp nakashim $";
d767 9
d778 3
a780 3
          lmmi[last_row][last_col].rw    = (dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1;
          lmmi[last_row][last_col].f     = dmop1->force;
          lmmi[last_row][last_col].p     = 0; /* initial value */
d810 1
a810 1
            lmmi[last_row][last_col].p   = 1; /* optional prefetch */
d814 9
d825 3
a827 3
            lmmi[last_row+current_mapdist][last_col].rw    = (dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1;
            lmmi[last_row+current_mapdist][last_col].f     = 0;
            lmmi[last_row+current_mapdist][last_col].p     = 1;
d869 9
d880 3
a882 3
          lmmi[last_row][last_col].rw    = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
          lmmi[last_row][last_col].f     = (dmop0->mtype==MTYPE_DLOAD||dmop0->mtype==MTYPE_TRANS)?1:dmop0->force;
          lmmi[last_row][last_col].p     = (dmop0->mtype==MTYPE_DLOAD||dmop0->mtype==MTYPE_TRANS)?1:0; /* initial value */
d892 9
d903 3
a905 3
            lmmi[last_row][last_col].rw    = 0;
            lmmi[last_row][last_col].f     = 1;
            lmmi[last_row][last_col].p     = 1;
d936 1
a936 1
            lmmi[last_row][last_col].p   = 1; /* optional postdrain */
d944 9
d955 3
a957 3
            lmmi[last_row-current_mapdist][last_col].rw    = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
            lmmi[last_row-current_mapdist][last_col].f     = 0;
            lmmi[last_row-current_mapdist][last_col].p     = 1;
d1273 9
d1284 3
a1286 3
          lmmi[last_row][last_col].rw    = (dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1;
          lmmi[last_row][last_col].f     = dmop1->force;
          lmmi[last_row][last_col].p     = 0; /* initial value */
d1316 1
a1316 1
            lmmi[last_row][last_col].p   = 1; /* optional prefetch */
d1320 9
d1331 3
a1333 3
            lmmi[last_row+current_mapdist][last_col].rw    = (dmop1->mtype==MTYPE_RLOAD||dmop1->mtype==MTYPE_DLOAD)?0:1;
            lmmi[last_row+current_mapdist][last_col].f     = 0;
            lmmi[last_row+current_mapdist][last_col].p     = 1;
d1369 9
d1380 3
a1382 3
            lmmi[last_row][last_col].rw    = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
            lmmi[last_row][last_col].f     = dmop0->force;
            lmmi[last_row][last_col].p     = 0; /* initial value */
d1417 1
a1417 1
              lmmi[last_row][last_col].p   = 1; /* optional postdrain */
d1425 9
d1436 3
a1438 3
              lmmi[last_row-current_mapdist][last_col].rw    = (dmop0->mtype==MTYPE_RLOAD||dmop0->mtype==MTYPE_DLOAD)?0:1;
              lmmi[last_row-current_mapdist][last_col].f     = 0;
              lmmi[last_row-current_mapdist][last_col].p     = 1;
@


1.19
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.18 2017/08/16 06:33:55 nakashim Exp nakashim $";
d2268 1
a2268 1
  fprintf(ofile, "\t  Ull *c;\n");
d2273 4
a2276 3
  fprintf(ofile, "\t  c = (Ull*)(((struct reg_ctrl*)emax6.reg_ctrl)->conf);\n");
  fprintf(ofile, "\t  for (i=0; i<sizeof(conf)/sizeof(Ull); i++)\n");
  fprintf(ofile, "\t    *(c+i) = *((Ull*)emax6_conf_%s+i);\n", id[current_prefix].name);
@


1.18
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.17 2017/08/14 13:19:05 nakashim Exp nakashim $";
d2268 1
d2273 1
d2275 1
a2275 1
  fprintf(ofile, "\t    *((Ull*)(((struct reg_ctrl*)emax6.reg_ctrl)->conf)+i) = *((Ull*)emax6_conf_%s+i);\n", id[current_prefix].name);
@


1.17
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.16 2017/08/13 13:36:12 nakashim Exp nakashim $";
d2226 1
a2226 1
    fprintf(ofile, "\temax6.lmmi_bitmap[emax6.lmmic][%d] = 0x%08.8x%08.8xLL;\n", j, lmmi_bitmap[j]);
d2256 1
a2256 1
    fprintf(ofile, "\t      if (emax6.lmmi_bitmap[emax6.lmmic][j] & (1LL<<i))\n");
@


1.16
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.15 2017/08/12 08:51:58 nakashim Exp nakashim $";
d1461 1
@


1.15
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.14 2017/08/09 13:52:33 nakashim Exp nakashim $";
d2244 1
a2244 1
	  fprintf(ofile, "\t  emax6_check_lmmi_and_dma(%d, 1, %d, %d);/*drain*/\n", mode, i, j); /* phase=1 drain */
d2256 1
a2256 1
    fprintf(ofile, "\t        emax6_check_lmmi_and_dma(%d, 1, i, j);/*drain*/\n", mode); /* phase=1 drain */
d2359 1
a2359 1
	fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 2, %d, %d);/*load*/\n", mode, i, j); /* phase=2 load */
d2398 1
a2398 1
	fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, %d);/*pdrain,pload*/\n", mode, i, j); /* phase=3 exec */
@


1.14
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.13 2017/07/25 07:18:47 nakashim Exp nakashim $";
d2348 1
a2348 1
	fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].bot = emax6.lmmi[emax6.lmmic][%d][%d].top+*((Ushort*)&emax6.lmmi[emax6.lmmic][%d][%d]+1)-1;\n", i, j, i, j, i, j);
d2364 1
a2364 1
    fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->cmd = 3LL; // EXEC\n");
d2386 1
a2386 1
	fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].bot = emax6.lmmi[emax6.lmmic][%d][%d].top+emax6.lmmi[emax6.lmmic][%d][%d].ofs+*((Ushort*)&emax6.lmmi[emax6.lmmic][%d][%d]+1)-1;\n", i, j, i, j, i, j, i, j);
@


1.13
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.12 2017/07/19 00:04:08 nakashim Exp nakashim $";
d2406 2
a2407 2
  for (j=0; j<EMAX_WIDTH; j++) {
    for (i=0; i<EMAX_DEPTH; i++) {
@


1.12
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.11 2017/07/18 09:21:35 nakashim Exp nakashim $";
d2402 1
a2402 1
  fprintf(ofile, "\twhile (((struct reg_ctrl*)emax6.reg_ctrl)->stat & 0xff); //LMRING_BUSY|EXRING_BUSY\n");
@


1.11
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.10 2017/06/14 23:32:32 nakashim Exp nakashim $";
d2269 1
a2269 1
  fprintf(ofile, "\t  *(Ull*)(((struct reg_ctrl*)emax6.reg_ctrl)->adtr) = emax_info.ddr_mmap - emax_info.lmm_phys;\n");
d2385 2
a2386 2
	fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].top = emax6.lmmi[emax6.lmmic][%d][%d].top+emax6.lmmi[emax6.lmmic][%d][%d].ofs;\n", i, j, i, j);
	fprintf(ofile, "\t((struct reg_ctrl*)emax6.reg_ctrl)->addr[%d][%d].bot = emax6.lmmi[emax6.lmmic][%d][%d].top+emax6.lmmi[emax6.lmmic][%d][%d].ofs+*((Ushort*)&emax6.lmmi[emax6.lmmic][%d][%d]+1)-1;\n", i, j, i, j, i, j);
@


1.10
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.9 2017/06/10 08:10:36 nakashim Exp nakashim $";
d2229 1
a2229 1
  if (!current_lmmwb) /* for transaction */
@


1.9
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.8 2017/06/04 14:32:23 nakashim Exp nakashim $";
d3829 1
a3829 1
  if (mwsa) {
d3840 1
a3840 1
  if (ea0store || mwsa) {
d3855 1
a3855 1
  if ((ea0store || mwsa) && mws0==0) { col=1; /*red*/   thi=5; } /* lmwd0 */
d3858 1
a3858 1
  if ((ea0store || mwsa) && mws0==1) { col=1; /*red*/   thi=5; } /* exdr */
d3861 1
a3861 1
  if ((ea0store || mwsa) && mws0==2) { col=1; /*red*/   thi=5; } /* ts0 */
d3866 1
a3866 1
  if (ea0store || mwsa) {
d3881 1
a3881 1
  if ((ea0store || mwsa) && mws1==0) { col=1; /*red*/   thi=5; } /* lmwd1 */
d3884 1
a3884 1
  if ((ea0store || mwsa) && mws1==1) { col=1; /*red*/   thi=5; } /* exdr */
d3887 1
a3887 1
  if ((ea0store || mwsa) && mws1==2) { col=1; /*red*/   thi=5; } /* ts1 */
d3892 1
a3892 1
  if (ea0store || mwsa) {
d3907 1
a3907 1
  if ((ea0store || mwsa) && mws2==0) { col=1; /*red*/   thi=5; } /* lmwd2 */
d3910 1
a3910 1
  if ((ea0store || mwsa) && mws2==1) { col=1; /*red*/   thi=5; } /* exdr */
d3913 1
a3913 1
  if ((ea0store || mwsa) && mws2==2) { col=1; /*red*/   thi=5; } /* ts2 */
d3918 1
a3918 1
  if (ea0store || mwsa) {
d3933 1
a3933 1
  if ((ea0store || mwsa) && mws3==0) { col=1; /*red*/   thi=5; } /* lmwd3 */
d3936 1
a3936 1
  if ((ea0store || mwsa) && mws3==1) { col=1; /*red*/   thi=5; } /* exdr */
d3939 1
a3939 1
  if ((ea0store || mwsa) && mws3==2) { col=1; /*red*/   thi=5; } /* ts3 */
@


1.8
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.7 2017/06/04 09:12:29 nakashim Exp nakashim $";
d2229 5
d2364 2
a2365 4
  if (!current_lmmwb) /* for transaction */
    fprintf(ofile, "\temax6_start_with_keep_cache(emax6.dma_ctrl, emax6.reg_ctrl);\n");
  else /* for normal emax */
    fprintf(ofile, "\temax6_start_with_drain_cache(emax6.dma_ctrl, emax6.reg_ctrl);\n");
@


1.7
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.6 2017/06/03 05:05:23 nakashim Exp nakashim $";
d2272 1
a2272 1
  fprintf(ofile, "\telse if (emax6.last_dist>0) {\n");
@


1.6
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.5 2017/06/03 01:22:04 nakashim Exp nakashim $";
d2264 1
a2264 1
  fprintf(ofile, "\t  *(Ull*)(emax6.reg_adtr) = emax_info.ddr_mmap - emax_info.lmm_phys;\n");
d2267 2
a2268 2
  fprintf(ofile, "\t    *((Ull*)(emax6.reg_conf)+i) = *((Ull*)emax6_conf_%s+i);\n", id[current_prefix].name);
  fprintf(ofile, "\t  while (*(Uchar*)emax6.reg_stat & 0xf0); //LMRING_BUSY \n");
d2274 2
a2275 2
  fprintf(ofile, "\t  *(Ull*)(emax6.reg_cmd) = 2LL; // SCON\n");
  fprintf(ofile, "\t  while (*(Uchar*)emax6.reg_stat & 0x0f); //EXRING_BUSY\n");
d2285 1
a2285 1
	    fprintf(ofile, "\temax6.reg_breg->breg[%d][%d].br[%d] = %s;\n", i, j, k, id[regv[i][j].br[k].h].name);
d2287 1
a2287 1
	    fprintf(ofile, "\temax6.reg_breg->breg[%d][%d].br[%d] = %s[%d];\n", i, j, k, id[regv[i][j].br[k].h].name, regv[i][j].br[k].s);
d2298 1
a2298 1
	  fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].ea0b = %s;\n", i, j, id[regv[i][j].ea0b_h].name);
d2300 1
a2300 1
	  fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].ea0b = %s[%d];\n", i, j, id[regv[i][j].ea0b_h].name, regv[i][j].ea0b_s);
d2304 1
a2304 1
	  fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].ea0o = %s;\n", i, j, id[regv[i][j].ea0o_h].name);
d2306 1
a2306 1
	  fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].ea0o = %s[%d];\n", i, j, id[regv[i][j].ea0o_h].name, regv[i][j].ea0o_s);
d2310 1
a2310 1
	  fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].ea1b = %s;\n", i, j, id[regv[i][j].ea1b_h].name);
d2312 1
a2312 1
	  fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].ea1b = %s[%d];\n", i, j, id[regv[i][j].ea1b_h].name, regv[i][j].ea1b_s);
d2316 1
a2316 1
	  fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].ea1o = %s;\n", i, j, id[regv[i][j].ea1o_h].name);
d2318 1
a2318 1
	  fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].ea1o = %s[%d];\n", i, j, id[regv[i][j].ea1o_h].name, regv[i][j].ea1o_s);
d2342 2
a2343 2
	fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].top = emax6.lmmi[emax6.lmmic][%d][%d].top;\n", i, j, i, j);
	fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].bot = emax6.lmmi[emax6.lmmic][%d][%d].top+*((Ushort*)&emax6.lmmi[emax6.lmmic][%d][%d]+1)-1;\n", i, j, i, j, i, j);
d2360 1
a2360 1
    fprintf(ofile, "\temax6_start_with_keep_cache(emax6_conf_%s, &emax6);\n", id[current_prefix].name);
d2362 1
a2362 1
    fprintf(ofile, "\temax6_start_with_drain_cache(emax6_conf_%s, &emax6);\n", id[current_prefix].name);
d2382 2
a2383 2
	fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].top = emax6.lmmi[emax6.lmmic][%d][%d].top+emax6.lmmi[emax6.lmmic][%d][%d].ofs;\n", i, j, i, j);
	fprintf(ofile, "\temax6.reg_addr->addr[%d][%d].bot = emax6.lmmi[emax6.lmmic][%d][%d].top+emax6.lmmi[emax6.lmmic][%d][%d].ofs+*((Ushort*)&emax6.lmmi[emax6.lmmic][%d][%d]+1)-1;\n", i, j, i, j, i, j);
d2399 1
a2399 1
  fprintf(ofile, "\twhile (*(Uchar*)emax6.reg_stat & 0xff); //LMRING_BUSY|EXRING_BUSY\n");
@


1.5
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.4 2017/06/03 00:11:09 nakashim Exp nakashim $";
d2389 1
a2390 8
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (lmmi_bitmap[j] & (1LL<<i))
	fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, %d);/*pdrain*/\n", mode, i, j); /* phase=3 exec */
    }
  }

  /* ■■■dma(pload) */
d2395 1
a2395 1
	fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 3, %d, %d);/*pload*/\n", mode, i, j); /* phase=3 exec */
@


1.4
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.3 2017/06/02 08:37:37 nakashim Exp nakashim $";
d2406 2
@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.2 2017/06/02 02:14:11 nakashim Exp nakashim $";
d2264 1
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.1 2017/06/02 02:00:52 nakashim Exp nakashim $";
d2239 1
a2239 1
	  fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 1, %d, %d);/*drain*/\n", mode, i, j); /* phase=1 drain */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
static char RcsHeader[] = "$Header: /usr/home/nakashim/proj-arm64/src/conv-c2c/RCS/emax6.c,v 1.165 2017/06/01 23:41:51 nakashim Exp $";
d2232 9
a2240 6
  fprintf(ofile, "\temax6.status = STATUS_DRAIN;\n");
  for (i=0; i<EMAX_DEPTH; i++) {
    for (j=0; j<EMAX_WIDTH; j++) {
      if (lmmi_bitmap[j] & (1LL<<i)) /* 同一conf使用の最後にemax5_drain_dirty_lmm()する前提なので,新lmmi_bitmapと,更新前RANGEの組合せでもOK */
	                             /* 但し,SCON後はconf.lmm_modeがずれるので,drainの時にtag_matchしない.drainはlmmi更新後&SCON前 */
	fprintf(ofile, "\temax6_check_lmmi_and_dma(%d, 1, %d, %d);/*drain*/\n", mode, i, j); /* phase=1 drain */
d2242 13
@
